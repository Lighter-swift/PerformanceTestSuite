{"sql":"-- MIT license, see: https:\/\/github.com\/jpwhite3\/northwind-SQLite3\nCREATE TABLE [Categories]\n(      [CategoryID] INTEGER PRIMARY KEY AUTOINCREMENT,\n       [CategoryName] TEXT,\n       [Description] TEXT,\n       [Picture] BLOB\n);\n\nCREATE TABLE [CustomerCustomerDemo](\n   [CustomerID]TEXT NOT NULL,\n   [CustomerTypeID]TEXT NOT NULL,\n   PRIMARY KEY (\"CustomerID\",\"CustomerTypeID\"),\n   FOREIGN KEY ([CustomerID]) REFERENCES [Customers] ([CustomerID])\n    ON DELETE NO ACTION ON UPDATE NO ACTION,\n  FOREIGN KEY ([CustomerTypeID]) REFERENCES [CustomerDemographics] ([CustomerTypeID])\n    ON DELETE NO ACTION ON UPDATE NO ACTION\n);\n\nCREATE TABLE [CustomerDemographics](\n   [CustomerTypeID]TEXT NOT NULL,\n   [CustomerDesc]TEXT,\n    PRIMARY KEY (\"CustomerTypeID\")\n);\n\nCREATE TABLE [Customers]\n(      [CustomerID] TEXT,\n       [CompanyName] TEXT,\n       [ContactName] TEXT,\n       [ContactTitle] TEXT,\n       [Address] TEXT,\n       [City] TEXT,\n       [Region] TEXT,\n       [PostalCode] TEXT,\n       [Country] TEXT,\n       [Phone] TEXT,\n       [Fax] TEXT,\n       PRIMARY KEY (`CustomerID`)\n);\n\nCREATE TABLE [Employees]\n(      [EmployeeID] INTEGER PRIMARY KEY AUTOINCREMENT,\n       [LastName] TEXT,\n       [FirstName] TEXT,\n       [Title] TEXT,\n       [TitleOfCourtesy] TEXT,\n       [BirthDate] DATE,\n       [HireDate] DATE,\n       [Address] TEXT,\n       [City] TEXT,\n       [Region] TEXT,\n       [PostalCode] TEXT,\n       [Country] TEXT,\n       [HomePhone] TEXT,\n       [Extension] TEXT,\n       [Photo] BLOB,\n       [Notes] TEXT,\n       [ReportsTo] INTEGER,\n       [PhotoPath] TEXT,\n     FOREIGN KEY ([ReportsTo]) REFERENCES [Employees] ([EmployeeID])\n    ON DELETE NO ACTION ON UPDATE NO ACTION\n);\n\nCREATE TABLE [EmployeeTerritories](\n   [EmployeeID]INTEGER NOT NULL,\n   [TerritoryID]TEXT NOT NULL,\n    PRIMARY KEY (\"EmployeeID\",\"TerritoryID\"),\n  FOREIGN KEY ([EmployeeID]) REFERENCES [Employees] ([EmployeeID])\n    ON DELETE NO ACTION ON UPDATE NO ACTION,\n  FOREIGN KEY ([TerritoryID]) REFERENCES [Territories] ([TerritoryID])\n    ON DELETE NO ACTION ON UPDATE NO ACTION\n);\n\nCREATE TABLE [Order Details](\n   [OrderID]INTEGER NOT NULL,\n   [ProductID]INTEGER NOT NULL,\n   [UnitPrice]NUMERIC NOT NULL DEFAULT 0,\n   [Quantity]INTEGER NOT NULL DEFAULT 1,\n   [Discount]REAL NOT NULL DEFAULT 0,\n    PRIMARY KEY (\"OrderID\",\"ProductID\"),\n    CHECK ([Discount]>=(0) AND [Discount]<=(1)),\n    CHECK ([Quantity]>(0)),\n    CHECK ([UnitPrice]>=(0)),\n  FOREIGN KEY ([OrderID]) REFERENCES [Orders] ([OrderID])\n    ON DELETE NO ACTION ON UPDATE NO ACTION,\n  FOREIGN KEY ([ProductID]) REFERENCES [Products] ([ProductID])\n    ON DELETE NO ACTION ON UPDATE NO ACTION\n);\n\nCREATE TABLE [Orders](\n   [OrderID]INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n   [CustomerID]TEXT,\n   [EmployeeID]INTEGER,\n   [OrderDate]DATETIME,\n   [RequiredDate]DATETIME,\n   [ShippedDate]DATETIME,\n   [ShipVia]INTEGER,\n   [Freight]NUMERIC DEFAULT 0,\n   [ShipName]TEXT,\n   [ShipAddress]TEXT,\n   [ShipCity]TEXT,\n   [ShipRegion]TEXT,\n   [ShipPostalCode]TEXT,\n   [ShipCountry]TEXT,\n   FOREIGN KEY ([EmployeeID]) REFERENCES [Employees] ([EmployeeID])\n    ON DELETE NO ACTION ON UPDATE NO ACTION,\n  FOREIGN KEY ([CustomerID]) REFERENCES [Customers] ([CustomerID])\n    ON DELETE NO ACTION ON UPDATE NO ACTION,\n  FOREIGN KEY ([ShipVia]) REFERENCES [Shippers] ([ShipperID])\n    ON DELETE NO ACTION ON UPDATE NO ACTION\n);\n\nCREATE TABLE [Products](\n   [ProductID]INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n   [ProductName]TEXT NOT NULL,\n   [SupplierID]INTEGER,\n   [CategoryID]INTEGER,\n   [QuantityPerUnit]TEXT,\n   [UnitPrice]NUMERIC DEFAULT 0,\n   [UnitsInStock]INTEGER DEFAULT 0,\n   [UnitsOnOrder]INTEGER DEFAULT 0,\n   [ReorderLevel]INTEGER DEFAULT 0,\n   [Discontinued]TEXT NOT NULL DEFAULT '0',\n    CHECK ([UnitPrice]>=(0)),\n    CHECK ([ReorderLevel]>=(0)),\n    CHECK ([UnitsInStock]>=(0)),\n    CHECK ([UnitsOnOrder]>=(0)),\n  FOREIGN KEY ([ProductID]) REFERENCES [Categories] ([CategoryID])\n    ON DELETE NO ACTION ON UPDATE NO ACTION,\n  FOREIGN KEY ([SupplierID]) REFERENCES [Suppliers] ([SupplierID])\n    ON DELETE NO ACTION ON UPDATE NO ACTION\n);\n\nCREATE TABLE [Regions](\n   [RegionID]INTEGER NOT NULL PRIMARY KEY,\n   [RegionDescription]TEXT NOT NULL\n);\n\nCREATE TABLE [Shippers](\n   [ShipperID]INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n   [CompanyName]TEXT NOT NULL,\n   [Phone]TEXT\n);\n\nCREATE TABLE [Suppliers](\n   [SupplierID]INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n   [CompanyName]TEXT NOT NULL,\n   [ContactName]TEXT,\n   [ContactTitle]TEXT,\n   [Address]TEXT,\n   [City]TEXT,\n   [Region]TEXT,\n   [PostalCode]TEXT,\n   [Country]TEXT,\n   [Phone]TEXT,\n   [Fax]TEXT,\n   [HomePage]TEXT\n);\n\nCREATE TABLE [Territories](\n   [TerritoryID]TEXT NOT NULL,\n   [TerritoryDescription]TEXT NOT NULL,\n   [RegionID]INTEGER NOT NULL,\n    PRIMARY KEY (\"TerritoryID\"),\n  FOREIGN KEY ([RegionID]) REFERENCES [Regions] ([RegionID])\n    ON DELETE NO ACTION ON UPDATE NO ACTION\n);\n\nCREATE VIEW [Alphabetical list of products]\nAS\nSELECT Products.*,\n       Categories.CategoryName\nFROM Categories\n   INNER JOIN Products ON Categories.CategoryID = Products.CategoryID\nWHERE (((Products.Discontinued)=0));\n\nCREATE VIEW [Current Product List]\nAS\nSELECT ProductID,\n       ProductName\nFROM Products\nWHERE Discontinued=0;\n\nCREATE VIEW [Customer and Suppliers by City]\nAS\nSELECT City,\n       CompanyName,\n       ContactName,\n       'Customers' AS Relationship\nFROM Customers\nUNION\nSELECT City,\n       CompanyName,\n       ContactName,\n       'Suppliers'\nFROM Suppliers\nORDER BY City, CompanyName;\n\nCREATE VIEW [Invoices]\nAS\nSELECT Orders.ShipName,\n       Orders.ShipAddress,\n       Orders.ShipCity,\n       Orders.ShipRegion,\n       Orders.ShipPostalCode,\n       Orders.ShipCountry,\n       Orders.CustomerID,\n       Customers.CompanyName AS CustomerName,\n       Customers.Address,\n       Customers.City,\n       Customers.Region,\n       Customers.PostalCode,\n       Customers.Country,\n       (Employees.FirstName + ' ' + Employees.LastName) AS Salesperson,\n       Orders.OrderID,\n       Orders.OrderDate,\n       Orders.RequiredDate,\n       Orders.ShippedDate,\n       Shippers.CompanyName As ShipperName,\n       [Order Details].ProductID,\n       Products.ProductName,\n       [Order Details].UnitPrice,\n       [Order Details].Quantity,\n       [Order Details].Discount,\n       ((([Order Details].UnitPrice*Quantity*(1-Discount))\/100)*100) AS ExtendedPrice,\n       Orders.Freight\nFROM Customers\n  JOIN Orders ON Customers.CustomerID = Orders.CustomerID\n    JOIN Employees ON Employees.EmployeeID = Orders.EmployeeID\n     JOIN [Order Details] ON Orders.OrderID = [Order Details].OrderID\n      JOIN Products ON Products.ProductID = [Order Details].ProductID\n       JOIN Shippers ON Shippers.ShipperID = Orders.ShipVia;\n\nCREATE VIEW [Orders Qry] AS\nSELECT Orders.OrderID,\n       Orders.CustomerID,\n       Orders.EmployeeID,\n       Orders.OrderDate,\n       Orders.RequiredDate,\n       Orders.ShippedDate,\n       Orders.ShipVia,\n       Orders.Freight,\n       Orders.ShipName,\n       Orders.ShipAddress,\n       Orders.ShipCity,\n       Orders.ShipRegion,\n       Orders.ShipPostalCode,\n       Orders.ShipCountry,\n       Customers.CompanyName,\n       Customers.Address,\n       Customers.City,\n       Customers.Region,\n       Customers.PostalCode,\n       Customers.Country\nFROM Customers\n     JOIN Orders ON Customers.CustomerID = Orders.CustomerID;\n\nCREATE VIEW [Order Subtotals] AS\nSELECT [Order Details].OrderID,\nSum(([Order Details].UnitPrice*Quantity*(1-Discount)\/100)*100) AS Subtotal\nFROM [Order Details]\nGROUP BY [Order Details].OrderID;\n\nCREATE VIEW [Product Sales for 1997] AS\nSELECT Categories.CategoryName,\n       Products.ProductName,\n       Sum(([Order Details].UnitPrice*Quantity*(1-Discount)\/100)*100) AS ProductSales\nFROM Categories\n JOIN    Products On Categories.CategoryID = Products.CategoryID\n    JOIN  [Order Details] on Products.ProductID = [Order Details].ProductID\n     JOIN  [Orders] on Orders.OrderID = [Order Details].OrderID\nWHERE Orders.ShippedDate Between DATETIME('1997-01-01') And DATETIME('1997-12-31')\nGROUP BY Categories.CategoryName, Products.ProductName;\n\nCREATE VIEW [Products Above Average Price] AS\nSELECT Products.ProductName,\n       Products.UnitPrice\nFROM Products\nWHERE Products.UnitPrice>(SELECT AVG(UnitPrice) From Products);\n\nCREATE VIEW [Products by Category] AS\nSELECT Categories.CategoryName,\n       Products.ProductName,\n       Products.QuantityPerUnit,\n       Products.UnitsInStock,\n       Products.Discontinued\nFROM Categories\n     INNER JOIN Products ON Categories.CategoryID = Products.CategoryID\nWHERE Products.Discontinued <> 1;\n\nCREATE VIEW [Quarterly Orders] AS\nSELECT DISTINCT Customers.CustomerID,\n                Customers.CompanyName,\n                Customers.City,\n                Customers.Country\nFROM Customers\n     JOIN Orders ON Customers.CustomerID = Orders.CustomerID\nWHERE Orders.OrderDate BETWEEN DATETIME('1997-01-01') And DATETIME('1997-12-31');\n\nCREATE VIEW [Sales Totals by Amount] AS\nSELECT [Order Subtotals].Subtotal AS SaleAmount,\n                  Orders.OrderID,\n               Customers.CompanyName,\n                  Orders.ShippedDate\nFROM Customers\n JOIN Orders ON Customers.CustomerID = Orders.CustomerID\n    JOIN [Order Subtotals] ON Orders.OrderID = [Order Subtotals].OrderID\nWHERE ([Order Subtotals].Subtotal >2500)\nAND (Orders.ShippedDate BETWEEN DATETIME('1997-01-01') And DATETIME('1997-12-31'));\n\nCREATE VIEW [Summary of Sales by Quarter] AS\nSELECT Orders.ShippedDate,\n       Orders.OrderID,\n       [Order Subtotals].Subtotal\nFROM Orders\n     INNER JOIN [Order Subtotals] ON Orders.OrderID = [Order Subtotals].OrderID\nWHERE Orders.ShippedDate IS NOT NULL;\n\nCREATE VIEW [Summary of Sales by Year] AS\nSELECT      Orders.ShippedDate,\n            Orders.OrderID,\n [Order Subtotals].Subtotal\nFROM Orders\n     INNER JOIN [Order Subtotals] ON Orders.OrderID = [Order Subtotals].OrderID\nWHERE Orders.ShippedDate IS NOT NULL;\n\nCREATE VIEW [Category Sales for 1997] AS\nSELECT     [Product Sales for 1997].CategoryName,\n       Sum([Product Sales for 1997].ProductSales) AS CategorySales\nFROM [Product Sales for 1997]\nGROUP BY [Product Sales for 1997].CategoryName;\n\nCREATE VIEW [Order Details Extended] AS\nSELECT [Order Details].OrderID,\n       [Order Details].ProductID,\n       Products.ProductName,\n     [Order Details].UnitPrice,\n       [Order Details].Quantity,\n       [Order Details].Discount,\n      ([Order Details].UnitPrice*Quantity*(1-Discount)\/100)*100 AS ExtendedPrice\nFROM Products\n     JOIN [Order Details] ON Products.ProductID = [Order Details].ProductID;\n\nCREATE VIEW [Sales by Category] AS\nSELECT Categories.CategoryID,\n       Categories.CategoryName,\n         Products.ProductName,\n  Sum([Order Details Extended].ExtendedPrice) AS ProductSales\nFROM  Categories\n    JOIN Products\n      ON Categories.CategoryID = Products.CategoryID\n       JOIN [Order Details Extended]\n         ON Products.ProductID = [Order Details Extended].ProductID\n           JOIN Orders\n             ON Orders.OrderID = [Order Details Extended].OrderID\nWHERE Orders.OrderDate BETWEEN DATETIME('1997-01-01') And DATETIME('1997-12-31')\nGROUP BY Categories.CategoryID, Categories.CategoryName, Products.ProductName;\n","EmbeddedLighter":{"updates":{"predicateBased":0,"keyBased":0},"selects":{"syncYield":{"columns":8,"sorts":2},"asyncArray":{"columns":8,"sorts":2},"syncArray":{"sorts":2,"columns":8}},"inserts":0},"swift":"import SQLite3\nimport Foundation\nimport Lighter\n\n\/**\n * A structure representing a SQLite database.\n * \n * ### Database Schema\n * \n * The schema captures the SQLite table\/view catalog as safe Swift types.\n * \n * #### Tables\n * \n * - ``Category``                   (SQL: `Categories`)\n * - ``CustomerCustomerDemo``       (SQL: `CustomerCustomerDemo`)\n * - ``CustomerDemographic``        (SQL: `CustomerDemographics`)\n * - ``Customer``                   (SQL: `Customers`)\n * - ``Employee``                   (SQL: `Employees`)\n * - ``EmployeeTerritory``          (SQL: `EmployeeTerritories`)\n * - ``OrderDetail``                (SQL: `Order Details`)\n * - ``Order``                      (SQL: `Orders`)\n * - ``Product``                    (SQL: `Products`)\n * - ``Region``                     (SQL: `Regions`)\n * - ``Shipper``                    (SQL: `Shippers`)\n * - ``Supplier``                   (SQL: `Suppliers`)\n * - ``Territory``                  (SQL: `Territories`)\n * \n * #### Views\n * \n * - ``AlphabeticalListOfProduct``  (SQL: `Alphabetical list of products`)\n * - ``CurrentProductList``         (SQL: `Current Product List`)\n * - ``CustomerAndSuppliersByCity`` (SQL: `Customer and Suppliers by City`)\n * - ``Invoice``                    (SQL: `Invoices`)\n * - ``OrdersQry``                  (SQL: `Orders Qry`)\n * - ``OrderSubtotal``              (SQL: `Order Subtotals`)\n * - ``ProductSalesFor1997``        (SQL: `Product Sales for 1997`)\n * - ``ProductsAboveAveragePrice``  (SQL: `Products Above Average Price`)\n * - ``ProductsByCategory``         (SQL: `Products by Category`)\n * - ``QuarterlyOrder``             (SQL: `Quarterly Orders`)\n * - ``SalesTotalsByAmount``        (SQL: `Sales Totals by Amount`)\n * - ``SummaryOfSalesByQuarter``    (SQL: `Summary of Sales by Quarter`)\n * - ``SummaryOfSalesByYear``       (SQL: `Summary of Sales by Year`)\n * - ``CategorySalesFor1997``       (SQL: `Category Sales for 1997`)\n * - ``OrderDetailsExtended``       (SQL: `Order Details Extended`)\n * - ``SalesByCategory``            (SQL: `Sales by Category`)\n * \n * \n * ### Examples\n * \n * Perform record operations on ``Category`` records:\n * ```swift\n * let records = try await db.categories.filter(orderBy: \\.categoryName) {\n *   $0.categoryName != nil\n * }\n * ```\n * \n * Perform column selects on the `Categories` table:\n * ```swift\n * let values = try await db.select(from: \\.categories, \\.categoryName) {\n *   $0.in([ 2, 3 ])\n * }\n * ```\n * \n * Perform low level operations on ``Category`` records:\n * ```swift\n * var db : OpaquePointer?\n * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n * \n * let records = Category.fetch(in: db, orderBy: \"categoryName\", limit: 5) {\n *   $0.categoryName != nil\n * }\n * ```\n *\/\n@dynamicMemberLookup\npublic struct NorthwindLighter : SQLDatabase, SQLDatabaseFetchOperations {\n  \n  \/**\n   * Mappings of table\/view Swift types to their \"reference name\".\n   * \n   * The `RecordTypes` structure contains a variable for the Swift type\n   * associated each table\/view of the database. It maps the tables\n   * \"reference names\" (e.g. ``categories``) to the\n   * \"record type\" of the table (e.g. ``Category``.self).\n   *\/\n  public struct RecordTypes {\n    \n    \/\/\/ Returns the Category type information (SQL: `Categories`).\n    public let categories = Category.self\n    \n    \/\/\/ Returns the CustomerCustomerDemo type information (SQL: `CustomerCustomerDemo`).\n    public let customerCustomerDemos = CustomerCustomerDemo.self\n    \n    \/\/\/ Returns the CustomerDemographic type information (SQL: `CustomerDemographics`).\n    public let customerDemographics = CustomerDemographic.self\n    \n    \/\/\/ Returns the Customer type information (SQL: `Customers`).\n    public let customers = Customer.self\n    \n    \/\/\/ Returns the Employee type information (SQL: `Employees`).\n    public let employees = Employee.self\n    \n    \/\/\/ Returns the EmployeeTerritory type information (SQL: `EmployeeTerritories`).\n    public let employeeTerritories = EmployeeTerritory.self\n    \n    \/\/\/ Returns the OrderDetail type information (SQL: `Order Details`).\n    public let orderDetails = OrderDetail.self\n    \n    \/\/\/ Returns the Order type information (SQL: `Orders`).\n    public let orders = Order.self\n    \n    \/\/\/ Returns the Product type information (SQL: `Products`).\n    public let products = Product.self\n    \n    \/\/\/ Returns the Region type information (SQL: `Regions`).\n    public let regions = Region.self\n    \n    \/\/\/ Returns the Shipper type information (SQL: `Shippers`).\n    public let shippers = Shipper.self\n    \n    \/\/\/ Returns the Supplier type information (SQL: `Suppliers`).\n    public let suppliers = Supplier.self\n    \n    \/\/\/ Returns the Territory type information (SQL: `Territories`).\n    public let territories = Territory.self\n    \n    \/\/\/ Returns the AlphabeticalListOfProduct type information (SQL: `Alphabetical list of products`).\n    public let alphabeticalListOfProducts = AlphabeticalListOfProduct.self\n    \n    \/\/\/ Returns the CurrentProductList type information (SQL: `Current Product List`).\n    public let currentProductLists = CurrentProductList.self\n    \n    \/\/\/ Returns the CustomerAndSuppliersByCity type information (SQL: `Customer and Suppliers by City`).\n    public let customerAndSuppliersByCities = CustomerAndSuppliersByCity.self\n    \n    \/\/\/ Returns the Invoice type information (SQL: `Invoices`).\n    public let invoices = Invoice.self\n    \n    \/\/\/ Returns the OrdersQry type information (SQL: `Orders Qry`).\n    public let ordersQries = OrdersQry.self\n    \n    \/\/\/ Returns the OrderSubtotal type information (SQL: `Order Subtotals`).\n    public let orderSubtotals = OrderSubtotal.self\n    \n    \/\/\/ Returns the ProductSalesFor1997 type information (SQL: `Product Sales for 1997`).\n    public let productSalesFor1997s = ProductSalesFor1997.self\n    \n    \/\/\/ Returns the ProductsAboveAveragePrice type information (SQL: `Products Above Average Price`).\n    public let productsAboveAveragePrices = ProductsAboveAveragePrice.self\n    \n    \/\/\/ Returns the ProductsByCategory type information (SQL: `Products by Category`).\n    public let productsByCategories = ProductsByCategory.self\n    \n    \/\/\/ Returns the QuarterlyOrder type information (SQL: `Quarterly Orders`).\n    public let quarterlyOrders = QuarterlyOrder.self\n    \n    \/\/\/ Returns the SalesTotalsByAmount type information (SQL: `Sales Totals by Amount`).\n    public let salesTotalsByAmounts = SalesTotalsByAmount.self\n    \n    \/\/\/ Returns the SummaryOfSalesByQuarter type information (SQL: `Summary of Sales by Quarter`).\n    public let summaryOfSalesByQuarters = SummaryOfSalesByQuarter.self\n    \n    \/\/\/ Returns the SummaryOfSalesByYear type information (SQL: `Summary of Sales by Year`).\n    public let summaryOfSalesByYears = SummaryOfSalesByYear.self\n    \n    \/\/\/ Returns the CategorySalesFor1997 type information (SQL: `Category Sales for 1997`).\n    public let categorySalesFor1997s = CategorySalesFor1997.self\n    \n    \/\/\/ Returns the OrderDetailsExtended type information (SQL: `Order Details Extended`).\n    public let orderDetailsExtendeds = OrderDetailsExtended.self\n    \n    \/\/\/ Returns the SalesByCategory type information (SQL: `Sales by Category`).\n    public let salesByCategories = SalesByCategory.self\n  }\n  \n  \/**\n   * Record representing the `Categories` SQL table.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``Category`` records:\n   * ```swift\n   * let records = try await db.categories.filter(orderBy: \\.categoryName) {\n   *   $0.categoryName != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Categories` table:\n   * ```swift\n   * let values = try await db.select(from: \\.categories, \\.categoryName) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``Category`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = Category.fetch(in: db, orderBy: \"categoryName\", limit: 5) {\n   *   $0.categoryName != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the table associated with the record:\n   * ```sql\n   * CREATE TABLE [Categories]\n   * (      [CategoryID] INTEGER PRIMARY KEY AUTOINCREMENT,\n   *        [CategoryName] TEXT,\n   *        [Description] TEXT,\n   *        [Picture] BLOB\n   * )\n   * ```\n   *\/\n  public struct Category : Identifiable, SQLKeyedTableRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``Category`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Primary key `CategoryID` (`INTEGER`), optional (default: `nil`).\n    public var id : Int?\n    \n    \/\/\/ Column `CategoryName` (`TEXT`), optional (default: `nil`).\n    public var categoryName : String?\n    \n    \/\/\/ Column `Description` (`TEXT`), optional (default: `nil`).\n    public var description : String?\n    \n    \/\/\/ Column `Picture` (`BLOB`), optional (default: `nil`).\n    public var picture : [ UInt8 ]?\n    \n    \/**\n     * Initialize a new ``Category`` record.\n     * \n     * - Parameters:\n     *   - id: Primary key `CategoryID` (`INTEGER`), optional (default: `nil`).\n     *   - categoryName: Column `CategoryName` (`TEXT`), optional (default: `nil`).\n     *   - description: Column `Description` (`TEXT`), optional (default: `nil`).\n     *   - picture: Column `Picture` (`BLOB`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(\n      id: Int? = nil,\n      categoryName: String? = nil,\n      description: String? = nil,\n      picture: [ UInt8 ]? = nil\n    )\n    {\n      self.id = id\n      self.categoryName = categoryName\n      self.description = description\n      self.picture = picture\n    }\n  }\n  \n  \/**\n   * Record representing the `CustomerCustomerDemo` SQL table.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``CustomerCustomerDemo`` records:\n   * ```swift\n   * let records = try await db.customerCustomerDemos.filter(orderBy: \\.customerID) {\n   *   $0.customerID != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `CustomerCustomerDemo` table:\n   * ```swift\n   * let values = try await db.select(from: \\.customerCustomerDemos, \\.customerID) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``CustomerCustomerDemo`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = CustomerCustomerDemo.fetch(in: db, orderBy: \"customerID\", limit: 5) {\n   *   $0.customerID != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the table associated with the record:\n   * ```sql\n   * CREATE TABLE [CustomerCustomerDemo](\n   *    [CustomerID]TEXT NOT NULL,\n   *    [CustomerTypeID]TEXT NOT NULL,\n   *    PRIMARY KEY (\"CustomerID\",\"CustomerTypeID\"),\n   *    FOREIGN KEY ([CustomerID]) REFERENCES [Customers] ([CustomerID])\n   *     ON DELETE NO ACTION ON UPDATE NO ACTION,\n   *   FOREIGN KEY ([CustomerTypeID]) REFERENCES [CustomerDemographics] ([CustomerTypeID])\n   *     ON DELETE NO ACTION ON UPDATE NO ACTION\n   * )\n   * ```\n   *\/\n  public struct CustomerCustomerDemo : Identifiable, SQLTableRecord, Codable {\n    \n    \/**\n     * ID structure representing the compound key of ``CustomerCustomerDemo``.\n     *\/\n    public struct ID : Hashable {\n      \n      public let customerID : String\n      public let customerTypeID : String\n      \n      \/**\n       * Initialize a compound ``CustomerCustomerDemo`` ``ID``\n       * \n       * - Parameters:\n       *   - customerID: Value of ``CustomerCustomerDemo\/customerID``.\n       *   - customerTypeID: Value of ``CustomerCustomerDemo\/customerTypeID``.\n       *\/\n      @inlinable\n      public init(_ customerID: String, _ customerTypeID: String)\n      {\n        self.customerID = customerID\n        self.customerTypeID = customerTypeID\n      }\n    }\n    \n    \/\/\/ Static SQL type information for the ``CustomerCustomerDemo`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Primary key `CustomerID` (`TEXT`), required (has default).\n    public var customerID : String\n    \n    \/\/\/ Primary key `CustomerTypeID` (`TEXT`), required (has default).\n    public var customerTypeID : String\n    \n    \/\/\/ Returns the compound primary key of ``CustomerCustomerDemo`` (customerID, customerTypeID).\n    @inlinable\n    public var id : ID { ID(customerID, customerTypeID) }\n    \n    \/**\n     * Initialize a new ``CustomerCustomerDemo`` record.\n     * \n     * - Parameters:\n     *   - customerID: Primary key `CustomerID` (`TEXT`), required (has default).\n     *   - customerTypeID: Primary key `CustomerTypeID` (`TEXT`), required (has default).\n     *\/\n    @inlinable\n    public init(customerID: String, customerTypeID: String)\n    {\n      self.customerID = customerID\n      self.customerTypeID = customerTypeID\n    }\n  }\n  \n  \/**\n   * Record representing the `CustomerDemographics` SQL table.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``CustomerDemographic`` records:\n   * ```swift\n   * let records = try await db.customerDemographics.filter(orderBy: \\.id) {\n   *   $0.id != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `CustomerDemographics` table:\n   * ```swift\n   * let values = try await db.select(from: \\.customerDemographics, \\.id) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``CustomerDemographic`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = CustomerDemographic.fetch(in: db, orderBy: \"id\", limit: 5) {\n   *   $0.id != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the table associated with the record:\n   * ```sql\n   * CREATE TABLE [CustomerDemographics](\n   *    [CustomerTypeID]TEXT NOT NULL,\n   *    [CustomerDesc]TEXT,\n   *     PRIMARY KEY (\"CustomerTypeID\")\n   * )\n   * ```\n   *\/\n  public struct CustomerDemographic : Identifiable, SQLKeyedTableRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``CustomerDemographic`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Primary key `CustomerTypeID` (`TEXT`), required (has default).\n    public var id : String\n    \n    \/\/\/ Column `CustomerDesc` (`TEXT`), optional (default: `nil`).\n    public var customerDesc : String?\n    \n    \/**\n     * Initialize a new ``CustomerDemographic`` record.\n     * \n     * - Parameters:\n     *   - id: Primary key `CustomerTypeID` (`TEXT`), required (has default).\n     *   - customerDesc: Column `CustomerDesc` (`TEXT`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(id: String, customerDesc: String? = nil)\n    {\n      self.id = id\n      self.customerDesc = customerDesc\n    }\n  }\n  \n  \/**\n   * Record representing the `Customers` SQL table.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``Customer`` records:\n   * ```swift\n   * let records = try await db.customers.filter(orderBy: \\.id) {\n   *   $0.id != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Customers` table:\n   * ```swift\n   * let values = try await db.select(from: \\.customers, \\.id) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``Customer`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = Customer.fetch(in: db, orderBy: \"id\", limit: 5) {\n   *   $0.id != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the table associated with the record:\n   * ```sql\n   * CREATE TABLE [Customers]\n   * (      [CustomerID] TEXT,\n   *        [CompanyName] TEXT,\n   *        [ContactName] TEXT,\n   *        [ContactTitle] TEXT,\n   *        [Address] TEXT,\n   *        [City] TEXT,\n   *        [Region] TEXT,\n   *        [PostalCode] TEXT,\n   *        [Country] TEXT,\n   *        [Phone] TEXT,\n   *        [Fax] TEXT,\n   *        PRIMARY KEY (`CustomerID`)\n   * )\n   * ```\n   *\/\n  public struct Customer : Identifiable, SQLKeyedTableRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``Customer`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Primary key `CustomerID` (`TEXT`), optional (default: `nil`).\n    public var id : String?\n    \n    \/\/\/ Column `CompanyName` (`TEXT`), optional (default: `nil`).\n    public var companyName : String?\n    \n    \/\/\/ Column `ContactName` (`TEXT`), optional (default: `nil`).\n    public var contactName : String?\n    \n    \/\/\/ Column `ContactTitle` (`TEXT`), optional (default: `nil`).\n    public var contactTitle : String?\n    \n    \/\/\/ Column `Address` (`TEXT`), optional (default: `nil`).\n    public var address : String?\n    \n    \/\/\/ Column `City` (`TEXT`), optional (default: `nil`).\n    public var city : String?\n    \n    \/\/\/ Column `Region` (`TEXT`), optional (default: `nil`).\n    public var region : String?\n    \n    \/\/\/ Column `PostalCode` (`TEXT`), optional (default: `nil`).\n    public var postalCode : String?\n    \n    \/\/\/ Column `Country` (`TEXT`), optional (default: `nil`).\n    public var country : String?\n    \n    \/\/\/ Column `Phone` (`TEXT`), optional (default: `nil`).\n    public var phone : String?\n    \n    \/\/\/ Column `Fax` (`TEXT`), optional (default: `nil`).\n    public var fax : String?\n    \n    \/**\n     * Initialize a new ``Customer`` record.\n     * \n     * - Parameters:\n     *   - id: Primary key `CustomerID` (`TEXT`), optional (default: `nil`).\n     *   - companyName: Column `CompanyName` (`TEXT`), optional (default: `nil`).\n     *   - contactName: Column `ContactName` (`TEXT`), optional (default: `nil`).\n     *   - contactTitle: Column `ContactTitle` (`TEXT`), optional (default: `nil`).\n     *   - address: Column `Address` (`TEXT`), optional (default: `nil`).\n     *   - city: Column `City` (`TEXT`), optional (default: `nil`).\n     *   - region: Column `Region` (`TEXT`), optional (default: `nil`).\n     *   - postalCode: Column `PostalCode` (`TEXT`), optional (default: `nil`).\n     *   - country: Column `Country` (`TEXT`), optional (default: `nil`).\n     *   - phone: Column `Phone` (`TEXT`), optional (default: `nil`).\n     *   - fax: Column `Fax` (`TEXT`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(\n      id: String? = nil,\n      companyName: String? = nil,\n      contactName: String? = nil,\n      contactTitle: String? = nil,\n      address: String? = nil,\n      city: String? = nil,\n      region: String? = nil,\n      postalCode: String? = nil,\n      country: String? = nil,\n      phone: String? = nil,\n      fax: String? = nil\n    )\n    {\n      self.id = id\n      self.companyName = companyName\n      self.contactName = contactName\n      self.contactTitle = contactTitle\n      self.address = address\n      self.city = city\n      self.region = region\n      self.postalCode = postalCode\n      self.country = country\n      self.phone = phone\n      self.fax = fax\n    }\n  }\n  \n  \/**\n   * Record representing the `Employees` SQL table.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``Employee`` records:\n   * ```swift\n   * let records = try await db.employees.filter(orderBy: \\.lastName) {\n   *   $0.lastName != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Employees` table:\n   * ```swift\n   * let values = try await db.select(from: \\.employees, \\.lastName) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``Employee`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = Employee.fetch(in: db, orderBy: \"lastName\", limit: 5) {\n   *   $0.lastName != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the table associated with the record:\n   * ```sql\n   * CREATE TABLE [Employees]\n   * (      [EmployeeID] INTEGER PRIMARY KEY AUTOINCREMENT,\n   *        [LastName] TEXT,\n   *        [FirstName] TEXT,\n   *        [Title] TEXT,\n   *        [TitleOfCourtesy] TEXT,\n   *        [BirthDate] DATE,\n   *        [HireDate] DATE,\n   *        [Address] TEXT,\n   *        [City] TEXT,\n   *        [Region] TEXT,\n   *        [PostalCode] TEXT,\n   *        [Country] TEXT,\n   *        [HomePhone] TEXT,\n   *        [Extension] TEXT,\n   *        [Photo] BLOB,\n   *        [Notes] TEXT,\n   *        [ReportsTo] INTEGER,\n   *        [PhotoPath] TEXT,\n   *      FOREIGN KEY ([ReportsTo]) REFERENCES [Employees] ([EmployeeID])\n   *     ON DELETE NO ACTION ON UPDATE NO ACTION\n   * )\n   * ```\n   *\/\n  public struct Employee : Identifiable, SQLKeyedTableRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``Employee`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Primary key `EmployeeID` (`INTEGER`), optional (default: `nil`).\n    public var id : Int?\n    \n    \/\/\/ Column `LastName` (`TEXT`), optional (default: `nil`).\n    public var lastName : String?\n    \n    \/\/\/ Column `FirstName` (`TEXT`), optional (default: `nil`).\n    public var firstName : String?\n    \n    \/\/\/ Column `Title` (`TEXT`), optional (default: `nil`).\n    public var title : String?\n    \n    \/\/\/ Column `TitleOfCourtesy` (`TEXT`), optional (default: `nil`).\n    public var titleOfCourtesy : String?\n    \n    \/\/\/ Column `BirthDate` (`DATE`), optional (default: `nil`).\n    public var birthDate : String?\n    \n    \/\/\/ Column `HireDate` (`DATE`), optional (default: `nil`).\n    public var hireDate : String?\n    \n    \/\/\/ Column `Address` (`TEXT`), optional (default: `nil`).\n    public var address : String?\n    \n    \/\/\/ Column `City` (`TEXT`), optional (default: `nil`).\n    public var city : String?\n    \n    \/\/\/ Column `Region` (`TEXT`), optional (default: `nil`).\n    public var region : String?\n    \n    \/\/\/ Column `PostalCode` (`TEXT`), optional (default: `nil`).\n    public var postalCode : String?\n    \n    \/\/\/ Column `Country` (`TEXT`), optional (default: `nil`).\n    public var country : String?\n    \n    \/\/\/ Column `HomePhone` (`TEXT`), optional (default: `nil`).\n    public var homePhone : String?\n    \n    \/\/\/ Column `Extension` (`TEXT`), optional (default: `nil`).\n    public var `extension` : String?\n    \n    \/\/\/ Column `Photo` (`BLOB`), optional (default: `nil`).\n    public var photo : [ UInt8 ]?\n    \n    \/\/\/ Column `Notes` (`TEXT`), optional (default: `nil`).\n    public var notes : String?\n    \n    \/\/\/ Column `ReportsTo` (`INTEGER`), optional (default: `nil`).\n    public var reportsTo : Int?\n    \n    \/\/\/ Column `PhotoPath` (`TEXT`), optional (default: `nil`).\n    public var photoPath : String?\n    \n    \/**\n     * Initialize a new ``Employee`` record.\n     * \n     * - Parameters:\n     *   - id: Primary key `EmployeeID` (`INTEGER`), optional (default: `nil`).\n     *   - lastName: Column `LastName` (`TEXT`), optional (default: `nil`).\n     *   - firstName: Column `FirstName` (`TEXT`), optional (default: `nil`).\n     *   - title: Column `Title` (`TEXT`), optional (default: `nil`).\n     *   - titleOfCourtesy: Column `TitleOfCourtesy` (`TEXT`), optional (default: `nil`).\n     *   - birthDate: Column `BirthDate` (`DATE`), optional (default: `nil`).\n     *   - hireDate: Column `HireDate` (`DATE`), optional (default: `nil`).\n     *   - address: Column `Address` (`TEXT`), optional (default: `nil`).\n     *   - city: Column `City` (`TEXT`), optional (default: `nil`).\n     *   - region: Column `Region` (`TEXT`), optional (default: `nil`).\n     *   - postalCode: Column `PostalCode` (`TEXT`), optional (default: `nil`).\n     *   - country: Column `Country` (`TEXT`), optional (default: `nil`).\n     *   - homePhone: Column `HomePhone` (`TEXT`), optional (default: `nil`).\n     *   - extension: Column `Extension` (`TEXT`), optional (default: `nil`).\n     *   - photo: Column `Photo` (`BLOB`), optional (default: `nil`).\n     *   - notes: Column `Notes` (`TEXT`), optional (default: `nil`).\n     *   - reportsTo: Column `ReportsTo` (`INTEGER`), optional (default: `nil`).\n     *   - photoPath: Column `PhotoPath` (`TEXT`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(\n      id: Int? = nil,\n      lastName: String? = nil,\n      firstName: String? = nil,\n      title: String? = nil,\n      titleOfCourtesy: String? = nil,\n      birthDate: String? = nil,\n      hireDate: String? = nil,\n      address: String? = nil,\n      city: String? = nil,\n      region: String? = nil,\n      postalCode: String? = nil,\n      country: String? = nil,\n      homePhone: String? = nil,\n      `extension`: String? = nil,\n      photo: [ UInt8 ]? = nil,\n      notes: String? = nil,\n      reportsTo: Int? = nil,\n      photoPath: String? = nil\n    )\n    {\n      self.id = id\n      self.lastName = lastName\n      self.firstName = firstName\n      self.title = title\n      self.titleOfCourtesy = titleOfCourtesy\n      self.birthDate = birthDate\n      self.hireDate = hireDate\n      self.address = address\n      self.city = city\n      self.region = region\n      self.postalCode = postalCode\n      self.country = country\n      self.homePhone = homePhone\n      self.`extension` = `extension`\n      self.photo = photo\n      self.notes = notes\n      self.reportsTo = reportsTo\n      self.photoPath = photoPath\n    }\n  }\n  \n  \/**\n   * Record representing the `EmployeeTerritories` SQL table.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``EmployeeTerritory`` records:\n   * ```swift\n   * let records = try await db.employeeTerritories.filter(orderBy: \\.territoryID) {\n   *   $0.territoryID != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `EmployeeTerritories` table:\n   * ```swift\n   * let values = try await db.select(from: \\.employeeTerritories, \\.territoryID) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``EmployeeTerritory`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = EmployeeTerritory.fetch(in: db, orderBy: \"territoryID\", limit: 5) {\n   *   $0.territoryID != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the table associated with the record:\n   * ```sql\n   * CREATE TABLE [EmployeeTerritories](\n   *    [EmployeeID]INTEGER NOT NULL,\n   *    [TerritoryID]TEXT NOT NULL,\n   *     PRIMARY KEY (\"EmployeeID\",\"TerritoryID\"),\n   *   FOREIGN KEY ([EmployeeID]) REFERENCES [Employees] ([EmployeeID])\n   *     ON DELETE NO ACTION ON UPDATE NO ACTION,\n   *   FOREIGN KEY ([TerritoryID]) REFERENCES [Territories] ([TerritoryID])\n   *     ON DELETE NO ACTION ON UPDATE NO ACTION\n   * )\n   * ```\n   *\/\n  public struct EmployeeTerritory : Identifiable, SQLTableRecord, Codable {\n    \n    \/**\n     * ID structure representing the compound key of ``EmployeeTerritory``.\n     *\/\n    public struct ID : Hashable {\n      \n      public let employeeID : Int\n      public let territoryID : String\n      \n      \/**\n       * Initialize a compound ``EmployeeTerritory`` ``ID``\n       * \n       * - Parameters:\n       *   - employeeID: Value of ``EmployeeTerritory\/employeeID``.\n       *   - territoryID: Value of ``EmployeeTerritory\/territoryID``.\n       *\/\n      @inlinable\n      public init(_ employeeID: Int, _ territoryID: String)\n      {\n        self.employeeID = employeeID\n        self.territoryID = territoryID\n      }\n    }\n    \n    \/\/\/ Static SQL type information for the ``EmployeeTerritory`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Primary key `EmployeeID` (`INTEGER`), required (has default).\n    public var employeeID : Int\n    \n    \/\/\/ Primary key `TerritoryID` (`TEXT`), required (has default).\n    public var territoryID : String\n    \n    \/\/\/ Returns the compound primary key of ``EmployeeTerritory`` (employeeID, territoryID).\n    @inlinable\n    public var id : ID { ID(employeeID, territoryID) }\n    \n    \/**\n     * Initialize a new ``EmployeeTerritory`` record.\n     * \n     * - Parameters:\n     *   - employeeID: Primary key `EmployeeID` (`INTEGER`), required (has default).\n     *   - territoryID: Primary key `TerritoryID` (`TEXT`), required (has default).\n     *\/\n    @inlinable\n    public init(employeeID: Int, territoryID: String)\n    {\n      self.employeeID = employeeID\n      self.territoryID = territoryID\n    }\n  }\n  \n  \/**\n   * Record representing the `Order Details` SQL table.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``OrderDetail`` records:\n   * ```swift\n   * let records = try await db.orderDetails.filter(orderBy: \\.unitPrice) {\n   *   $0.unitPrice != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Order Details` table:\n   * ```swift\n   * let values = try await db.select(from: \\.orderDetails, \\.unitPrice) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``OrderDetail`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = OrderDetail.fetch(in: db, orderBy: \"unitPrice\", limit: 5) {\n   *   $0.unitPrice != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the table associated with the record:\n   * ```sql\n   * CREATE TABLE [Order Details](\n   *    [OrderID]INTEGER NOT NULL,\n   *    [ProductID]INTEGER NOT NULL,\n   *    [UnitPrice]NUMERIC NOT NULL DEFAULT 0,\n   *    [Quantity]INTEGER NOT NULL DEFAULT 1,\n   *    [Discount]REAL NOT NULL DEFAULT 0,\n   *     PRIMARY KEY (\"OrderID\",\"ProductID\"),\n   *     CHECK ([Discount]>=(0) AND [Discount]<=(1)),\n   *     CHECK ([Quantity]>(0)),\n   *     CHECK ([UnitPrice]>=(0)),\n   *   FOREIGN KEY ([OrderID]) REFERENCES [Orders] ([OrderID])\n   *     ON DELETE NO ACTION ON UPDATE NO ACTION,\n   *   FOREIGN KEY ([ProductID]) REFERENCES [Products] ([ProductID])\n   *     ON DELETE NO ACTION ON UPDATE NO ACTION\n   * )\n   * ```\n   *\/\n  public struct OrderDetail : Identifiable, SQLTableRecord, Codable {\n    \n    \/**\n     * ID structure representing the compound key of ``OrderDetail``.\n     *\/\n    public struct ID : Hashable {\n      \n      public let orderID : Int\n      public let productID : Int\n      \n      \/**\n       * Initialize a compound ``OrderDetail`` ``ID``\n       * \n       * - Parameters:\n       *   - orderID: Value of ``OrderDetail\/orderID``.\n       *   - productID: Value of ``OrderDetail\/productID``.\n       *\/\n      @inlinable\n      public init(_ orderID: Int, _ productID: Int)\n      {\n        self.orderID = orderID\n        self.productID = productID\n      }\n    }\n    \n    \/\/\/ Static SQL type information for the ``OrderDetail`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Primary key `OrderID` (`INTEGER`), required (has default).\n    public var orderID : Int\n    \n    \/\/\/ Primary key `ProductID` (`INTEGER`), required (has default).\n    public var productID : Int\n    \n    \/\/\/ Column `UnitPrice` (`NUMERIC`), required (has default string).\n    public var unitPrice : String\n    \n    \/\/\/ Column `Quantity` (`INTEGER`), required (default: `1`).\n    public var quantity : Int\n    \n    \/\/\/ Column `Discount` (`REAL`), required (default: `0.0`).\n    public var discount : Double\n    \n    \/\/\/ Returns the compound primary key of ``OrderDetail`` (orderID, productID).\n    @inlinable\n    public var id : ID { ID(orderID, productID) }\n    \n    \/**\n     * Initialize a new ``OrderDetail`` record.\n     * \n     * - Parameters:\n     *   - orderID: Primary key `OrderID` (`INTEGER`), required (has default).\n     *   - productID: Primary key `ProductID` (`INTEGER`), required (has default).\n     *   - unitPrice: Column `UnitPrice` (`NUMERIC`), required (has default string).\n     *   - quantity: Column `Quantity` (`INTEGER`), required (default: `1`).\n     *   - discount: Column `Discount` (`REAL`), required (default: `0.0`).\n     *\/\n    @inlinable\n    public init(\n      orderID: Int,\n      productID: Int,\n      unitPrice: String = \"0\",\n      quantity: Int = 1,\n      discount: Double = 0.0\n    )\n    {\n      self.orderID = orderID\n      self.productID = productID\n      self.unitPrice = unitPrice\n      self.quantity = quantity\n      self.discount = discount\n    }\n  }\n  \n  \/**\n   * Record representing the `Orders` SQL table.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``Order`` records:\n   * ```swift\n   * let records = try await db.orders.filter(orderBy: \\.customerID) {\n   *   $0.customerID != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Orders` table:\n   * ```swift\n   * let values = try await db.select(from: \\.orders, \\.customerID) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``Order`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = Order.fetch(in: db, orderBy: \"customerID\", limit: 5) {\n   *   $0.customerID != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the table associated with the record:\n   * ```sql\n   * CREATE TABLE [Orders](\n   *    [OrderID]INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n   *    [CustomerID]TEXT,\n   *    [EmployeeID]INTEGER,\n   *    [OrderDate]DATETIME,\n   *    [RequiredDate]DATETIME,\n   *    [ShippedDate]DATETIME,\n   *    [ShipVia]INTEGER,\n   *    [Freight]NUMERIC DEFAULT 0,\n   *    [ShipName]TEXT,\n   *    [ShipAddress]TEXT,\n   *    [ShipCity]TEXT,\n   *    [ShipRegion]TEXT,\n   *    [ShipPostalCode]TEXT,\n   *    [ShipCountry]TEXT,\n   *    FOREIGN KEY ([EmployeeID]) REFERENCES [Employees] ([EmployeeID])\n   *     ON DELETE NO ACTION ON UPDATE NO ACTION,\n   *   FOREIGN KEY ([CustomerID]) REFERENCES [Customers] ([CustomerID])\n   *     ON DELETE NO ACTION ON UPDATE NO ACTION,\n   *   FOREIGN KEY ([ShipVia]) REFERENCES [Shippers] ([ShipperID])\n   *     ON DELETE NO ACTION ON UPDATE NO ACTION\n   * )\n   * ```\n   *\/\n  public struct Order : Identifiable, SQLKeyedTableRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``Order`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Primary key `OrderID` (`INTEGER`), required (has default).\n    public var id : Int\n    \n    \/\/\/ Column `CustomerID` (`TEXT`), optional (default: `nil`).\n    public var customerID : String?\n    \n    \/\/\/ Column `EmployeeID` (`INTEGER`), optional (default: `nil`).\n    public var employeeID : Int?\n    \n    \/\/\/ Column `OrderDate` (`DATETIME`), optional (default: `nil`).\n    public var orderDate : String?\n    \n    \/\/\/ Column `RequiredDate` (`DATETIME`), optional (default: `nil`).\n    public var requiredDate : String?\n    \n    \/\/\/ Column `ShippedDate` (`DATETIME`), optional (default: `nil`).\n    public var shippedDate : String?\n    \n    \/\/\/ Column `ShipVia` (`INTEGER`), optional (default: `nil`).\n    public var shipVia : Int?\n    \n    \/\/\/ Column `Freight` (`NUMERIC`), optional (has default string).\n    public var freight : String?\n    \n    \/\/\/ Column `ShipName` (`TEXT`), optional (default: `nil`).\n    public var shipName : String?\n    \n    \/\/\/ Column `ShipAddress` (`TEXT`), optional (default: `nil`).\n    public var shipAddress : String?\n    \n    \/\/\/ Column `ShipCity` (`TEXT`), optional (default: `nil`).\n    public var shipCity : String?\n    \n    \/\/\/ Column `ShipRegion` (`TEXT`), optional (default: `nil`).\n    public var shipRegion : String?\n    \n    \/\/\/ Column `ShipPostalCode` (`TEXT`), optional (default: `nil`).\n    public var shipPostalCode : String?\n    \n    \/\/\/ Column `ShipCountry` (`TEXT`), optional (default: `nil`).\n    public var shipCountry : String?\n    \n    \/**\n     * Initialize a new ``Order`` record.\n     * \n     * - Parameters:\n     *   - id: Primary key `OrderID` (`INTEGER`), required (has default).\n     *   - customerID: Column `CustomerID` (`TEXT`), optional (default: `nil`).\n     *   - employeeID: Column `EmployeeID` (`INTEGER`), optional (default: `nil`).\n     *   - orderDate: Column `OrderDate` (`DATETIME`), optional (default: `nil`).\n     *   - requiredDate: Column `RequiredDate` (`DATETIME`), optional (default: `nil`).\n     *   - shippedDate: Column `ShippedDate` (`DATETIME`), optional (default: `nil`).\n     *   - shipVia: Column `ShipVia` (`INTEGER`), optional (default: `nil`).\n     *   - freight: Column `Freight` (`NUMERIC`), optional (has default string).\n     *   - shipName: Column `ShipName` (`TEXT`), optional (default: `nil`).\n     *   - shipAddress: Column `ShipAddress` (`TEXT`), optional (default: `nil`).\n     *   - shipCity: Column `ShipCity` (`TEXT`), optional (default: `nil`).\n     *   - shipRegion: Column `ShipRegion` (`TEXT`), optional (default: `nil`).\n     *   - shipPostalCode: Column `ShipPostalCode` (`TEXT`), optional (default: `nil`).\n     *   - shipCountry: Column `ShipCountry` (`TEXT`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(\n      id: Int,\n      customerID: String? = nil,\n      employeeID: Int? = nil,\n      orderDate: String? = nil,\n      requiredDate: String? = nil,\n      shippedDate: String? = nil,\n      shipVia: Int? = nil,\n      freight: String? = \"0\",\n      shipName: String? = nil,\n      shipAddress: String? = nil,\n      shipCity: String? = nil,\n      shipRegion: String? = nil,\n      shipPostalCode: String? = nil,\n      shipCountry: String? = nil\n    )\n    {\n      self.id = id\n      self.customerID = customerID\n      self.employeeID = employeeID\n      self.orderDate = orderDate\n      self.requiredDate = requiredDate\n      self.shippedDate = shippedDate\n      self.shipVia = shipVia\n      self.freight = freight\n      self.shipName = shipName\n      self.shipAddress = shipAddress\n      self.shipCity = shipCity\n      self.shipRegion = shipRegion\n      self.shipPostalCode = shipPostalCode\n      self.shipCountry = shipCountry\n    }\n  }\n  \n  \/**\n   * Record representing the `Products` SQL table.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``Product`` records:\n   * ```swift\n   * let records = try await db.products.filter(orderBy: \\.productName) {\n   *   $0.productName != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Products` table:\n   * ```swift\n   * let values = try await db.select(from: \\.products, \\.productName) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``Product`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = Product.fetch(in: db, orderBy: \"productName\", limit: 5) {\n   *   $0.productName != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the table associated with the record:\n   * ```sql\n   * CREATE TABLE [Products](\n   *    [ProductID]INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n   *    [ProductName]TEXT NOT NULL,\n   *    [SupplierID]INTEGER,\n   *    [CategoryID]INTEGER,\n   *    [QuantityPerUnit]TEXT,\n   *    [UnitPrice]NUMERIC DEFAULT 0,\n   *    [UnitsInStock]INTEGER DEFAULT 0,\n   *    [UnitsOnOrder]INTEGER DEFAULT 0,\n   *    [ReorderLevel]INTEGER DEFAULT 0,\n   *    [Discontinued]TEXT NOT NULL DEFAULT '0',\n   *     CHECK ([UnitPrice]>=(0)),\n   *     CHECK ([ReorderLevel]>=(0)),\n   *     CHECK ([UnitsInStock]>=(0)),\n   *     CHECK ([UnitsOnOrder]>=(0)),\n   *   FOREIGN KEY ([ProductID]) REFERENCES [Categories] ([CategoryID])\n   *     ON DELETE NO ACTION ON UPDATE NO ACTION,\n   *   FOREIGN KEY ([SupplierID]) REFERENCES [Suppliers] ([SupplierID])\n   *     ON DELETE NO ACTION ON UPDATE NO ACTION\n   * )\n   * ```\n   *\/\n  public struct Product : Identifiable, SQLKeyedTableRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``Product`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Primary key `ProductID` (`INTEGER`), required (has default).\n    public var id : Int\n    \n    \/\/\/ Column `ProductName` (`TEXT`), required (has default).\n    public var productName : String\n    \n    \/\/\/ Column `SupplierID` (`INTEGER`), optional (default: `nil`).\n    public var supplierID : Int?\n    \n    \/\/\/ Column `CategoryID` (`INTEGER`), optional (default: `nil`).\n    public var categoryID : Int?\n    \n    \/\/\/ Column `QuantityPerUnit` (`TEXT`), optional (default: `nil`).\n    public var quantityPerUnit : String?\n    \n    \/\/\/ Column `UnitPrice` (`NUMERIC`), optional (has default string).\n    public var unitPrice : String?\n    \n    \/\/\/ Column `UnitsInStock` (`INTEGER`), optional (default: `0`).\n    public var unitsInStock : Int?\n    \n    \/\/\/ Column `UnitsOnOrder` (`INTEGER`), optional (default: `0`).\n    public var unitsOnOrder : Int?\n    \n    \/\/\/ Column `ReorderLevel` (`INTEGER`), optional (default: `0`).\n    public var reorderLevel : Int?\n    \n    \/\/\/ Column `Discontinued` (`TEXT`), required (has default string).\n    public var discontinued : String\n    \n    \/**\n     * Initialize a new ``Product`` record.\n     * \n     * - Parameters:\n     *   - id: Primary key `ProductID` (`INTEGER`), required (has default).\n     *   - productName: Column `ProductName` (`TEXT`), required (has default).\n     *   - supplierID: Column `SupplierID` (`INTEGER`), optional (default: `nil`).\n     *   - categoryID: Column `CategoryID` (`INTEGER`), optional (default: `nil`).\n     *   - quantityPerUnit: Column `QuantityPerUnit` (`TEXT`), optional (default: `nil`).\n     *   - unitPrice: Column `UnitPrice` (`NUMERIC`), optional (has default string).\n     *   - unitsInStock: Column `UnitsInStock` (`INTEGER`), optional (default: `0`).\n     *   - unitsOnOrder: Column `UnitsOnOrder` (`INTEGER`), optional (default: `0`).\n     *   - reorderLevel: Column `ReorderLevel` (`INTEGER`), optional (default: `0`).\n     *   - discontinued: Column `Discontinued` (`TEXT`), required (has default string).\n     *\/\n    @inlinable\n    public init(\n      id: Int,\n      productName: String,\n      supplierID: Int? = nil,\n      categoryID: Int? = nil,\n      quantityPerUnit: String? = nil,\n      unitPrice: String? = \"0\",\n      unitsInStock: Int? = 0,\n      unitsOnOrder: Int? = 0,\n      reorderLevel: Int? = 0,\n      discontinued: String = \"'0'\"\n    )\n    {\n      self.id = id\n      self.productName = productName\n      self.supplierID = supplierID\n      self.categoryID = categoryID\n      self.quantityPerUnit = quantityPerUnit\n      self.unitPrice = unitPrice\n      self.unitsInStock = unitsInStock\n      self.unitsOnOrder = unitsOnOrder\n      self.reorderLevel = reorderLevel\n      self.discontinued = discontinued\n    }\n  }\n  \n  \/**\n   * Record representing the `Regions` SQL table.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``Region`` records:\n   * ```swift\n   * let records = try await db.regions.filter(orderBy: \\.regionDescription) {\n   *   $0.regionDescription != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Regions` table:\n   * ```swift\n   * let values = try await db.select(from: \\.regions, \\.regionDescription) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``Region`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = Region.fetch(in: db, orderBy: \"regionDescription\", limit: 5) {\n   *   $0.regionDescription != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the table associated with the record:\n   * ```sql\n   * CREATE TABLE [Regions](\n   *    [RegionID]INTEGER NOT NULL PRIMARY KEY,\n   *    [RegionDescription]TEXT NOT NULL\n   * )\n   * ```\n   *\/\n  public struct Region : Identifiable, SQLKeyedTableRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``Region`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Primary key `RegionID` (`INTEGER`), required (has default).\n    public var id : Int\n    \n    \/\/\/ Column `RegionDescription` (`TEXT`), required (has default).\n    public var regionDescription : String\n    \n    \/**\n     * Initialize a new ``Region`` record.\n     * \n     * - Parameters:\n     *   - id: Primary key `RegionID` (`INTEGER`), required (has default).\n     *   - regionDescription: Column `RegionDescription` (`TEXT`), required (has default).\n     *\/\n    @inlinable\n    public init(id: Int, regionDescription: String)\n    {\n      self.id = id\n      self.regionDescription = regionDescription\n    }\n  }\n  \n  \/**\n   * Record representing the `Shippers` SQL table.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``Shipper`` records:\n   * ```swift\n   * let records = try await db.shippers.filter(orderBy: \\.companyName) {\n   *   $0.companyName != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Shippers` table:\n   * ```swift\n   * let values = try await db.select(from: \\.shippers, \\.companyName) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``Shipper`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = Shipper.fetch(in: db, orderBy: \"companyName\", limit: 5) {\n   *   $0.companyName != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the table associated with the record:\n   * ```sql\n   * CREATE TABLE [Shippers](\n   *    [ShipperID]INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n   *    [CompanyName]TEXT NOT NULL,\n   *    [Phone]TEXT\n   * )\n   * ```\n   *\/\n  public struct Shipper : Identifiable, SQLKeyedTableRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``Shipper`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Primary key `ShipperID` (`INTEGER`), required (has default).\n    public var id : Int\n    \n    \/\/\/ Column `CompanyName` (`TEXT`), required (has default).\n    public var companyName : String\n    \n    \/\/\/ Column `Phone` (`TEXT`), optional (default: `nil`).\n    public var phone : String?\n    \n    \/**\n     * Initialize a new ``Shipper`` record.\n     * \n     * - Parameters:\n     *   - id: Primary key `ShipperID` (`INTEGER`), required (has default).\n     *   - companyName: Column `CompanyName` (`TEXT`), required (has default).\n     *   - phone: Column `Phone` (`TEXT`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(id: Int, companyName: String, phone: String? = nil)\n    {\n      self.id = id\n      self.companyName = companyName\n      self.phone = phone\n    }\n  }\n  \n  \/**\n   * Record representing the `Suppliers` SQL table.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``Supplier`` records:\n   * ```swift\n   * let records = try await db.suppliers.filter(orderBy: \\.companyName) {\n   *   $0.companyName != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Suppliers` table:\n   * ```swift\n   * let values = try await db.select(from: \\.suppliers, \\.companyName) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``Supplier`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = Supplier.fetch(in: db, orderBy: \"companyName\", limit: 5) {\n   *   $0.companyName != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the table associated with the record:\n   * ```sql\n   * CREATE TABLE [Suppliers](\n   *    [SupplierID]INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n   *    [CompanyName]TEXT NOT NULL,\n   *    [ContactName]TEXT,\n   *    [ContactTitle]TEXT,\n   *    [Address]TEXT,\n   *    [City]TEXT,\n   *    [Region]TEXT,\n   *    [PostalCode]TEXT,\n   *    [Country]TEXT,\n   *    [Phone]TEXT,\n   *    [Fax]TEXT,\n   *    [HomePage]TEXT\n   * )\n   * ```\n   *\/\n  public struct Supplier : Identifiable, SQLKeyedTableRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``Supplier`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Primary key `SupplierID` (`INTEGER`), required (has default).\n    public var id : Int\n    \n    \/\/\/ Column `CompanyName` (`TEXT`), required (has default).\n    public var companyName : String\n    \n    \/\/\/ Column `ContactName` (`TEXT`), optional (default: `nil`).\n    public var contactName : String?\n    \n    \/\/\/ Column `ContactTitle` (`TEXT`), optional (default: `nil`).\n    public var contactTitle : String?\n    \n    \/\/\/ Column `Address` (`TEXT`), optional (default: `nil`).\n    public var address : String?\n    \n    \/\/\/ Column `City` (`TEXT`), optional (default: `nil`).\n    public var city : String?\n    \n    \/\/\/ Column `Region` (`TEXT`), optional (default: `nil`).\n    public var region : String?\n    \n    \/\/\/ Column `PostalCode` (`TEXT`), optional (default: `nil`).\n    public var postalCode : String?\n    \n    \/\/\/ Column `Country` (`TEXT`), optional (default: `nil`).\n    public var country : String?\n    \n    \/\/\/ Column `Phone` (`TEXT`), optional (default: `nil`).\n    public var phone : String?\n    \n    \/\/\/ Column `Fax` (`TEXT`), optional (default: `nil`).\n    public var fax : String?\n    \n    \/\/\/ Column `HomePage` (`TEXT`), optional (default: `nil`).\n    public var homePage : String?\n    \n    \/**\n     * Initialize a new ``Supplier`` record.\n     * \n     * - Parameters:\n     *   - id: Primary key `SupplierID` (`INTEGER`), required (has default).\n     *   - companyName: Column `CompanyName` (`TEXT`), required (has default).\n     *   - contactName: Column `ContactName` (`TEXT`), optional (default: `nil`).\n     *   - contactTitle: Column `ContactTitle` (`TEXT`), optional (default: `nil`).\n     *   - address: Column `Address` (`TEXT`), optional (default: `nil`).\n     *   - city: Column `City` (`TEXT`), optional (default: `nil`).\n     *   - region: Column `Region` (`TEXT`), optional (default: `nil`).\n     *   - postalCode: Column `PostalCode` (`TEXT`), optional (default: `nil`).\n     *   - country: Column `Country` (`TEXT`), optional (default: `nil`).\n     *   - phone: Column `Phone` (`TEXT`), optional (default: `nil`).\n     *   - fax: Column `Fax` (`TEXT`), optional (default: `nil`).\n     *   - homePage: Column `HomePage` (`TEXT`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(\n      id: Int,\n      companyName: String,\n      contactName: String? = nil,\n      contactTitle: String? = nil,\n      address: String? = nil,\n      city: String? = nil,\n      region: String? = nil,\n      postalCode: String? = nil,\n      country: String? = nil,\n      phone: String? = nil,\n      fax: String? = nil,\n      homePage: String? = nil\n    )\n    {\n      self.id = id\n      self.companyName = companyName\n      self.contactName = contactName\n      self.contactTitle = contactTitle\n      self.address = address\n      self.city = city\n      self.region = region\n      self.postalCode = postalCode\n      self.country = country\n      self.phone = phone\n      self.fax = fax\n      self.homePage = homePage\n    }\n  }\n  \n  \/**\n   * Record representing the `Territories` SQL table.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``Territory`` records:\n   * ```swift\n   * let records = try await db.territories.filter(orderBy: \\.id) {\n   *   $0.id != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Territories` table:\n   * ```swift\n   * let values = try await db.select(from: \\.territories, \\.id) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``Territory`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = Territory.fetch(in: db, orderBy: \"id\", limit: 5) {\n   *   $0.id != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the table associated with the record:\n   * ```sql\n   * CREATE TABLE [Territories](\n   *    [TerritoryID]TEXT NOT NULL,\n   *    [TerritoryDescription]TEXT NOT NULL,\n   *    [RegionID]INTEGER NOT NULL,\n   *     PRIMARY KEY (\"TerritoryID\"),\n   *   FOREIGN KEY ([RegionID]) REFERENCES [Regions] ([RegionID])\n   *     ON DELETE NO ACTION ON UPDATE NO ACTION\n   * )\n   * ```\n   *\/\n  public struct Territory : Identifiable, SQLKeyedTableRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``Territory`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Primary key `TerritoryID` (`TEXT`), required (has default).\n    public var id : String\n    \n    \/\/\/ Column `TerritoryDescription` (`TEXT`), required (has default).\n    public var territoryDescription : String\n    \n    \/\/\/ Column `RegionID` (`INTEGER`), required (has default).\n    public var regionID : Int\n    \n    \/**\n     * Initialize a new ``Territory`` record.\n     * \n     * - Parameters:\n     *   - id: Primary key `TerritoryID` (`TEXT`), required (has default).\n     *   - territoryDescription: Column `TerritoryDescription` (`TEXT`), required (has default).\n     *   - regionID: Column `RegionID` (`INTEGER`), required (has default).\n     *\/\n    @inlinable\n    public init(id: String, territoryDescription: String, regionID: Int)\n    {\n      self.id = id\n      self.territoryDescription = territoryDescription\n      self.regionID = regionID\n    }\n  }\n  \n  \/**\n   * Record representing the `Alphabetical list of products` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``AlphabeticalListOfProduct`` records:\n   * ```swift\n   * let records = try await db.alphabeticalListOfProducts.filter(orderBy: \\.productName) {\n   *   $0.productName != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Alphabetical list of products` table:\n   * ```swift\n   * let values = try await db.select(from: \\.alphabeticalListOfProducts, \\.productName) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``AlphabeticalListOfProduct`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = AlphabeticalListOfProduct.fetch(in: db, orderBy: \"productName\", limit: 5) {\n   *   $0.productName != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Alphabetical list of products]\n   * AS\n   * SELECT Products.*,\n   *        Categories.CategoryName\n   * FROM Categories\n   *    INNER JOIN Products ON Categories.CategoryID = Products.CategoryID\n   * WHERE (((Products.Discontinued)=0))\n   * ```\n   *\/\n  public struct AlphabeticalListOfProduct : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``AlphabeticalListOfProduct`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `ProductID` (`INTEGER`), optional (default: `nil`).\n    public var productID : Int?\n    \n    \/\/\/ Column `ProductName` (`TEXT`), optional (default: `nil`).\n    public var productName : String?\n    \n    \/\/\/ Column `SupplierID` (`INTEGER`), optional (default: `nil`).\n    public var supplierID : Int?\n    \n    \/\/\/ Column `CategoryID` (`INTEGER`), optional (default: `nil`).\n    public var categoryID : Int?\n    \n    \/\/\/ Column `QuantityPerUnit` (`TEXT`), optional (default: `nil`).\n    public var quantityPerUnit : String?\n    \n    \/\/\/ Column `UnitPrice` (`NUMERIC`), optional (default: `nil`).\n    public var unitPrice : String?\n    \n    \/\/\/ Column `UnitsInStock` (`INTEGER`), optional (default: `nil`).\n    public var unitsInStock : Int?\n    \n    \/\/\/ Column `UnitsOnOrder` (`INTEGER`), optional (default: `nil`).\n    public var unitsOnOrder : Int?\n    \n    \/\/\/ Column `ReorderLevel` (`INTEGER`), optional (default: `nil`).\n    public var reorderLevel : Int?\n    \n    \/\/\/ Column `Discontinued` (`TEXT`), optional (default: `nil`).\n    public var discontinued : String?\n    \n    \/\/\/ Column `CategoryName` (`TEXT`), optional (default: `nil`).\n    public var categoryName : String?\n    \n    \/**\n     * Initialize a new ``AlphabeticalListOfProduct`` record.\n     * \n     * - Parameters:\n     *   - productID: Column `ProductID` (`INTEGER`), optional (default: `nil`).\n     *   - productName: Column `ProductName` (`TEXT`), optional (default: `nil`).\n     *   - supplierID: Column `SupplierID` (`INTEGER`), optional (default: `nil`).\n     *   - categoryID: Column `CategoryID` (`INTEGER`), optional (default: `nil`).\n     *   - quantityPerUnit: Column `QuantityPerUnit` (`TEXT`), optional (default: `nil`).\n     *   - unitPrice: Column `UnitPrice` (`NUMERIC`), optional (default: `nil`).\n     *   - unitsInStock: Column `UnitsInStock` (`INTEGER`), optional (default: `nil`).\n     *   - unitsOnOrder: Column `UnitsOnOrder` (`INTEGER`), optional (default: `nil`).\n     *   - reorderLevel: Column `ReorderLevel` (`INTEGER`), optional (default: `nil`).\n     *   - discontinued: Column `Discontinued` (`TEXT`), optional (default: `nil`).\n     *   - categoryName: Column `CategoryName` (`TEXT`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(\n      productID: Int? = nil,\n      productName: String? = nil,\n      supplierID: Int? = nil,\n      categoryID: Int? = nil,\n      quantityPerUnit: String? = nil,\n      unitPrice: String? = nil,\n      unitsInStock: Int? = nil,\n      unitsOnOrder: Int? = nil,\n      reorderLevel: Int? = nil,\n      discontinued: String? = nil,\n      categoryName: String? = nil\n    )\n    {\n      self.productID = productID\n      self.productName = productName\n      self.supplierID = supplierID\n      self.categoryID = categoryID\n      self.quantityPerUnit = quantityPerUnit\n      self.unitPrice = unitPrice\n      self.unitsInStock = unitsInStock\n      self.unitsOnOrder = unitsOnOrder\n      self.reorderLevel = reorderLevel\n      self.discontinued = discontinued\n      self.categoryName = categoryName\n    }\n  }\n  \n  \/**\n   * Record representing the `Current Product List` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``CurrentProductList`` records:\n   * ```swift\n   * let records = try await db.currentProductLists.filter(orderBy: \\.productName) {\n   *   $0.productName != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Current Product List` table:\n   * ```swift\n   * let values = try await db.select(from: \\.currentProductLists, \\.productName) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``CurrentProductList`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = CurrentProductList.fetch(in: db, orderBy: \"productName\", limit: 5) {\n   *   $0.productName != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Current Product List]\n   * AS\n   * SELECT ProductID,\n   *        ProductName\n   * FROM Products\n   * WHERE Discontinued=0\n   * ```\n   *\/\n  public struct CurrentProductList : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``CurrentProductList`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `ProductID` (`INTEGER`), optional (default: `nil`).\n    public var productID : Int?\n    \n    \/\/\/ Column `ProductName` (`TEXT`), optional (default: `nil`).\n    public var productName : String?\n    \n    \/**\n     * Initialize a new ``CurrentProductList`` record.\n     * \n     * - Parameters:\n     *   - productID: Column `ProductID` (`INTEGER`), optional (default: `nil`).\n     *   - productName: Column `ProductName` (`TEXT`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(productID: Int? = nil, productName: String? = nil)\n    {\n      self.productID = productID\n      self.productName = productName\n    }\n  }\n  \n  \/**\n   * Record representing the `Customer and Suppliers by City` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``CustomerAndSuppliersByCity`` records:\n   * ```swift\n   * let records = try await db.customerAndSuppliersByCities.filter(orderBy: \\.city) {\n   *   $0.city != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Customer and Suppliers by City` table:\n   * ```swift\n   * let values = try await db.select(from: \\.customerAndSuppliersByCities, \\.city) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``CustomerAndSuppliersByCity`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = CustomerAndSuppliersByCity.fetch(in: db, orderBy: \"city\", limit: 5) {\n   *   $0.city != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Customer and Suppliers by City]\n   * AS\n   * SELECT City,\n   *        CompanyName,\n   *        ContactName,\n   *        'Customers' AS Relationship\n   * FROM Customers\n   * UNION\n   * SELECT City,\n   *        CompanyName,\n   *        ContactName,\n   *        'Suppliers'\n   * FROM Suppliers\n   * ORDER BY City, CompanyName\n   * ```\n   *\/\n  public struct CustomerAndSuppliersByCity : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``CustomerAndSuppliersByCity`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `City` (`TEXT`), optional (default: `nil`).\n    public var city : String?\n    \n    \/\/\/ Column `CompanyName` (`TEXT`), optional (default: `nil`).\n    public var companyName : String?\n    \n    \/\/\/ Column `ContactName` (`TEXT`), optional (default: `nil`).\n    public var contactName : String?\n    \n    \/\/\/ Column `Relationship` (`ANY`), optional (default: `nil`).\n    public var relationship : String?\n    \n    \/**\n     * Initialize a new ``CustomerAndSuppliersByCity`` record.\n     * \n     * - Parameters:\n     *   - city: Column `City` (`TEXT`), optional (default: `nil`).\n     *   - companyName: Column `CompanyName` (`TEXT`), optional (default: `nil`).\n     *   - contactName: Column `ContactName` (`TEXT`), optional (default: `nil`).\n     *   - relationship: Column `Relationship` (`ANY`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(\n      city: String? = nil,\n      companyName: String? = nil,\n      contactName: String? = nil,\n      relationship: String? = nil\n    )\n    {\n      self.city = city\n      self.companyName = companyName\n      self.contactName = contactName\n      self.relationship = relationship\n    }\n  }\n  \n  \/**\n   * Record representing the `Invoices` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``Invoice`` records:\n   * ```swift\n   * let records = try await db.invoices.filter(orderBy: \\.shipName) {\n   *   $0.shipName != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Invoices` table:\n   * ```swift\n   * let values = try await db.select(from: \\.invoices, \\.shipName) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``Invoice`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = Invoice.fetch(in: db, orderBy: \"shipName\", limit: 5) {\n   *   $0.shipName != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Invoices]\n   * AS\n   * SELECT Orders.ShipName,\n   *        Orders.ShipAddress,\n   *        Orders.ShipCity,\n   *        Orders.ShipRegion,\n   *        Orders.ShipPostalCode,\n   *        Orders.ShipCountry,\n   *        Orders.CustomerID,\n   *        Customers.CompanyName AS CustomerName,\n   *        Customers.Address,\n   *        Customers.City,\n   *        Customers.Region,\n   *        Customers.PostalCode,\n   *        Customers.Country,\n   *        (Employees.FirstName + ' ' + Employees.LastName) AS Salesperson,\n   *        Orders.OrderID,\n   *        Orders.OrderDate,\n   *        Orders.RequiredDate,\n   *        Orders.ShippedDate,\n   *        Shippers.CompanyName As ShipperName,\n   *        [Order Details].ProductID,\n   *        Products.ProductName,\n   *        [Order Details].UnitPrice,\n   *        [Order Details].Quantity,\n   *        [Order Details].Discount,\n   *        ((([Order Details].UnitPrice*Quantity*(1-Discount))\/100)*100) AS ExtendedPrice,\n   *        Orders.Freight\n   * FROM Customers\n   *   JOIN Orders ON Customers.CustomerID = Orders.CustomerID\n   *     JOIN Employees ON Employees.EmployeeID = Orders.EmployeeID\n   *      JOIN [Order Details] ON Orders.OrderID = [Order Details].OrderID\n   *       JOIN Products ON Products.ProductID = [Order Details].ProductID\n   *        JOIN Shippers ON Shippers.ShipperID = Orders.ShipVia\n   * ```\n   *\/\n  public struct Invoice : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``Invoice`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `ShipName` (`TEXT`), optional (default: `nil`).\n    public var shipName : String?\n    \n    \/\/\/ Column `ShipAddress` (`TEXT`), optional (default: `nil`).\n    public var shipAddress : String?\n    \n    \/\/\/ Column `ShipCity` (`TEXT`), optional (default: `nil`).\n    public var shipCity : String?\n    \n    \/\/\/ Column `ShipRegion` (`TEXT`), optional (default: `nil`).\n    public var shipRegion : String?\n    \n    \/\/\/ Column `ShipPostalCode` (`TEXT`), optional (default: `nil`).\n    public var shipPostalCode : String?\n    \n    \/\/\/ Column `ShipCountry` (`TEXT`), optional (default: `nil`).\n    public var shipCountry : String?\n    \n    \/\/\/ Column `CustomerID` (`TEXT`), optional (default: `nil`).\n    public var customerID : String?\n    \n    \/\/\/ Column `CustomerName` (`TEXT`), optional (default: `nil`).\n    public var customerName : String?\n    \n    \/\/\/ Column `Address` (`TEXT`), optional (default: `nil`).\n    public var address : String?\n    \n    \/\/\/ Column `City` (`TEXT`), optional (default: `nil`).\n    public var city : String?\n    \n    \/\/\/ Column `Region` (`TEXT`), optional (default: `nil`).\n    public var region : String?\n    \n    \/\/\/ Column `PostalCode` (`TEXT`), optional (default: `nil`).\n    public var postalCode : String?\n    \n    \/\/\/ Column `Country` (`TEXT`), optional (default: `nil`).\n    public var country : String?\n    \n    \/\/\/ Column `Salesperson` (`ANY`), optional (default: `nil`).\n    public var salesperson : String?\n    \n    \/\/\/ Column `OrderID` (`INTEGER`), optional (default: `nil`).\n    public var orderID : Int?\n    \n    \/\/\/ Column `OrderDate` (`DATETIME`), optional (default: `nil`).\n    public var orderDate : String?\n    \n    \/\/\/ Column `RequiredDate` (`DATETIME`), optional (default: `nil`).\n    public var requiredDate : String?\n    \n    \/\/\/ Column `ShippedDate` (`DATETIME`), optional (default: `nil`).\n    public var shippedDate : String?\n    \n    \/\/\/ Column `ShipperName` (`TEXT`), optional (default: `nil`).\n    public var shipperName : String?\n    \n    \/\/\/ Column `ProductID` (`INTEGER`), optional (default: `nil`).\n    public var productID : Int?\n    \n    \/\/\/ Column `ProductName` (`TEXT`), optional (default: `nil`).\n    public var productName : String?\n    \n    \/\/\/ Column `UnitPrice` (`NUMERIC`), optional (default: `nil`).\n    public var unitPrice : String?\n    \n    \/\/\/ Column `Quantity` (`INTEGER`), optional (default: `nil`).\n    public var quantity : Int?\n    \n    \/\/\/ Column `Discount` (`REAL`), optional (default: `nil`).\n    public var discount : Double?\n    \n    \/\/\/ Column `ExtendedPrice` (`ANY`), optional (default: `nil`).\n    public var extendedPrice : String?\n    \n    \/\/\/ Column `Freight` (`NUMERIC`), optional (default: `nil`).\n    public var freight : String?\n    \n    \/**\n     * Initialize a new ``Invoice`` record.\n     * \n     * - Parameters:\n     *   - shipName: Column `ShipName` (`TEXT`), optional (default: `nil`).\n     *   - shipAddress: Column `ShipAddress` (`TEXT`), optional (default: `nil`).\n     *   - shipCity: Column `ShipCity` (`TEXT`), optional (default: `nil`).\n     *   - shipRegion: Column `ShipRegion` (`TEXT`), optional (default: `nil`).\n     *   - shipPostalCode: Column `ShipPostalCode` (`TEXT`), optional (default: `nil`).\n     *   - shipCountry: Column `ShipCountry` (`TEXT`), optional (default: `nil`).\n     *   - customerID: Column `CustomerID` (`TEXT`), optional (default: `nil`).\n     *   - customerName: Column `CustomerName` (`TEXT`), optional (default: `nil`).\n     *   - address: Column `Address` (`TEXT`), optional (default: `nil`).\n     *   - city: Column `City` (`TEXT`), optional (default: `nil`).\n     *   - region: Column `Region` (`TEXT`), optional (default: `nil`).\n     *   - postalCode: Column `PostalCode` (`TEXT`), optional (default: `nil`).\n     *   - country: Column `Country` (`TEXT`), optional (default: `nil`).\n     *   - salesperson: Column `Salesperson` (`ANY`), optional (default: `nil`).\n     *   - orderID: Column `OrderID` (`INTEGER`), optional (default: `nil`).\n     *   - orderDate: Column `OrderDate` (`DATETIME`), optional (default: `nil`).\n     *   - requiredDate: Column `RequiredDate` (`DATETIME`), optional (default: `nil`).\n     *   - shippedDate: Column `ShippedDate` (`DATETIME`), optional (default: `nil`).\n     *   - shipperName: Column `ShipperName` (`TEXT`), optional (default: `nil`).\n     *   - productID: Column `ProductID` (`INTEGER`), optional (default: `nil`).\n     *   - productName: Column `ProductName` (`TEXT`), optional (default: `nil`).\n     *   - unitPrice: Column `UnitPrice` (`NUMERIC`), optional (default: `nil`).\n     *   - quantity: Column `Quantity` (`INTEGER`), optional (default: `nil`).\n     *   - discount: Column `Discount` (`REAL`), optional (default: `nil`).\n     *   - extendedPrice: Column `ExtendedPrice` (`ANY`), optional (default: `nil`).\n     *   - freight: Column `Freight` (`NUMERIC`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(\n      shipName: String? = nil,\n      shipAddress: String? = nil,\n      shipCity: String? = nil,\n      shipRegion: String? = nil,\n      shipPostalCode: String? = nil,\n      shipCountry: String? = nil,\n      customerID: String? = nil,\n      customerName: String? = nil,\n      address: String? = nil,\n      city: String? = nil,\n      region: String? = nil,\n      postalCode: String? = nil,\n      country: String? = nil,\n      salesperson: String? = nil,\n      orderID: Int? = nil,\n      orderDate: String? = nil,\n      requiredDate: String? = nil,\n      shippedDate: String? = nil,\n      shipperName: String? = nil,\n      productID: Int? = nil,\n      productName: String? = nil,\n      unitPrice: String? = nil,\n      quantity: Int? = nil,\n      discount: Double? = nil,\n      extendedPrice: String? = nil,\n      freight: String? = nil\n    )\n    {\n      self.shipName = shipName\n      self.shipAddress = shipAddress\n      self.shipCity = shipCity\n      self.shipRegion = shipRegion\n      self.shipPostalCode = shipPostalCode\n      self.shipCountry = shipCountry\n      self.customerID = customerID\n      self.customerName = customerName\n      self.address = address\n      self.city = city\n      self.region = region\n      self.postalCode = postalCode\n      self.country = country\n      self.salesperson = salesperson\n      self.orderID = orderID\n      self.orderDate = orderDate\n      self.requiredDate = requiredDate\n      self.shippedDate = shippedDate\n      self.shipperName = shipperName\n      self.productID = productID\n      self.productName = productName\n      self.unitPrice = unitPrice\n      self.quantity = quantity\n      self.discount = discount\n      self.extendedPrice = extendedPrice\n      self.freight = freight\n    }\n  }\n  \n  \/**\n   * Record representing the `Orders Qry` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``OrdersQry`` records:\n   * ```swift\n   * let records = try await db.ordersQries.filter(orderBy: \\.customerID) {\n   *   $0.customerID != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Orders Qry` table:\n   * ```swift\n   * let values = try await db.select(from: \\.ordersQries, \\.customerID) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``OrdersQry`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = OrdersQry.fetch(in: db, orderBy: \"customerID\", limit: 5) {\n   *   $0.customerID != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Orders Qry] AS\n   * SELECT Orders.OrderID,\n   *        Orders.CustomerID,\n   *        Orders.EmployeeID,\n   *        Orders.OrderDate,\n   *        Orders.RequiredDate,\n   *        Orders.ShippedDate,\n   *        Orders.ShipVia,\n   *        Orders.Freight,\n   *        Orders.ShipName,\n   *        Orders.ShipAddress,\n   *        Orders.ShipCity,\n   *        Orders.ShipRegion,\n   *        Orders.ShipPostalCode,\n   *        Orders.ShipCountry,\n   *        Customers.CompanyName,\n   *        Customers.Address,\n   *        Customers.City,\n   *        Customers.Region,\n   *        Customers.PostalCode,\n   *        Customers.Country\n   * FROM Customers\n   *      JOIN Orders ON Customers.CustomerID = Orders.CustomerID\n   * ```\n   *\/\n  public struct OrdersQry : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``OrdersQry`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `OrderID` (`INTEGER`), optional (default: `nil`).\n    public var orderID : Int?\n    \n    \/\/\/ Column `CustomerID` (`TEXT`), optional (default: `nil`).\n    public var customerID : String?\n    \n    \/\/\/ Column `EmployeeID` (`INTEGER`), optional (default: `nil`).\n    public var employeeID : Int?\n    \n    \/\/\/ Column `OrderDate` (`DATETIME`), optional (default: `nil`).\n    public var orderDate : String?\n    \n    \/\/\/ Column `RequiredDate` (`DATETIME`), optional (default: `nil`).\n    public var requiredDate : String?\n    \n    \/\/\/ Column `ShippedDate` (`DATETIME`), optional (default: `nil`).\n    public var shippedDate : String?\n    \n    \/\/\/ Column `ShipVia` (`INTEGER`), optional (default: `nil`).\n    public var shipVia : Int?\n    \n    \/\/\/ Column `Freight` (`NUMERIC`), optional (default: `nil`).\n    public var freight : String?\n    \n    \/\/\/ Column `ShipName` (`TEXT`), optional (default: `nil`).\n    public var shipName : String?\n    \n    \/\/\/ Column `ShipAddress` (`TEXT`), optional (default: `nil`).\n    public var shipAddress : String?\n    \n    \/\/\/ Column `ShipCity` (`TEXT`), optional (default: `nil`).\n    public var shipCity : String?\n    \n    \/\/\/ Column `ShipRegion` (`TEXT`), optional (default: `nil`).\n    public var shipRegion : String?\n    \n    \/\/\/ Column `ShipPostalCode` (`TEXT`), optional (default: `nil`).\n    public var shipPostalCode : String?\n    \n    \/\/\/ Column `ShipCountry` (`TEXT`), optional (default: `nil`).\n    public var shipCountry : String?\n    \n    \/\/\/ Column `CompanyName` (`TEXT`), optional (default: `nil`).\n    public var companyName : String?\n    \n    \/\/\/ Column `Address` (`TEXT`), optional (default: `nil`).\n    public var address : String?\n    \n    \/\/\/ Column `City` (`TEXT`), optional (default: `nil`).\n    public var city : String?\n    \n    \/\/\/ Column `Region` (`TEXT`), optional (default: `nil`).\n    public var region : String?\n    \n    \/\/\/ Column `PostalCode` (`TEXT`), optional (default: `nil`).\n    public var postalCode : String?\n    \n    \/\/\/ Column `Country` (`TEXT`), optional (default: `nil`).\n    public var country : String?\n    \n    \/**\n     * Initialize a new ``OrdersQry`` record.\n     * \n     * - Parameters:\n     *   - orderID: Column `OrderID` (`INTEGER`), optional (default: `nil`).\n     *   - customerID: Column `CustomerID` (`TEXT`), optional (default: `nil`).\n     *   - employeeID: Column `EmployeeID` (`INTEGER`), optional (default: `nil`).\n     *   - orderDate: Column `OrderDate` (`DATETIME`), optional (default: `nil`).\n     *   - requiredDate: Column `RequiredDate` (`DATETIME`), optional (default: `nil`).\n     *   - shippedDate: Column `ShippedDate` (`DATETIME`), optional (default: `nil`).\n     *   - shipVia: Column `ShipVia` (`INTEGER`), optional (default: `nil`).\n     *   - freight: Column `Freight` (`NUMERIC`), optional (default: `nil`).\n     *   - shipName: Column `ShipName` (`TEXT`), optional (default: `nil`).\n     *   - shipAddress: Column `ShipAddress` (`TEXT`), optional (default: `nil`).\n     *   - shipCity: Column `ShipCity` (`TEXT`), optional (default: `nil`).\n     *   - shipRegion: Column `ShipRegion` (`TEXT`), optional (default: `nil`).\n     *   - shipPostalCode: Column `ShipPostalCode` (`TEXT`), optional (default: `nil`).\n     *   - shipCountry: Column `ShipCountry` (`TEXT`), optional (default: `nil`).\n     *   - companyName: Column `CompanyName` (`TEXT`), optional (default: `nil`).\n     *   - address: Column `Address` (`TEXT`), optional (default: `nil`).\n     *   - city: Column `City` (`TEXT`), optional (default: `nil`).\n     *   - region: Column `Region` (`TEXT`), optional (default: `nil`).\n     *   - postalCode: Column `PostalCode` (`TEXT`), optional (default: `nil`).\n     *   - country: Column `Country` (`TEXT`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(\n      orderID: Int? = nil,\n      customerID: String? = nil,\n      employeeID: Int? = nil,\n      orderDate: String? = nil,\n      requiredDate: String? = nil,\n      shippedDate: String? = nil,\n      shipVia: Int? = nil,\n      freight: String? = nil,\n      shipName: String? = nil,\n      shipAddress: String? = nil,\n      shipCity: String? = nil,\n      shipRegion: String? = nil,\n      shipPostalCode: String? = nil,\n      shipCountry: String? = nil,\n      companyName: String? = nil,\n      address: String? = nil,\n      city: String? = nil,\n      region: String? = nil,\n      postalCode: String? = nil,\n      country: String? = nil\n    )\n    {\n      self.orderID = orderID\n      self.customerID = customerID\n      self.employeeID = employeeID\n      self.orderDate = orderDate\n      self.requiredDate = requiredDate\n      self.shippedDate = shippedDate\n      self.shipVia = shipVia\n      self.freight = freight\n      self.shipName = shipName\n      self.shipAddress = shipAddress\n      self.shipCity = shipCity\n      self.shipRegion = shipRegion\n      self.shipPostalCode = shipPostalCode\n      self.shipCountry = shipCountry\n      self.companyName = companyName\n      self.address = address\n      self.city = city\n      self.region = region\n      self.postalCode = postalCode\n      self.country = country\n    }\n  }\n  \n  \/**\n   * Record representing the `Order Subtotals` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``OrderSubtotal`` records:\n   * ```swift\n   * let records = try await db.orderSubtotals.filter(orderBy: \\.subtotal) {\n   *   $0.subtotal != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Order Subtotals` table:\n   * ```swift\n   * let values = try await db.select(from: \\.orderSubtotals, \\.subtotal) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``OrderSubtotal`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = OrderSubtotal.fetch(in: db, orderBy: \"subtotal\", limit: 5) {\n   *   $0.subtotal != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Order Subtotals] AS\n   * SELECT [Order Details].OrderID,\n   * Sum(([Order Details].UnitPrice*Quantity*(1-Discount)\/100)*100) AS Subtotal\n   * FROM [Order Details]\n   * GROUP BY [Order Details].OrderID\n   * ```\n   *\/\n  public struct OrderSubtotal : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``OrderSubtotal`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `OrderID` (`INTEGER`), optional (default: `nil`).\n    public var orderID : Int?\n    \n    \/\/\/ Column `Subtotal` (`ANY`), optional (default: `nil`).\n    public var subtotal : String?\n    \n    \/**\n     * Initialize a new ``OrderSubtotal`` record.\n     * \n     * - Parameters:\n     *   - orderID: Column `OrderID` (`INTEGER`), optional (default: `nil`).\n     *   - subtotal: Column `Subtotal` (`ANY`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(orderID: Int? = nil, subtotal: String? = nil)\n    {\n      self.orderID = orderID\n      self.subtotal = subtotal\n    }\n  }\n  \n  \/**\n   * Record representing the `Product Sales for 1997` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``ProductSalesFor1997`` records:\n   * ```swift\n   * let records = try await db.productSalesFor1997s.filter(orderBy: \\.categoryName) {\n   *   $0.categoryName != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Product Sales for 1997` table:\n   * ```swift\n   * let values = try await db.select(from: \\.productSalesFor1997s, \\.categoryName) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``ProductSalesFor1997`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = ProductSalesFor1997.fetch(in: db, orderBy: \"categoryName\", limit: 5) {\n   *   $0.categoryName != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Product Sales for 1997] AS\n   * SELECT Categories.CategoryName,\n   *        Products.ProductName,\n   *        Sum(([Order Details].UnitPrice*Quantity*(1-Discount)\/100)*100) AS ProductSales\n   * FROM Categories\n   *  JOIN    Products On Categories.CategoryID = Products.CategoryID\n   *     JOIN  [Order Details] on Products.ProductID = [Order Details].ProductID\n   *      JOIN  [Orders] on Orders.OrderID = [Order Details].OrderID\n   * WHERE Orders.ShippedDate Between DATETIME('1997-01-01') And DATETIME('1997-12-31')\n   * GROUP BY Categories.CategoryName, Products.ProductName\n   * ```\n   *\/\n  public struct ProductSalesFor1997 : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``ProductSalesFor1997`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `CategoryName` (`TEXT`), optional (default: `nil`).\n    public var categoryName : String?\n    \n    \/\/\/ Column `ProductName` (`TEXT`), optional (default: `nil`).\n    public var productName : String?\n    \n    \/\/\/ Column `ProductSales` (`ANY`), optional (default: `nil`).\n    public var productSales : String?\n    \n    \/**\n     * Initialize a new ``ProductSalesFor1997`` record.\n     * \n     * - Parameters:\n     *   - categoryName: Column `CategoryName` (`TEXT`), optional (default: `nil`).\n     *   - productName: Column `ProductName` (`TEXT`), optional (default: `nil`).\n     *   - productSales: Column `ProductSales` (`ANY`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(\n      categoryName: String? = nil,\n      productName: String? = nil,\n      productSales: String? = nil\n    )\n    {\n      self.categoryName = categoryName\n      self.productName = productName\n      self.productSales = productSales\n    }\n  }\n  \n  \/**\n   * Record representing the `Products Above Average Price` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``ProductsAboveAveragePrice`` records:\n   * ```swift\n   * let records = try await db.productsAboveAveragePrices.filter(orderBy: \\.productName) {\n   *   $0.productName != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Products Above Average Price` table:\n   * ```swift\n   * let values = try await db.select(from: \\.productsAboveAveragePrices, \\.productName) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``ProductsAboveAveragePrice`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = ProductsAboveAveragePrice.fetch(in: db, orderBy: \"productName\", limit: 5) {\n   *   $0.productName != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Products Above Average Price] AS\n   * SELECT Products.ProductName,\n   *        Products.UnitPrice\n   * FROM Products\n   * WHERE Products.UnitPrice>(SELECT AVG(UnitPrice) From Products)\n   * ```\n   *\/\n  public struct ProductsAboveAveragePrice : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``ProductsAboveAveragePrice`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `ProductName` (`TEXT`), optional (default: `nil`).\n    public var productName : String?\n    \n    \/\/\/ Column `UnitPrice` (`NUMERIC`), optional (default: `nil`).\n    public var unitPrice : String?\n    \n    \/**\n     * Initialize a new ``ProductsAboveAveragePrice`` record.\n     * \n     * - Parameters:\n     *   - productName: Column `ProductName` (`TEXT`), optional (default: `nil`).\n     *   - unitPrice: Column `UnitPrice` (`NUMERIC`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(productName: String? = nil, unitPrice: String? = nil)\n    {\n      self.productName = productName\n      self.unitPrice = unitPrice\n    }\n  }\n  \n  \/**\n   * Record representing the `Products by Category` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``ProductsByCategory`` records:\n   * ```swift\n   * let records = try await db.productsByCategories.filter(orderBy: \\.categoryName) {\n   *   $0.categoryName != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Products by Category` table:\n   * ```swift\n   * let values = try await db.select(from: \\.productsByCategories, \\.categoryName) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``ProductsByCategory`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = ProductsByCategory.fetch(in: db, orderBy: \"categoryName\", limit: 5) {\n   *   $0.categoryName != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Products by Category] AS\n   * SELECT Categories.CategoryName,\n   *        Products.ProductName,\n   *        Products.QuantityPerUnit,\n   *        Products.UnitsInStock,\n   *        Products.Discontinued\n   * FROM Categories\n   *      INNER JOIN Products ON Categories.CategoryID = Products.CategoryID\n   * WHERE Products.Discontinued <> 1\n   * ```\n   *\/\n  public struct ProductsByCategory : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``ProductsByCategory`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `CategoryName` (`TEXT`), optional (default: `nil`).\n    public var categoryName : String?\n    \n    \/\/\/ Column `ProductName` (`TEXT`), optional (default: `nil`).\n    public var productName : String?\n    \n    \/\/\/ Column `QuantityPerUnit` (`TEXT`), optional (default: `nil`).\n    public var quantityPerUnit : String?\n    \n    \/\/\/ Column `UnitsInStock` (`INTEGER`), optional (default: `nil`).\n    public var unitsInStock : Int?\n    \n    \/\/\/ Column `Discontinued` (`TEXT`), optional (default: `nil`).\n    public var discontinued : String?\n    \n    \/**\n     * Initialize a new ``ProductsByCategory`` record.\n     * \n     * - Parameters:\n     *   - categoryName: Column `CategoryName` (`TEXT`), optional (default: `nil`).\n     *   - productName: Column `ProductName` (`TEXT`), optional (default: `nil`).\n     *   - quantityPerUnit: Column `QuantityPerUnit` (`TEXT`), optional (default: `nil`).\n     *   - unitsInStock: Column `UnitsInStock` (`INTEGER`), optional (default: `nil`).\n     *   - discontinued: Column `Discontinued` (`TEXT`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(\n      categoryName: String? = nil,\n      productName: String? = nil,\n      quantityPerUnit: String? = nil,\n      unitsInStock: Int? = nil,\n      discontinued: String? = nil\n    )\n    {\n      self.categoryName = categoryName\n      self.productName = productName\n      self.quantityPerUnit = quantityPerUnit\n      self.unitsInStock = unitsInStock\n      self.discontinued = discontinued\n    }\n  }\n  \n  \/**\n   * Record representing the `Quarterly Orders` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``QuarterlyOrder`` records:\n   * ```swift\n   * let records = try await db.quarterlyOrders.filter(orderBy: \\.customerID) {\n   *   $0.customerID != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Quarterly Orders` table:\n   * ```swift\n   * let values = try await db.select(from: \\.quarterlyOrders, \\.customerID) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``QuarterlyOrder`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = QuarterlyOrder.fetch(in: db, orderBy: \"customerID\", limit: 5) {\n   *   $0.customerID != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Quarterly Orders] AS\n   * SELECT DISTINCT Customers.CustomerID,\n   *                 Customers.CompanyName,\n   *                 Customers.City,\n   *                 Customers.Country\n   * FROM Customers\n   *      JOIN Orders ON Customers.CustomerID = Orders.CustomerID\n   * WHERE Orders.OrderDate BETWEEN DATETIME('1997-01-01') And DATETIME('1997-12-31')\n   * ```\n   *\/\n  public struct QuarterlyOrder : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``QuarterlyOrder`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `CustomerID` (`TEXT`), optional (default: `nil`).\n    public var customerID : String?\n    \n    \/\/\/ Column `CompanyName` (`TEXT`), optional (default: `nil`).\n    public var companyName : String?\n    \n    \/\/\/ Column `City` (`TEXT`), optional (default: `nil`).\n    public var city : String?\n    \n    \/\/\/ Column `Country` (`TEXT`), optional (default: `nil`).\n    public var country : String?\n    \n    \/**\n     * Initialize a new ``QuarterlyOrder`` record.\n     * \n     * - Parameters:\n     *   - customerID: Column `CustomerID` (`TEXT`), optional (default: `nil`).\n     *   - companyName: Column `CompanyName` (`TEXT`), optional (default: `nil`).\n     *   - city: Column `City` (`TEXT`), optional (default: `nil`).\n     *   - country: Column `Country` (`TEXT`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(\n      customerID: String? = nil,\n      companyName: String? = nil,\n      city: String? = nil,\n      country: String? = nil\n    )\n    {\n      self.customerID = customerID\n      self.companyName = companyName\n      self.city = city\n      self.country = country\n    }\n  }\n  \n  \/**\n   * Record representing the `Sales Totals by Amount` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``SalesTotalsByAmount`` records:\n   * ```swift\n   * let records = try await db.salesTotalsByAmounts.filter(orderBy: \\.saleAmount) {\n   *   $0.saleAmount != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Sales Totals by Amount` table:\n   * ```swift\n   * let values = try await db.select(from: \\.salesTotalsByAmounts, \\.saleAmount) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``SalesTotalsByAmount`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = SalesTotalsByAmount.fetch(in: db, orderBy: \"saleAmount\", limit: 5) {\n   *   $0.saleAmount != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Sales Totals by Amount] AS\n   * SELECT [Order Subtotals].Subtotal AS SaleAmount,\n   *                   Orders.OrderID,\n   *                Customers.CompanyName,\n   *                   Orders.ShippedDate\n   * FROM Customers\n   *  JOIN Orders ON Customers.CustomerID = Orders.CustomerID\n   *     JOIN [Order Subtotals] ON Orders.OrderID = [Order Subtotals].OrderID\n   * WHERE ([Order Subtotals].Subtotal >2500)\n   * AND (Orders.ShippedDate BETWEEN DATETIME('1997-01-01') And DATETIME('1997-12-31'))\n   * ```\n   *\/\n  public struct SalesTotalsByAmount : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``SalesTotalsByAmount`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `SaleAmount` (`ANY`), optional (default: `nil`).\n    public var saleAmount : String?\n    \n    \/\/\/ Column `OrderID` (`INTEGER`), optional (default: `nil`).\n    public var orderID : Int?\n    \n    \/\/\/ Column `CompanyName` (`TEXT`), optional (default: `nil`).\n    public var companyName : String?\n    \n    \/\/\/ Column `ShippedDate` (`DATETIME`), optional (default: `nil`).\n    public var shippedDate : String?\n    \n    \/**\n     * Initialize a new ``SalesTotalsByAmount`` record.\n     * \n     * - Parameters:\n     *   - saleAmount: Column `SaleAmount` (`ANY`), optional (default: `nil`).\n     *   - orderID: Column `OrderID` (`INTEGER`), optional (default: `nil`).\n     *   - companyName: Column `CompanyName` (`TEXT`), optional (default: `nil`).\n     *   - shippedDate: Column `ShippedDate` (`DATETIME`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(\n      saleAmount: String? = nil,\n      orderID: Int? = nil,\n      companyName: String? = nil,\n      shippedDate: String? = nil\n    )\n    {\n      self.saleAmount = saleAmount\n      self.orderID = orderID\n      self.companyName = companyName\n      self.shippedDate = shippedDate\n    }\n  }\n  \n  \/**\n   * Record representing the `Summary of Sales by Quarter` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``SummaryOfSalesByQuarter`` records:\n   * ```swift\n   * let records = try await db.summaryOfSalesByQuarters.filter(orderBy: \\.subtotal) {\n   *   $0.subtotal != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Summary of Sales by Quarter` table:\n   * ```swift\n   * let values = try await db.select(from: \\.summaryOfSalesByQuarters, \\.subtotal) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``SummaryOfSalesByQuarter`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = SummaryOfSalesByQuarter.fetch(in: db, orderBy: \"subtotal\", limit: 5) {\n   *   $0.subtotal != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Summary of Sales by Quarter] AS\n   * SELECT Orders.ShippedDate,\n   *        Orders.OrderID,\n   *        [Order Subtotals].Subtotal\n   * FROM Orders\n   *      INNER JOIN [Order Subtotals] ON Orders.OrderID = [Order Subtotals].OrderID\n   * WHERE Orders.ShippedDate IS NOT NULL\n   * ```\n   *\/\n  public struct SummaryOfSalesByQuarter : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``SummaryOfSalesByQuarter`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `ShippedDate` (`DATETIME`), optional (default: `nil`).\n    public var shippedDate : String?\n    \n    \/\/\/ Column `OrderID` (`INTEGER`), optional (default: `nil`).\n    public var orderID : Int?\n    \n    \/\/\/ Column `Subtotal` (`ANY`), optional (default: `nil`).\n    public var subtotal : String?\n    \n    \/**\n     * Initialize a new ``SummaryOfSalesByQuarter`` record.\n     * \n     * - Parameters:\n     *   - shippedDate: Column `ShippedDate` (`DATETIME`), optional (default: `nil`).\n     *   - orderID: Column `OrderID` (`INTEGER`), optional (default: `nil`).\n     *   - subtotal: Column `Subtotal` (`ANY`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(shippedDate: String? = nil, orderID: Int? = nil, subtotal: String? = nil)\n    {\n      self.shippedDate = shippedDate\n      self.orderID = orderID\n      self.subtotal = subtotal\n    }\n  }\n  \n  \/**\n   * Record representing the `Summary of Sales by Year` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``SummaryOfSalesByYear`` records:\n   * ```swift\n   * let records = try await db.summaryOfSalesByYears.filter(orderBy: \\.subtotal) {\n   *   $0.subtotal != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Summary of Sales by Year` table:\n   * ```swift\n   * let values = try await db.select(from: \\.summaryOfSalesByYears, \\.subtotal) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``SummaryOfSalesByYear`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = SummaryOfSalesByYear.fetch(in: db, orderBy: \"subtotal\", limit: 5) {\n   *   $0.subtotal != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Summary of Sales by Year] AS\n   * SELECT      Orders.ShippedDate,\n   *             Orders.OrderID,\n   *  [Order Subtotals].Subtotal\n   * FROM Orders\n   *      INNER JOIN [Order Subtotals] ON Orders.OrderID = [Order Subtotals].OrderID\n   * WHERE Orders.ShippedDate IS NOT NULL\n   * ```\n   *\/\n  public struct SummaryOfSalesByYear : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``SummaryOfSalesByYear`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `ShippedDate` (`DATETIME`), optional (default: `nil`).\n    public var shippedDate : String?\n    \n    \/\/\/ Column `OrderID` (`INTEGER`), optional (default: `nil`).\n    public var orderID : Int?\n    \n    \/\/\/ Column `Subtotal` (`ANY`), optional (default: `nil`).\n    public var subtotal : String?\n    \n    \/**\n     * Initialize a new ``SummaryOfSalesByYear`` record.\n     * \n     * - Parameters:\n     *   - shippedDate: Column `ShippedDate` (`DATETIME`), optional (default: `nil`).\n     *   - orderID: Column `OrderID` (`INTEGER`), optional (default: `nil`).\n     *   - subtotal: Column `Subtotal` (`ANY`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(shippedDate: String? = nil, orderID: Int? = nil, subtotal: String? = nil)\n    {\n      self.shippedDate = shippedDate\n      self.orderID = orderID\n      self.subtotal = subtotal\n    }\n  }\n  \n  \/**\n   * Record representing the `Category Sales for 1997` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``CategorySalesFor1997`` records:\n   * ```swift\n   * let records = try await db.categorySalesFor1997s.filter(orderBy: \\.categoryName) {\n   *   $0.categoryName != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Category Sales for 1997` table:\n   * ```swift\n   * let values = try await db.select(from: \\.categorySalesFor1997s, \\.categoryName) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``CategorySalesFor1997`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = CategorySalesFor1997.fetch(in: db, orderBy: \"categoryName\", limit: 5) {\n   *   $0.categoryName != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Category Sales for 1997] AS\n   * SELECT     [Product Sales for 1997].CategoryName,\n   *        Sum([Product Sales for 1997].ProductSales) AS CategorySales\n   * FROM [Product Sales for 1997]\n   * GROUP BY [Product Sales for 1997].CategoryName\n   * ```\n   *\/\n  public struct CategorySalesFor1997 : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``CategorySalesFor1997`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `CategoryName` (`TEXT`), optional (default: `nil`).\n    public var categoryName : String?\n    \n    \/\/\/ Column `CategorySales` (`ANY`), optional (default: `nil`).\n    public var categorySales : String?\n    \n    \/**\n     * Initialize a new ``CategorySalesFor1997`` record.\n     * \n     * - Parameters:\n     *   - categoryName: Column `CategoryName` (`TEXT`), optional (default: `nil`).\n     *   - categorySales: Column `CategorySales` (`ANY`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(categoryName: String? = nil, categorySales: String? = nil)\n    {\n      self.categoryName = categoryName\n      self.categorySales = categorySales\n    }\n  }\n  \n  \/**\n   * Record representing the `Order Details Extended` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``OrderDetailsExtended`` records:\n   * ```swift\n   * let records = try await db.orderDetailsExtendeds.filter(orderBy: \\.productName) {\n   *   $0.productName != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Order Details Extended` table:\n   * ```swift\n   * let values = try await db.select(from: \\.orderDetailsExtendeds, \\.productName) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``OrderDetailsExtended`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = OrderDetailsExtended.fetch(in: db, orderBy: \"productName\", limit: 5) {\n   *   $0.productName != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Order Details Extended] AS\n   * SELECT [Order Details].OrderID,\n   *        [Order Details].ProductID,\n   *        Products.ProductName,\n   *      [Order Details].UnitPrice,\n   *        [Order Details].Quantity,\n   *        [Order Details].Discount,\n   *       ([Order Details].UnitPrice*Quantity*(1-Discount)\/100)*100 AS ExtendedPrice\n   * FROM Products\n   *      JOIN [Order Details] ON Products.ProductID = [Order Details].ProductID\n   * ```\n   *\/\n  public struct OrderDetailsExtended : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``OrderDetailsExtended`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `OrderID` (`INTEGER`), optional (default: `nil`).\n    public var orderID : Int?\n    \n    \/\/\/ Column `ProductID` (`INTEGER`), optional (default: `nil`).\n    public var productID : Int?\n    \n    \/\/\/ Column `ProductName` (`TEXT`), optional (default: `nil`).\n    public var productName : String?\n    \n    \/\/\/ Column `UnitPrice` (`NUMERIC`), optional (default: `nil`).\n    public var unitPrice : String?\n    \n    \/\/\/ Column `Quantity` (`INTEGER`), optional (default: `nil`).\n    public var quantity : Int?\n    \n    \/\/\/ Column `Discount` (`REAL`), optional (default: `nil`).\n    public var discount : Double?\n    \n    \/\/\/ Column `ExtendedPrice` (`ANY`), optional (default: `nil`).\n    public var extendedPrice : String?\n    \n    \/**\n     * Initialize a new ``OrderDetailsExtended`` record.\n     * \n     * - Parameters:\n     *   - orderID: Column `OrderID` (`INTEGER`), optional (default: `nil`).\n     *   - productID: Column `ProductID` (`INTEGER`), optional (default: `nil`).\n     *   - productName: Column `ProductName` (`TEXT`), optional (default: `nil`).\n     *   - unitPrice: Column `UnitPrice` (`NUMERIC`), optional (default: `nil`).\n     *   - quantity: Column `Quantity` (`INTEGER`), optional (default: `nil`).\n     *   - discount: Column `Discount` (`REAL`), optional (default: `nil`).\n     *   - extendedPrice: Column `ExtendedPrice` (`ANY`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(\n      orderID: Int? = nil,\n      productID: Int? = nil,\n      productName: String? = nil,\n      unitPrice: String? = nil,\n      quantity: Int? = nil,\n      discount: Double? = nil,\n      extendedPrice: String? = nil\n    )\n    {\n      self.orderID = orderID\n      self.productID = productID\n      self.productName = productName\n      self.unitPrice = unitPrice\n      self.quantity = quantity\n      self.discount = discount\n      self.extendedPrice = extendedPrice\n    }\n  }\n  \n  \/**\n   * Record representing the `Sales by Category` SQL view.\n   * \n   * Record types represent rows within tables&views in a SQLite database.\n   * They are returned by the functions or queries\/filters generated by\n   * Enlighter.\n   * \n   * ### Examples\n   * \n   * Perform record operations on ``SalesByCategory`` records:\n   * ```swift\n   * let records = try await db.salesByCategories.filter(orderBy: \\.categoryName) {\n   *   $0.categoryName != nil\n   * }\n   * ```\n   * \n   * Perform column selects on the `Sales by Category` table:\n   * ```swift\n   * let values = try await db.select(from: \\.salesByCategories, \\.categoryName) {\n   *   $0.in([ 2, 3 ])\n   * }\n   * ```\n   * \n   * Perform low level operations on ``SalesByCategory`` records:\n   * ```swift\n   * var db : OpaquePointer?\n   * sqlite3_open_v2(path, &db, SQLITE_OPEN_READONLY, nil)\n   * \n   * let records = SalesByCategory.fetch(in: db, orderBy: \"categoryName\", limit: 5) {\n   *   $0.categoryName != nil\n   * }\n   * ```\n   * \n   * ### SQL\n   * \n   * The SQL used to create the view associated with the record:\n   * ```sql\n   * CREATE VIEW [Sales by Category] AS\n   * SELECT Categories.CategoryID,\n   *        Categories.CategoryName,\n   *          Products.ProductName,\n   *   Sum([Order Details Extended].ExtendedPrice) AS ProductSales\n   * FROM  Categories\n   *     JOIN Products\n   *       ON Categories.CategoryID = Products.CategoryID\n   *        JOIN [Order Details Extended]\n   *          ON Products.ProductID = [Order Details Extended].ProductID\n   *            JOIN Orders\n   *              ON Orders.OrderID = [Order Details Extended].OrderID\n   * WHERE Orders.OrderDate BETWEEN DATETIME('1997-01-01') And DATETIME('1997-12-31')\n   * GROUP BY Categories.CategoryID, Categories.CategoryName, Products.ProductName\n   * ```\n   *\/\n  public struct SalesByCategory : SQLViewRecord, Codable {\n    \n    \/\/\/ Static SQL type information for the ``SalesByCategory`` record.\n    public static let schema = Schema()\n    \n    \/\/\/ Column `CategoryID` (`INTEGER`), optional (default: `nil`).\n    public var categoryID : Int?\n    \n    \/\/\/ Column `CategoryName` (`TEXT`), optional (default: `nil`).\n    public var categoryName : String?\n    \n    \/\/\/ Column `ProductName` (`TEXT`), optional (default: `nil`).\n    public var productName : String?\n    \n    \/\/\/ Column `ProductSales` (`ANY`), optional (default: `nil`).\n    public var productSales : String?\n    \n    \/**\n     * Initialize a new ``SalesByCategory`` record.\n     * \n     * - Parameters:\n     *   - categoryID: Column `CategoryID` (`INTEGER`), optional (default: `nil`).\n     *   - categoryName: Column `CategoryName` (`TEXT`), optional (default: `nil`).\n     *   - productName: Column `ProductName` (`TEXT`), optional (default: `nil`).\n     *   - productSales: Column `ProductSales` (`ANY`), optional (default: `nil`).\n     *\/\n    @inlinable\n    public init(\n      categoryID: Int? = nil,\n      categoryName: String? = nil,\n      productName: String? = nil,\n      productSales: String? = nil\n    )\n    {\n      self.categoryID = categoryID\n      self.categoryName = categoryName\n      self.productName = productName\n      self.productSales = productSales\n    }\n  }\n  \n  \/\/\/ Property based access to the ``RecordTypes-swift.struct``.\n  public static let recordTypes = RecordTypes()\n  \n  #if swift(>=5.7)\n  \/\/\/ All RecordTypes defined in the database.\n  public static let _allRecordTypes : [ any SQLRecord.Type ] = [ Category.self, CustomerCustomerDemo.self, CustomerDemographic.self, Customer.self, Employee.self, EmployeeTerritory.self, OrderDetail.self, Order.self, Product.self, Region.self, Shipper.self, Supplier.self, Territory.self, AlphabeticalListOfProduct.self, CurrentProductList.self, CustomerAndSuppliersByCity.self, Invoice.self, OrdersQry.self, OrderSubtotal.self, ProductSalesFor1997.self, ProductsAboveAveragePrice.self, ProductsByCategory.self, QuarterlyOrder.self, SalesTotalsByAmount.self, SummaryOfSalesByQuarter.self, SummaryOfSalesByYear.self, CategorySalesFor1997.self, OrderDetailsExtended.self, SalesByCategory.self ]\n  #endif \/\/ swift(>=5.7)\n  \n  \/\/\/ User version of the database (`PRAGMA user_version`).\n  public static var userVersion = 0\n  \n  \/\/\/ Whether `INSERT  RETURNING` should be used (requires SQLite 3.35.0+).\n  public static var useInsertReturning = sqlite3_libversion_number() >= 3035000\n  \n  public static func withOptCString<R>(\n    _ s: String?,\n    _ body: ( UnsafePointer<CChar>? ) throws -> R\n  ) rethrows -> R\n  {\n    if let s = s { return try s.withCString(body) }\n    else { return try body(nil) }\n  }\n  \n  public static func withOptBlob<R>(\n    _ data: [ UInt8 ]?,\n    _ body: ( UnsafeRawBufferPointer ) throws -> R\n  ) rethrows -> R\n  {\n    if let data = data { return try data.withUnsafeBytes(body) }\n    else { return try body(UnsafeRawBufferPointer(start: nil, count: 0)) }\n  }\n  \n  \/\/\/ The `connectionHandler` is used to open SQLite database connections.\n  public var connectionHandler : SQLConnectionHandler\n  \n  \/**\n   * Initialize ``NorthwindLighter``, read-only, with a `URL`.\n   * \n   * Configures the database with a simple connection pool opening the\n   * specified `URL` read-only.\n   * \n   * Example:\n   * ```swift\n   * let db = NorthwindLighter(url: ...)\n   * \n   * \/\/ Write operations will raise an error.\n   * let readOnly = NorthwindLighter(\n   *   url: Bundle.module.url(forResource: \"samples\", withExtension: \"db\")\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - url: A `URL` pointing to the database to be used.\n   *\/\n  @inlinable\n  public init(url: URL)\n  {\n    self.connectionHandler = .simplePool(url: url, readOnly: true)\n  }\n  \n  \/**\n   * Initialize ``NorthwindLighter``, read-only, with a `URL`.\n   * \n   * Configures the database with a simple connection pool opening the\n   * specified `URL` read-only.\n   * \n   * Example:\n   * ```swift\n   * let db = NorthwindLighter(url: ...)\n   * \n   * \/\/ Write operations will raise an error.\n   * let readOnly = NorthwindLighter(\n   *   url: Bundle.module.url(forResource: \"samples\", withExtension: \"db\")\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - url: A `URL` pointing to the database to be used.\n   *   - readOnly: For protocol conformance, only allowed value: `true`.\n   *\/\n  @inlinable\n  public init(url: URL, readOnly: Bool = true)\n  {\n    self.init(url: url)\n  }\n  \n  \/**\n   * Initialize ``NorthwindLighter`` w\/ a `SQLConnectionHandler`.\n   * \n   * `SQLConnectionHandler`'s are used to open SQLite database connections when\n   * queries are run using the `Lighter` APIs.\n   * The `SQLConnectionHandler` is a protocol and custom handlers\n   * can be provided.\n   * \n   * Example:\n   * ```swift\n   * let db = NorthwindLighter(connectionHandler: .simplePool(\n   *   url: Bundle.module.url(forResource: \"samples\", withExtension: \"db\"),\n   *   readOnly: true,\n   *   maxAge: 10,\n   *   maximumPoolSizePerConfiguration: 4\n   * ))\n   * ```\n   * \n   * - Parameters:\n   *   - connectionHandler: The `SQLConnectionHandler` to use w\/ the database.\n   *\/\n  @inlinable\n  public init(connectionHandler: SQLConnectionHandler)\n  {\n    self.connectionHandler = connectionHandler\n  }\n}\n\npublic extension NorthwindLighter.Category {\n  \n  \/**\n   * Fetch ``Category`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = Category.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Categories\"#\n   * }\n   * \n   * let records = Category.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Categories\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``Category`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.Category ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.Category.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.Category ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.Category(statement, indices: indices))\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.CustomerCustomerDemo {\n  \n  \/**\n   * Fetch ``CustomerCustomerDemo`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = CustomerCustomerDemo.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM CustomerCustomerDemo\"#\n   * }\n   * \n   * let records = CustomerCustomerDemo.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM CustomerCustomerDemo\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``CustomerCustomerDemo`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.CustomerCustomerDemo ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.CustomerCustomerDemo.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.CustomerCustomerDemo ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(\n        NorthwindLighter.CustomerCustomerDemo(statement, indices: indices)\n      )\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.CustomerDemographic {\n  \n  \/**\n   * Fetch ``CustomerDemographic`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = CustomerDemographic.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM CustomerDemographics\"#\n   * }\n   * \n   * let records = CustomerDemographic.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM CustomerDemographics\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``CustomerDemographic`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.CustomerDemographic ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.CustomerDemographic.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.CustomerDemographic ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(\n        NorthwindLighter.CustomerDemographic(statement, indices: indices)\n      )\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.Customer {\n  \n  \/**\n   * Fetch ``Customer`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = Customer.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Customers\"#\n   * }\n   * \n   * let records = Customer.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Customers\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``Customer`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.Customer ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.Customer.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.Customer ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.Customer(statement, indices: indices))\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.Employee {\n  \n  \/**\n   * Fetch ``Employee`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = Employee.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Employees\"#\n   * }\n   * \n   * let records = Employee.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Employees\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``Employee`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.Employee ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.Employee.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.Employee ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.Employee(statement, indices: indices))\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.EmployeeTerritory {\n  \n  \/**\n   * Fetch ``EmployeeTerritory`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = EmployeeTerritory.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM EmployeeTerritories\"#\n   * }\n   * \n   * let records = EmployeeTerritory.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM EmployeeTerritories\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``EmployeeTerritory`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.EmployeeTerritory ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.EmployeeTerritory.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.EmployeeTerritory ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.EmployeeTerritory(statement, indices: indices))\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.OrderDetail {\n  \n  \/**\n   * Fetch ``OrderDetail`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = OrderDetail.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Order Details\"#\n   * }\n   * \n   * let records = OrderDetail.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Order Details\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``OrderDetail`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.OrderDetail ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.OrderDetail.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.OrderDetail ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.OrderDetail(statement, indices: indices))\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.Order {\n  \n  \/**\n   * Fetch ``Order`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = Order.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Orders\"#\n   * }\n   * \n   * let records = Order.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Orders\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``Order`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.Order ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.Order.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.Order ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.Order(statement, indices: indices))\n    }\n    return records\n  }\n  \n  \/**\n   * Fetch a ``Order`` record the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * if let record = Order.find(10, in: db) {\n   *   print(\"Found record:\", record)\n   * }\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Optional custom SQL yielding ``Order`` records, has one `?` parameter containing the ID.\n   *   - primaryKey: The primary key value to lookup (e.g. `10`)\n   * - Returns: The record matching the query, or `nil` if it wasn't found or there was an error.\n   *\/\n  @inlinable\n  static func find(\n    _ primaryKey: Int,\n    `in` db: OpaquePointer!,\n    sql customSQL: String? = nil\n  ) -> NorthwindLighter.Order?\n  {\n    var sql = customSQL ?? NorthwindLighter.Order.Schema.select\n    if customSQL != nil {\n      sql.append(#\" WHERE \"OrderID\" = ? LIMIT 1\"#)\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    sqlite3_bind_int64(statement, 1, Int64(primaryKey))\n    let rc = sqlite3_step(statement)\n    if rc == SQLITE_DONE {\n      return nil\n    }\n    else if rc != SQLITE_ROW {\n      return nil\n    }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    return NorthwindLighter.Order(statement, indices: indices)\n  }\n}\n\npublic extension NorthwindLighter.Product {\n  \n  \/**\n   * Fetch ``Product`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = Product.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Products\"#\n   * }\n   * \n   * let records = Product.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Products\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``Product`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.Product ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.Product.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.Product ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.Product(statement, indices: indices))\n    }\n    return records\n  }\n  \n  \/**\n   * Fetch a ``Product`` record the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * if let record = Product.find(10, in: db) {\n   *   print(\"Found record:\", record)\n   * }\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Optional custom SQL yielding ``Product`` records, has one `?` parameter containing the ID.\n   *   - primaryKey: The primary key value to lookup (e.g. `10`)\n   * - Returns: The record matching the query, or `nil` if it wasn't found or there was an error.\n   *\/\n  @inlinable\n  static func find(\n    _ primaryKey: Int,\n    `in` db: OpaquePointer!,\n    sql customSQL: String? = nil\n  ) -> NorthwindLighter.Product?\n  {\n    var sql = customSQL ?? NorthwindLighter.Product.Schema.select\n    if customSQL != nil {\n      sql.append(#\" WHERE \"ProductID\" = ? LIMIT 1\"#)\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    sqlite3_bind_int64(statement, 1, Int64(primaryKey))\n    let rc = sqlite3_step(statement)\n    if rc == SQLITE_DONE {\n      return nil\n    }\n    else if rc != SQLITE_ROW {\n      return nil\n    }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    return NorthwindLighter.Product(statement, indices: indices)\n  }\n}\n\npublic extension NorthwindLighter.Region {\n  \n  \/**\n   * Fetch ``Region`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = Region.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Regions\"#\n   * }\n   * \n   * let records = Region.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Regions\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``Region`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.Region ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.Region.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.Region ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.Region(statement, indices: indices))\n    }\n    return records\n  }\n  \n  \/**\n   * Fetch a ``Region`` record the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * if let record = Region.find(10, in: db) {\n   *   print(\"Found record:\", record)\n   * }\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Optional custom SQL yielding ``Region`` records, has one `?` parameter containing the ID.\n   *   - primaryKey: The primary key value to lookup (e.g. `10`)\n   * - Returns: The record matching the query, or `nil` if it wasn't found or there was an error.\n   *\/\n  @inlinable\n  static func find(\n    _ primaryKey: Int,\n    `in` db: OpaquePointer!,\n    sql customSQL: String? = nil\n  ) -> NorthwindLighter.Region?\n  {\n    var sql = customSQL ?? NorthwindLighter.Region.Schema.select\n    if customSQL != nil {\n      sql.append(#\" WHERE \"RegionID\" = ? LIMIT 1\"#)\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    sqlite3_bind_int64(statement, 1, Int64(primaryKey))\n    let rc = sqlite3_step(statement)\n    if rc == SQLITE_DONE {\n      return nil\n    }\n    else if rc != SQLITE_ROW {\n      return nil\n    }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    return NorthwindLighter.Region(statement, indices: indices)\n  }\n}\n\npublic extension NorthwindLighter.Shipper {\n  \n  \/**\n   * Fetch ``Shipper`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = Shipper.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Shippers\"#\n   * }\n   * \n   * let records = Shipper.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Shippers\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``Shipper`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.Shipper ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.Shipper.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.Shipper ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.Shipper(statement, indices: indices))\n    }\n    return records\n  }\n  \n  \/**\n   * Fetch a ``Shipper`` record the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * if let record = Shipper.find(10, in: db) {\n   *   print(\"Found record:\", record)\n   * }\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Optional custom SQL yielding ``Shipper`` records, has one `?` parameter containing the ID.\n   *   - primaryKey: The primary key value to lookup (e.g. `10`)\n   * - Returns: The record matching the query, or `nil` if it wasn't found or there was an error.\n   *\/\n  @inlinable\n  static func find(\n    _ primaryKey: Int,\n    `in` db: OpaquePointer!,\n    sql customSQL: String? = nil\n  ) -> NorthwindLighter.Shipper?\n  {\n    var sql = customSQL ?? NorthwindLighter.Shipper.Schema.select\n    if customSQL != nil {\n      sql.append(#\" WHERE \"ShipperID\" = ? LIMIT 1\"#)\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    sqlite3_bind_int64(statement, 1, Int64(primaryKey))\n    let rc = sqlite3_step(statement)\n    if rc == SQLITE_DONE {\n      return nil\n    }\n    else if rc != SQLITE_ROW {\n      return nil\n    }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    return NorthwindLighter.Shipper(statement, indices: indices)\n  }\n}\n\npublic extension NorthwindLighter.Supplier {\n  \n  \/**\n   * Fetch ``Supplier`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = Supplier.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Suppliers\"#\n   * }\n   * \n   * let records = Supplier.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Suppliers\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``Supplier`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.Supplier ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.Supplier.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.Supplier ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.Supplier(statement, indices: indices))\n    }\n    return records\n  }\n  \n  \/**\n   * Fetch a ``Supplier`` record the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * if let record = Supplier.find(10, in: db) {\n   *   print(\"Found record:\", record)\n   * }\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Optional custom SQL yielding ``Supplier`` records, has one `?` parameter containing the ID.\n   *   - primaryKey: The primary key value to lookup (e.g. `10`)\n   * - Returns: The record matching the query, or `nil` if it wasn't found or there was an error.\n   *\/\n  @inlinable\n  static func find(\n    _ primaryKey: Int,\n    `in` db: OpaquePointer!,\n    sql customSQL: String? = nil\n  ) -> NorthwindLighter.Supplier?\n  {\n    var sql = customSQL ?? NorthwindLighter.Supplier.Schema.select\n    if customSQL != nil {\n      sql.append(#\" WHERE \"SupplierID\" = ? LIMIT 1\"#)\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    sqlite3_bind_int64(statement, 1, Int64(primaryKey))\n    let rc = sqlite3_step(statement)\n    if rc == SQLITE_DONE {\n      return nil\n    }\n    else if rc != SQLITE_ROW {\n      return nil\n    }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    return NorthwindLighter.Supplier(statement, indices: indices)\n  }\n}\n\npublic extension NorthwindLighter.Territory {\n  \n  \/**\n   * Fetch ``Territory`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = Territory.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Territories\"#\n   * }\n   * \n   * let records = Territory.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Territories\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``Territory`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.Territory ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.Territory.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.Territory ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.Territory(statement, indices: indices))\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.AlphabeticalListOfProduct {\n  \n  \/**\n   * Fetch ``AlphabeticalListOfProduct`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = AlphabeticalListOfProduct.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Alphabetical list of products\"#\n   * }\n   * \n   * let records = AlphabeticalListOfProduct.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Alphabetical list of products\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``AlphabeticalListOfProduct`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.AlphabeticalListOfProduct ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.AlphabeticalListOfProduct.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.AlphabeticalListOfProduct ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(\n        NorthwindLighter.AlphabeticalListOfProduct(statement, indices: indices)\n      )\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.CurrentProductList {\n  \n  \/**\n   * Fetch ``CurrentProductList`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = CurrentProductList.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Current Product List\"#\n   * }\n   * \n   * let records = CurrentProductList.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Current Product List\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``CurrentProductList`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.CurrentProductList ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.CurrentProductList.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.CurrentProductList ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.CurrentProductList(statement, indices: indices))\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.CustomerAndSuppliersByCity {\n  \n  \/**\n   * Fetch ``CustomerAndSuppliersByCity`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = CustomerAndSuppliersByCity.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Customer and Suppliers by City\"#\n   * }\n   * \n   * let records = CustomerAndSuppliersByCity.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Customer and Suppliers by City\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``CustomerAndSuppliersByCity`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.CustomerAndSuppliersByCity ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.CustomerAndSuppliersByCity.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.CustomerAndSuppliersByCity ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(\n        NorthwindLighter.CustomerAndSuppliersByCity(statement, indices: indices)\n      )\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.Invoice {\n  \n  \/**\n   * Fetch ``Invoice`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = Invoice.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Invoices\"#\n   * }\n   * \n   * let records = Invoice.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Invoices\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``Invoice`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.Invoice ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.Invoice.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.Invoice ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.Invoice(statement, indices: indices))\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.OrdersQry {\n  \n  \/**\n   * Fetch ``OrdersQry`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = OrdersQry.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Orders Qry\"#\n   * }\n   * \n   * let records = OrdersQry.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Orders Qry\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``OrdersQry`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.OrdersQry ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.OrdersQry.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.OrdersQry ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.OrdersQry(statement, indices: indices))\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.OrderSubtotal {\n  \n  \/**\n   * Fetch ``OrderSubtotal`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = OrderSubtotal.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Order Subtotals\"#\n   * }\n   * \n   * let records = OrderSubtotal.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Order Subtotals\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``OrderSubtotal`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.OrderSubtotal ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.OrderSubtotal.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.OrderSubtotal ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.OrderSubtotal(statement, indices: indices))\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.ProductSalesFor1997 {\n  \n  \/**\n   * Fetch ``ProductSalesFor1997`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = ProductSalesFor1997.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Product Sales for 1997\"#\n   * }\n   * \n   * let records = ProductSalesFor1997.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Product Sales for 1997\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``ProductSalesFor1997`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.ProductSalesFor1997 ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.ProductSalesFor1997.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.ProductSalesFor1997 ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(\n        NorthwindLighter.ProductSalesFor1997(statement, indices: indices)\n      )\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.ProductsAboveAveragePrice {\n  \n  \/**\n   * Fetch ``ProductsAboveAveragePrice`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = ProductsAboveAveragePrice.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Products Above Average Price\"#\n   * }\n   * \n   * let records = ProductsAboveAveragePrice.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Products Above Average Price\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``ProductsAboveAveragePrice`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.ProductsAboveAveragePrice ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.ProductsAboveAveragePrice.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.ProductsAboveAveragePrice ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(\n        NorthwindLighter.ProductsAboveAveragePrice(statement, indices: indices)\n      )\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.ProductsByCategory {\n  \n  \/**\n   * Fetch ``ProductsByCategory`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = ProductsByCategory.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Products by Category\"#\n   * }\n   * \n   * let records = ProductsByCategory.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Products by Category\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``ProductsByCategory`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.ProductsByCategory ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.ProductsByCategory.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.ProductsByCategory ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.ProductsByCategory(statement, indices: indices))\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.QuarterlyOrder {\n  \n  \/**\n   * Fetch ``QuarterlyOrder`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = QuarterlyOrder.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Quarterly Orders\"#\n   * }\n   * \n   * let records = QuarterlyOrder.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Quarterly Orders\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``QuarterlyOrder`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.QuarterlyOrder ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.QuarterlyOrder.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.QuarterlyOrder ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.QuarterlyOrder(statement, indices: indices))\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.SalesTotalsByAmount {\n  \n  \/**\n   * Fetch ``SalesTotalsByAmount`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = SalesTotalsByAmount.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Sales Totals by Amount\"#\n   * }\n   * \n   * let records = SalesTotalsByAmount.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Sales Totals by Amount\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``SalesTotalsByAmount`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.SalesTotalsByAmount ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.SalesTotalsByAmount.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.SalesTotalsByAmount ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(\n        NorthwindLighter.SalesTotalsByAmount(statement, indices: indices)\n      )\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.SummaryOfSalesByQuarter {\n  \n  \/**\n   * Fetch ``SummaryOfSalesByQuarter`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = SummaryOfSalesByQuarter.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Summary of Sales by Quarter\"#\n   * }\n   * \n   * let records = SummaryOfSalesByQuarter.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Summary of Sales by Quarter\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``SummaryOfSalesByQuarter`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.SummaryOfSalesByQuarter ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.SummaryOfSalesByQuarter.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.SummaryOfSalesByQuarter ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(\n        NorthwindLighter.SummaryOfSalesByQuarter(statement, indices: indices)\n      )\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.SummaryOfSalesByYear {\n  \n  \/**\n   * Fetch ``SummaryOfSalesByYear`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = SummaryOfSalesByYear.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Summary of Sales by Year\"#\n   * }\n   * \n   * let records = SummaryOfSalesByYear.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Summary of Sales by Year\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``SummaryOfSalesByYear`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.SummaryOfSalesByYear ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.SummaryOfSalesByYear.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.SummaryOfSalesByYear ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(\n        NorthwindLighter.SummaryOfSalesByYear(statement, indices: indices)\n      )\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.CategorySalesFor1997 {\n  \n  \/**\n   * Fetch ``CategorySalesFor1997`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = CategorySalesFor1997.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Category Sales for 1997\"#\n   * }\n   * \n   * let records = CategorySalesFor1997.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Category Sales for 1997\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``CategorySalesFor1997`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.CategorySalesFor1997 ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.CategorySalesFor1997.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.CategorySalesFor1997 ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(\n        NorthwindLighter.CategorySalesFor1997(statement, indices: indices)\n      )\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.OrderDetailsExtended {\n  \n  \/**\n   * Fetch ``OrderDetailsExtended`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = OrderDetailsExtended.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Order Details Extended\"#\n   * }\n   * \n   * let records = OrderDetailsExtended.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Order Details Extended\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``OrderDetailsExtended`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.OrderDetailsExtended ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.OrderDetailsExtended.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.OrderDetailsExtended ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(\n        NorthwindLighter.OrderDetailsExtended(statement, indices: indices)\n      )\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.SalesByCategory {\n  \n  \/**\n   * Fetch ``SalesByCategory`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = SalesByCategory.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM Sales by Category\"#\n   * }\n   * \n   * let records = SalesByCategory.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM Sales by Category\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``SalesByCategory`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ NorthwindLighter.SalesByCategory ]?\n  {\n    var sql = customSQL ?? NorthwindLighter.SalesByCategory.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ NorthwindLighter.SalesByCategory ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(NorthwindLighter.SalesByCategory(statement, indices: indices))\n    }\n    return records\n  }\n}\n\npublic extension NorthwindLighter.Category {\n  \n  \/**\n   * Static type information for the ``Category`` record (`Categories` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLKeyedTableSchema {\n    \n    public typealias PropertyIndices = ( idx_id: Int32, idx_categoryName: Int32, idx_description: Int32, idx_picture: Int32 )\n    public typealias RecordType = NorthwindLighter.Category\n    \n    \/\/\/ The SQL table name associated with the ``Category`` record.\n    public static let externalName = \"Categories\"\n    \n    \/\/\/ The number of columns the `Categories` table has.\n    public static let columnCount : Int32 = 4\n    \n    \/\/\/ Information on the records primary key (``Category\/id``).\n    public static let primaryKeyColumn = MappedColumn<NorthwindLighter.Category, Int?>(\n      externalName: \"CategoryID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Category.id\n    )\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Categories` table.\n    public static let select = #\"SELECT \"CategoryID\", \"CategoryName\", \"Description\", \"Picture\" FROM \"Categories\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"CategoryID\", \"CategoryName\", \"Description\", \"Picture\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let update = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let updateParameterIndices : PropertyIndices = ( -1, -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insert = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertReturning = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertParameterIndices : PropertyIndices = ( -1, -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let delete = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let deleteParameterIndices : PropertyIndices = ( -1, -1, -1, -1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Categories_id FROM Categories`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Categories_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"CategoryID\") == 0 {\n          indices.idx_id = i\n        }\n        else if strcmp(col!, \"CategoryName\") == 0 {\n          indices.idx_categoryName = i\n        }\n        else if strcmp(col!, \"Description\") == 0 {\n          indices.idx_description = i\n        }\n        else if strcmp(col!, \"Picture\") == 0 {\n          indices.idx_picture = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``Category\/id`` (`CategoryID` column).\n    public let id = MappedColumn<NorthwindLighter.Category, Int?>(\n      externalName: \"CategoryID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Category.id\n    )\n    \n    \/\/\/ Type information for property ``Category\/categoryName`` (`CategoryName` column).\n    public let categoryName = MappedColumn<NorthwindLighter.Category, String?>(\n      externalName: \"CategoryName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Category.categoryName\n    )\n    \n    \/\/\/ Type information for property ``Category\/description`` (`Description` column).\n    public let description = MappedColumn<NorthwindLighter.Category, String?>(\n      externalName: \"Description\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Category.description\n    )\n    \n    \/\/\/ Type information for property ``Category\/picture`` (`Picture` column).\n    public let picture = MappedColumn<NorthwindLighter.Category, [ UInt8 ]?>(\n      externalName: \"Picture\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Category.picture\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ id, categoryName, description, picture ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``Category`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Categories\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = Category(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      id: (indices.idx_id >= 0) && (indices.idx_id < argc) ? (sqlite3_column_type(statement, indices.idx_id) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_id)) : nil) : Self.schema.id.defaultValue,\n      categoryName: (indices.idx_categoryName >= 0) && (indices.idx_categoryName < argc) ? (sqlite3_column_text(statement, indices.idx_categoryName).flatMap(String.init(cString:))) : Self.schema.categoryName.defaultValue,\n      description: (indices.idx_description >= 0) && (indices.idx_description < argc) ? (sqlite3_column_text(statement, indices.idx_description).flatMap(String.init(cString:))) : Self.schema.description.defaultValue,\n      picture: (indices.idx_picture >= 0) && (indices.idx_picture < argc) ? (sqlite3_column_blob(statement, indices.idx_picture).flatMap({ [ UInt8 ](UnsafeRawBufferPointer(start: $0, count: Int(sqlite3_column_bytes(statement, indices.idx_picture)))) })) : Self.schema.picture.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``Category`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE \"Categories\" SET \"CategoryName\" = ?, \"Description\" = ?, \"Picture\" = ? WHERE \"CategoryID\" = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = Category(id: 1, categoryName: \"Hello\", description: \"World\", picture: nil)\n   * let ok = record.bind(to: statement, indices: ( 4, 1, 2, 3 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_id >= 0 {\n      if let id = id {\n        sqlite3_bind_int64(statement, indices.idx_id, Int64(id))\n      }\n      else {\n        sqlite3_bind_null(statement, indices.idx_id)\n      }\n    }\n    return try NorthwindLighter.withOptCString(categoryName) { ( s ) in\n      if indices.idx_categoryName >= 0 {\n        sqlite3_bind_text(statement, indices.idx_categoryName, s, -1, nil)\n      }\n      return try NorthwindLighter.withOptCString(description) { ( s ) in\n        if indices.idx_description >= 0 {\n          sqlite3_bind_text(statement, indices.idx_description, s, -1, nil)\n        }\n        return try NorthwindLighter.withOptBlob(picture) { ( rbp ) in\n          if indices.idx_picture >= 0 {\n            sqlite3_bind_blob(\n              statement,\n              indices.idx_picture,\n              rbp.baseAddress,\n              Int32(rbp.count),\n              nil\n            )\n          }\n          return try execute()\n        }\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.CustomerCustomerDemo {\n  \n  \/**\n   * Static type information for the ``CustomerCustomerDemo`` record (`CustomerCustomerDemo` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLTableSchema {\n    \n    public typealias PropertyIndices = ( idx_customerID: Int32, idx_customerTypeID: Int32 )\n    public typealias RecordType = NorthwindLighter.CustomerCustomerDemo\n    \n    \/\/\/ The SQL table name associated with the ``CustomerCustomerDemo`` record.\n    public static let externalName = \"CustomerCustomerDemo\"\n    \n    \/\/\/ The number of columns the `CustomerCustomerDemo` table has.\n    public static let columnCount : Int32 = 2\n    \n    \/\/\/ SQL to `SELECT` all columns of the `CustomerCustomerDemo` table.\n    public static let select = #\"SELECT \"CustomerID\", \"CustomerTypeID\" FROM \"CustomerCustomerDemo\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"CustomerID\", \"CustomerTypeID\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let update = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let updateParameterIndices : PropertyIndices = ( -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insert = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertReturning = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertParameterIndices : PropertyIndices = ( -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let delete = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let deleteParameterIndices : PropertyIndices = ( -1, -1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, CustomerCustomerDemo_id FROM CustomerCustomerDemo`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `CustomerCustomerDemo_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"CustomerID\") == 0 {\n          indices.idx_customerID = i\n        }\n        else if strcmp(col!, \"CustomerTypeID\") == 0 {\n          indices.idx_customerTypeID = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``CustomerCustomerDemo\/customerID`` (`CustomerID` column).\n    public let customerID = MappedForeignKey<NorthwindLighter.CustomerCustomerDemo, String, MappedColumn<NorthwindLighter.Customer, String?>>(\n      externalName: \"CustomerID\",\n      defaultValue: \"\",\n      keyPath: \\NorthwindLighter.CustomerCustomerDemo.customerID,\n      destinationColumn: NorthwindLighter.Customer.schema.id\n    )\n    \n    \/\/\/ Type information for property ``CustomerCustomerDemo\/customerTypeID`` (`CustomerTypeID` column).\n    public let customerTypeID = MappedForeignKey<NorthwindLighter.CustomerCustomerDemo, String, MappedColumn<NorthwindLighter.CustomerDemographic, String>>(\n      externalName: \"CustomerTypeID\",\n      defaultValue: \"\",\n      keyPath: \\NorthwindLighter.CustomerCustomerDemo.customerTypeID,\n      destinationColumn: NorthwindLighter.CustomerDemographic.schema.id\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ customerID, customerTypeID ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``CustomerCustomerDemo`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM CustomerCustomerDemo\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = CustomerCustomerDemo(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      customerID: ((indices.idx_customerID >= 0) && (indices.idx_customerID < argc) ? (sqlite3_column_text(statement, indices.idx_customerID).flatMap(String.init(cString:))) : nil) ?? Self.schema.customerID.defaultValue,\n      customerTypeID: ((indices.idx_customerTypeID >= 0) && (indices.idx_customerTypeID < argc) ? (sqlite3_column_text(statement, indices.idx_customerTypeID).flatMap(String.init(cString:))) : nil) ?? Self.schema.customerTypeID.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``CustomerCustomerDemo`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE CustomerCustomerDemo SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = CustomerCustomerDemo(customerID: \"Hello\", customerTypeID: \"World\")\n   * let ok = record.bind(to: statement, indices: ( 1, 2 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    return try customerID.withCString() { ( s ) in\n      if indices.idx_customerID >= 0 {\n        sqlite3_bind_text(statement, indices.idx_customerID, s, -1, nil)\n      }\n      return try customerTypeID.withCString() { ( s ) in\n        if indices.idx_customerTypeID >= 0 {\n          sqlite3_bind_text(statement, indices.idx_customerTypeID, s, -1, nil)\n        }\n        return try execute()\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.CustomerDemographic {\n  \n  \/**\n   * Static type information for the ``CustomerDemographic`` record (`CustomerDemographics` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLKeyedTableSchema {\n    \n    public typealias PropertyIndices = ( idx_id: Int32, idx_customerDesc: Int32 )\n    public typealias RecordType = NorthwindLighter.CustomerDemographic\n    \n    \/\/\/ The SQL table name associated with the ``CustomerDemographic`` record.\n    public static let externalName = \"CustomerDemographics\"\n    \n    \/\/\/ The number of columns the `CustomerDemographics` table has.\n    public static let columnCount : Int32 = 2\n    \n    \/\/\/ Information on the records primary key (``CustomerDemographic\/id``).\n    public static let primaryKeyColumn = MappedColumn<NorthwindLighter.CustomerDemographic, String>(\n      externalName: \"CustomerTypeID\",\n      defaultValue: \"\",\n      keyPath: \\NorthwindLighter.CustomerDemographic.id\n    )\n    \n    \/\/\/ SQL to `SELECT` all columns of the `CustomerDemographics` table.\n    public static let select = #\"SELECT \"CustomerTypeID\", \"CustomerDesc\" FROM \"CustomerDemographics\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"CustomerTypeID\", \"CustomerDesc\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let update = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let updateParameterIndices : PropertyIndices = ( -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insert = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertReturning = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertParameterIndices : PropertyIndices = ( -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let delete = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let deleteParameterIndices : PropertyIndices = ( -1, -1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, CustomerDemographics_id FROM CustomerDemographics`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `CustomerDemographics_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"CustomerTypeID\") == 0 {\n          indices.idx_id = i\n        }\n        else if strcmp(col!, \"CustomerDesc\") == 0 {\n          indices.idx_customerDesc = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``CustomerDemographic\/id`` (`CustomerTypeID` column).\n    public let id = MappedColumn<NorthwindLighter.CustomerDemographic, String>(\n      externalName: \"CustomerTypeID\",\n      defaultValue: \"\",\n      keyPath: \\NorthwindLighter.CustomerDemographic.id\n    )\n    \n    \/\/\/ Type information for property ``CustomerDemographic\/customerDesc`` (`CustomerDesc` column).\n    public let customerDesc = MappedColumn<NorthwindLighter.CustomerDemographic, String?>(\n      externalName: \"CustomerDesc\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.CustomerDemographic.customerDesc\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ id, customerDesc ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``CustomerDemographic`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM CustomerDemographics\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = CustomerDemographic(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      id: ((indices.idx_id >= 0) && (indices.idx_id < argc) ? (sqlite3_column_text(statement, indices.idx_id).flatMap(String.init(cString:))) : nil) ?? Self.schema.id.defaultValue,\n      customerDesc: (indices.idx_customerDesc >= 0) && (indices.idx_customerDesc < argc) ? (sqlite3_column_text(statement, indices.idx_customerDesc).flatMap(String.init(cString:))) : Self.schema.customerDesc.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``CustomerDemographic`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE \"CustomerDemographics\" SET \"CustomerDesc\" = ? WHERE \"CustomerTypeID\" = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = CustomerDemographic(id: \"Hello\", customerDesc: \"World\")\n   * let ok = record.bind(to: statement, indices: ( 2, 1 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    return try id.withCString() { ( s ) in\n      if indices.idx_id >= 0 {\n        sqlite3_bind_text(statement, indices.idx_id, s, -1, nil)\n      }\n      return try NorthwindLighter.withOptCString(customerDesc) { ( s ) in\n        if indices.idx_customerDesc >= 0 {\n          sqlite3_bind_text(statement, indices.idx_customerDesc, s, -1, nil)\n        }\n        return try execute()\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.Customer {\n  \n  \/**\n   * Static type information for the ``Customer`` record (`Customers` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLKeyedTableSchema {\n    \n    public typealias PropertyIndices = ( idx_id: Int32, idx_companyName: Int32, idx_contactName: Int32, idx_contactTitle: Int32, idx_address: Int32, idx_city: Int32, idx_region: Int32, idx_postalCode: Int32, idx_country: Int32, idx_phone: Int32, idx_fax: Int32 )\n    public typealias RecordType = NorthwindLighter.Customer\n    \n    \/\/\/ The SQL table name associated with the ``Customer`` record.\n    public static let externalName = \"Customers\"\n    \n    \/\/\/ The number of columns the `Customers` table has.\n    public static let columnCount : Int32 = 11\n    \n    \/\/\/ Information on the records primary key (``Customer\/id``).\n    public static let primaryKeyColumn = MappedColumn<NorthwindLighter.Customer, String?>(\n      externalName: \"CustomerID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Customer.id\n    )\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Customers` table.\n    public static let select = #\"SELECT \"CustomerID\", \"CompanyName\", \"ContactName\", \"ContactTitle\", \"Address\", \"City\", \"Region\", \"PostalCode\", \"Country\", \"Phone\", \"Fax\" FROM \"Customers\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"CustomerID\", \"CompanyName\", \"ContactName\", \"ContactTitle\", \"Address\", \"City\", \"Region\", \"PostalCode\", \"Country\", \"Phone\", \"Fax\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let update = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let updateParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insert = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertReturning = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let delete = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let deleteParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Customers_id FROM Customers`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Customers_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"CustomerID\") == 0 {\n          indices.idx_id = i\n        }\n        else if strcmp(col!, \"CompanyName\") == 0 {\n          indices.idx_companyName = i\n        }\n        else if strcmp(col!, \"ContactName\") == 0 {\n          indices.idx_contactName = i\n        }\n        else if strcmp(col!, \"ContactTitle\") == 0 {\n          indices.idx_contactTitle = i\n        }\n        else if strcmp(col!, \"Address\") == 0 {\n          indices.idx_address = i\n        }\n        else if strcmp(col!, \"City\") == 0 {\n          indices.idx_city = i\n        }\n        else if strcmp(col!, \"Region\") == 0 {\n          indices.idx_region = i\n        }\n        else if strcmp(col!, \"PostalCode\") == 0 {\n          indices.idx_postalCode = i\n        }\n        else if strcmp(col!, \"Country\") == 0 {\n          indices.idx_country = i\n        }\n        else if strcmp(col!, \"Phone\") == 0 {\n          indices.idx_phone = i\n        }\n        else if strcmp(col!, \"Fax\") == 0 {\n          indices.idx_fax = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``Customer\/id`` (`CustomerID` column).\n    public let id = MappedColumn<NorthwindLighter.Customer, String?>(\n      externalName: \"CustomerID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Customer.id\n    )\n    \n    \/\/\/ Type information for property ``Customer\/companyName`` (`CompanyName` column).\n    public let companyName = MappedColumn<NorthwindLighter.Customer, String?>(\n      externalName: \"CompanyName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Customer.companyName\n    )\n    \n    \/\/\/ Type information for property ``Customer\/contactName`` (`ContactName` column).\n    public let contactName = MappedColumn<NorthwindLighter.Customer, String?>(\n      externalName: \"ContactName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Customer.contactName\n    )\n    \n    \/\/\/ Type information for property ``Customer\/contactTitle`` (`ContactTitle` column).\n    public let contactTitle = MappedColumn<NorthwindLighter.Customer, String?>(\n      externalName: \"ContactTitle\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Customer.contactTitle\n    )\n    \n    \/\/\/ Type information for property ``Customer\/address`` (`Address` column).\n    public let address = MappedColumn<NorthwindLighter.Customer, String?>(\n      externalName: \"Address\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Customer.address\n    )\n    \n    \/\/\/ Type information for property ``Customer\/city`` (`City` column).\n    public let city = MappedColumn<NorthwindLighter.Customer, String?>(\n      externalName: \"City\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Customer.city\n    )\n    \n    \/\/\/ Type information for property ``Customer\/region`` (`Region` column).\n    public let region = MappedColumn<NorthwindLighter.Customer, String?>(\n      externalName: \"Region\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Customer.region\n    )\n    \n    \/\/\/ Type information for property ``Customer\/postalCode`` (`PostalCode` column).\n    public let postalCode = MappedColumn<NorthwindLighter.Customer, String?>(\n      externalName: \"PostalCode\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Customer.postalCode\n    )\n    \n    \/\/\/ Type information for property ``Customer\/country`` (`Country` column).\n    public let country = MappedColumn<NorthwindLighter.Customer, String?>(\n      externalName: \"Country\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Customer.country\n    )\n    \n    \/\/\/ Type information for property ``Customer\/phone`` (`Phone` column).\n    public let phone = MappedColumn<NorthwindLighter.Customer, String?>(\n      externalName: \"Phone\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Customer.phone\n    )\n    \n    \/\/\/ Type information for property ``Customer\/fax`` (`Fax` column).\n    public let fax = MappedColumn<NorthwindLighter.Customer, String?>(\n      externalName: \"Fax\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Customer.fax\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ id, companyName, contactName, contactTitle, address, city, region, postalCode, country, phone, fax ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``Customer`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Customers\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = Customer(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      id: (indices.idx_id >= 0) && (indices.idx_id < argc) ? (sqlite3_column_text(statement, indices.idx_id).flatMap(String.init(cString:))) : Self.schema.id.defaultValue,\n      companyName: (indices.idx_companyName >= 0) && (indices.idx_companyName < argc) ? (sqlite3_column_text(statement, indices.idx_companyName).flatMap(String.init(cString:))) : Self.schema.companyName.defaultValue,\n      contactName: (indices.idx_contactName >= 0) && (indices.idx_contactName < argc) ? (sqlite3_column_text(statement, indices.idx_contactName).flatMap(String.init(cString:))) : Self.schema.contactName.defaultValue,\n      contactTitle: (indices.idx_contactTitle >= 0) && (indices.idx_contactTitle < argc) ? (sqlite3_column_text(statement, indices.idx_contactTitle).flatMap(String.init(cString:))) : Self.schema.contactTitle.defaultValue,\n      address: (indices.idx_address >= 0) && (indices.idx_address < argc) ? (sqlite3_column_text(statement, indices.idx_address).flatMap(String.init(cString:))) : Self.schema.address.defaultValue,\n      city: (indices.idx_city >= 0) && (indices.idx_city < argc) ? (sqlite3_column_text(statement, indices.idx_city).flatMap(String.init(cString:))) : Self.schema.city.defaultValue,\n      region: (indices.idx_region >= 0) && (indices.idx_region < argc) ? (sqlite3_column_text(statement, indices.idx_region).flatMap(String.init(cString:))) : Self.schema.region.defaultValue,\n      postalCode: (indices.idx_postalCode >= 0) && (indices.idx_postalCode < argc) ? (sqlite3_column_text(statement, indices.idx_postalCode).flatMap(String.init(cString:))) : Self.schema.postalCode.defaultValue,\n      country: (indices.idx_country >= 0) && (indices.idx_country < argc) ? (sqlite3_column_text(statement, indices.idx_country).flatMap(String.init(cString:))) : Self.schema.country.defaultValue,\n      phone: (indices.idx_phone >= 0) && (indices.idx_phone < argc) ? (sqlite3_column_text(statement, indices.idx_phone).flatMap(String.init(cString:))) : Self.schema.phone.defaultValue,\n      fax: (indices.idx_fax >= 0) && (indices.idx_fax < argc) ? (sqlite3_column_text(statement, indices.idx_fax).flatMap(String.init(cString:))) : Self.schema.fax.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``Customer`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE \"Customers\" SET \"CompanyName\" = ?, \"ContactName\" = ?, \"ContactTitle\" = ?, \"Address\" = ?, \"City\" = ?, \"Region\" = ?, \"PostalCode\" = ?, \"Country\" = ?, \"Phone\" = ?, \"Fax\" = ? WHERE \"CustomerID\" = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = Customer(id: \"Hello\", companyName: \"World\", contactName: \"Duck\", contactTitle: \"Donald\")\n   * let ok = record.bind(to: statement, indices: ( 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    return try NorthwindLighter.withOptCString(id) { ( s ) in\n      if indices.idx_id >= 0 {\n        sqlite3_bind_text(statement, indices.idx_id, s, -1, nil)\n      }\n      return try NorthwindLighter.withOptCString(companyName) { ( s ) in\n        if indices.idx_companyName >= 0 {\n          sqlite3_bind_text(statement, indices.idx_companyName, s, -1, nil)\n        }\n        return try NorthwindLighter.withOptCString(contactName) { ( s ) in\n          if indices.idx_contactName >= 0 {\n            sqlite3_bind_text(statement, indices.idx_contactName, s, -1, nil)\n          }\n          return try NorthwindLighter.withOptCString(contactTitle) { ( s ) in\n            if indices.idx_contactTitle >= 0 {\n              sqlite3_bind_text(statement, indices.idx_contactTitle, s, -1, nil)\n            }\n            return try NorthwindLighter.withOptCString(address) { ( s ) in\n              if indices.idx_address >= 0 {\n                sqlite3_bind_text(statement, indices.idx_address, s, -1, nil)\n              }\n              return try NorthwindLighter.withOptCString(city) { ( s ) in\n                if indices.idx_city >= 0 {\n                  sqlite3_bind_text(statement, indices.idx_city, s, -1, nil)\n                }\n                return try NorthwindLighter.withOptCString(region) { ( s ) in\n                  if indices.idx_region >= 0 {\n                    sqlite3_bind_text(statement, indices.idx_region, s, -1, nil)\n                  }\n                  return try NorthwindLighter.withOptCString(postalCode) { ( s ) in\n                    if indices.idx_postalCode >= 0 {\n                      sqlite3_bind_text(statement, indices.idx_postalCode, s, -1, nil)\n                    }\n                    return try NorthwindLighter.withOptCString(country) { ( s ) in\n                      if indices.idx_country >= 0 {\n                        sqlite3_bind_text(statement, indices.idx_country, s, -1, nil)\n                      }\n                      return try NorthwindLighter.withOptCString(phone) { ( s ) in\n                        if indices.idx_phone >= 0 {\n                          sqlite3_bind_text(statement, indices.idx_phone, s, -1, nil)\n                        }\n                        return try NorthwindLighter.withOptCString(fax) { ( s ) in\n                          if indices.idx_fax >= 0 {\n                            sqlite3_bind_text(statement, indices.idx_fax, s, -1, nil)\n                          }\n                          return try execute()\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.Employee {\n  \n  \/**\n   * Static type information for the ``Employee`` record (`Employees` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLKeyedTableSchema {\n    \n    public typealias PropertyIndices = ( idx_id: Int32, idx_lastName: Int32, idx_firstName: Int32, idx_title: Int32, idx_titleOfCourtesy: Int32, idx_birthDate: Int32, idx_hireDate: Int32, idx_address: Int32, idx_city: Int32, idx_region: Int32, idx_postalCode: Int32, idx_country: Int32, idx_homePhone: Int32, idx_extension: Int32, idx_photo: Int32, idx_notes: Int32, idx_reportsTo: Int32, idx_photoPath: Int32 )\n    public typealias RecordType = NorthwindLighter.Employee\n    \n    \/\/\/ The SQL table name associated with the ``Employee`` record.\n    public static let externalName = \"Employees\"\n    \n    \/\/\/ The number of columns the `Employees` table has.\n    public static let columnCount : Int32 = 18\n    \n    \/\/\/ Information on the records primary key (``Employee\/id``).\n    public static let primaryKeyColumn = MappedColumn<NorthwindLighter.Employee, Int?>(\n      externalName: \"EmployeeID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.id\n    )\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Employees` table.\n    public static let select = #\"SELECT \"EmployeeID\", \"LastName\", \"FirstName\", \"Title\", \"TitleOfCourtesy\", \"BirthDate\", \"HireDate\", \"Address\", \"City\", \"Region\", \"PostalCode\", \"Country\", \"HomePhone\", \"Extension\", \"Photo\", \"Notes\", \"ReportsTo\", \"PhotoPath\" FROM \"Employees\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"EmployeeID\", \"LastName\", \"FirstName\", \"Title\", \"TitleOfCourtesy\", \"BirthDate\", \"HireDate\", \"Address\", \"City\", \"Region\", \"PostalCode\", \"Country\", \"HomePhone\", \"Extension\", \"Photo\", \"Notes\", \"ReportsTo\", \"PhotoPath\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let update = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let updateParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insert = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertReturning = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let delete = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let deleteParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Employees_id FROM Employees`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Employees_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"EmployeeID\") == 0 {\n          indices.idx_id = i\n        }\n        else if strcmp(col!, \"LastName\") == 0 {\n          indices.idx_lastName = i\n        }\n        else if strcmp(col!, \"FirstName\") == 0 {\n          indices.idx_firstName = i\n        }\n        else if strcmp(col!, \"Title\") == 0 {\n          indices.idx_title = i\n        }\n        else if strcmp(col!, \"TitleOfCourtesy\") == 0 {\n          indices.idx_titleOfCourtesy = i\n        }\n        else if strcmp(col!, \"BirthDate\") == 0 {\n          indices.idx_birthDate = i\n        }\n        else if strcmp(col!, \"HireDate\") == 0 {\n          indices.idx_hireDate = i\n        }\n        else if strcmp(col!, \"Address\") == 0 {\n          indices.idx_address = i\n        }\n        else if strcmp(col!, \"City\") == 0 {\n          indices.idx_city = i\n        }\n        else if strcmp(col!, \"Region\") == 0 {\n          indices.idx_region = i\n        }\n        else if strcmp(col!, \"PostalCode\") == 0 {\n          indices.idx_postalCode = i\n        }\n        else if strcmp(col!, \"Country\") == 0 {\n          indices.idx_country = i\n        }\n        else if strcmp(col!, \"HomePhone\") == 0 {\n          indices.idx_homePhone = i\n        }\n        else if strcmp(col!, \"Extension\") == 0 {\n          indices.idx_extension = i\n        }\n        else if strcmp(col!, \"Photo\") == 0 {\n          indices.idx_photo = i\n        }\n        else if strcmp(col!, \"Notes\") == 0 {\n          indices.idx_notes = i\n        }\n        else if strcmp(col!, \"ReportsTo\") == 0 {\n          indices.idx_reportsTo = i\n        }\n        else if strcmp(col!, \"PhotoPath\") == 0 {\n          indices.idx_photoPath = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``Employee\/id`` (`EmployeeID` column).\n    public let id = MappedColumn<NorthwindLighter.Employee, Int?>(\n      externalName: \"EmployeeID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.id\n    )\n    \n    \/\/\/ Type information for property ``Employee\/lastName`` (`LastName` column).\n    public let lastName = MappedColumn<NorthwindLighter.Employee, String?>(\n      externalName: \"LastName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.lastName\n    )\n    \n    \/\/\/ Type information for property ``Employee\/firstName`` (`FirstName` column).\n    public let firstName = MappedColumn<NorthwindLighter.Employee, String?>(\n      externalName: \"FirstName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.firstName\n    )\n    \n    \/\/\/ Type information for property ``Employee\/title`` (`Title` column).\n    public let title = MappedColumn<NorthwindLighter.Employee, String?>(\n      externalName: \"Title\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.title\n    )\n    \n    \/\/\/ Type information for property ``Employee\/titleOfCourtesy`` (`TitleOfCourtesy` column).\n    public let titleOfCourtesy = MappedColumn<NorthwindLighter.Employee, String?>(\n      externalName: \"TitleOfCourtesy\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.titleOfCourtesy\n    )\n    \n    \/\/\/ Type information for property ``Employee\/birthDate`` (`BirthDate` column).\n    public let birthDate = MappedColumn<NorthwindLighter.Employee, String?>(\n      externalName: \"BirthDate\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.birthDate\n    )\n    \n    \/\/\/ Type information for property ``Employee\/hireDate`` (`HireDate` column).\n    public let hireDate = MappedColumn<NorthwindLighter.Employee, String?>(\n      externalName: \"HireDate\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.hireDate\n    )\n    \n    \/\/\/ Type information for property ``Employee\/address`` (`Address` column).\n    public let address = MappedColumn<NorthwindLighter.Employee, String?>(\n      externalName: \"Address\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.address\n    )\n    \n    \/\/\/ Type information for property ``Employee\/city`` (`City` column).\n    public let city = MappedColumn<NorthwindLighter.Employee, String?>(\n      externalName: \"City\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.city\n    )\n    \n    \/\/\/ Type information for property ``Employee\/region`` (`Region` column).\n    public let region = MappedColumn<NorthwindLighter.Employee, String?>(\n      externalName: \"Region\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.region\n    )\n    \n    \/\/\/ Type information for property ``Employee\/postalCode`` (`PostalCode` column).\n    public let postalCode = MappedColumn<NorthwindLighter.Employee, String?>(\n      externalName: \"PostalCode\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.postalCode\n    )\n    \n    \/\/\/ Type information for property ``Employee\/country`` (`Country` column).\n    public let country = MappedColumn<NorthwindLighter.Employee, String?>(\n      externalName: \"Country\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.country\n    )\n    \n    \/\/\/ Type information for property ``Employee\/homePhone`` (`HomePhone` column).\n    public let homePhone = MappedColumn<NorthwindLighter.Employee, String?>(\n      externalName: \"HomePhone\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.homePhone\n    )\n    \n    \/\/\/ Type information for property ``Employee\/extension`` (`Extension` column).\n    public let `extension` = MappedColumn<NorthwindLighter.Employee, String?>(\n      externalName: \"Extension\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.`extension`\n    )\n    \n    \/\/\/ Type information for property ``Employee\/photo`` (`Photo` column).\n    public let photo = MappedColumn<NorthwindLighter.Employee, [ UInt8 ]?>(\n      externalName: \"Photo\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.photo\n    )\n    \n    \/\/\/ Type information for property ``Employee\/notes`` (`Notes` column).\n    public let notes = MappedColumn<NorthwindLighter.Employee, String?>(\n      externalName: \"Notes\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.notes\n    )\n    \n    \/\/\/ Type information for property ``Employee\/reportsTo`` (`ReportsTo` column).\n    public let reportsTo = MappedForeignKey<NorthwindLighter.Employee, Int?, MappedColumn<NorthwindLighter.Employee, Int?>>(\n      externalName: \"ReportsTo\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.reportsTo,\n      destinationColumn: NorthwindLighter.Employee.schema.id\n    )\n    \n    \/\/\/ Type information for property ``Employee\/photoPath`` (`PhotoPath` column).\n    public let photoPath = MappedColumn<NorthwindLighter.Employee, String?>(\n      externalName: \"PhotoPath\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Employee.photoPath\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ id, lastName, firstName, title, titleOfCourtesy, birthDate, hireDate, address, city, region, postalCode, country, homePhone, `extension`, photo, notes, reportsTo, photoPath ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``Employee`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Employees\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = Employee(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      id: (indices.idx_id >= 0) && (indices.idx_id < argc) ? (sqlite3_column_type(statement, indices.idx_id) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_id)) : nil) : Self.schema.id.defaultValue,\n      lastName: (indices.idx_lastName >= 0) && (indices.idx_lastName < argc) ? (sqlite3_column_text(statement, indices.idx_lastName).flatMap(String.init(cString:))) : Self.schema.lastName.defaultValue,\n      firstName: (indices.idx_firstName >= 0) && (indices.idx_firstName < argc) ? (sqlite3_column_text(statement, indices.idx_firstName).flatMap(String.init(cString:))) : Self.schema.firstName.defaultValue,\n      title: (indices.idx_title >= 0) && (indices.idx_title < argc) ? (sqlite3_column_text(statement, indices.idx_title).flatMap(String.init(cString:))) : Self.schema.title.defaultValue,\n      titleOfCourtesy: (indices.idx_titleOfCourtesy >= 0) && (indices.idx_titleOfCourtesy < argc) ? (sqlite3_column_text(statement, indices.idx_titleOfCourtesy).flatMap(String.init(cString:))) : Self.schema.titleOfCourtesy.defaultValue,\n      birthDate: (indices.idx_birthDate >= 0) && (indices.idx_birthDate < argc) ? (sqlite3_column_text(statement, indices.idx_birthDate).flatMap(String.init(cString:))) : Self.schema.birthDate.defaultValue,\n      hireDate: (indices.idx_hireDate >= 0) && (indices.idx_hireDate < argc) ? (sqlite3_column_text(statement, indices.idx_hireDate).flatMap(String.init(cString:))) : Self.schema.hireDate.defaultValue,\n      address: (indices.idx_address >= 0) && (indices.idx_address < argc) ? (sqlite3_column_text(statement, indices.idx_address).flatMap(String.init(cString:))) : Self.schema.address.defaultValue,\n      city: (indices.idx_city >= 0) && (indices.idx_city < argc) ? (sqlite3_column_text(statement, indices.idx_city).flatMap(String.init(cString:))) : Self.schema.city.defaultValue,\n      region: (indices.idx_region >= 0) && (indices.idx_region < argc) ? (sqlite3_column_text(statement, indices.idx_region).flatMap(String.init(cString:))) : Self.schema.region.defaultValue,\n      postalCode: (indices.idx_postalCode >= 0) && (indices.idx_postalCode < argc) ? (sqlite3_column_text(statement, indices.idx_postalCode).flatMap(String.init(cString:))) : Self.schema.postalCode.defaultValue,\n      country: (indices.idx_country >= 0) && (indices.idx_country < argc) ? (sqlite3_column_text(statement, indices.idx_country).flatMap(String.init(cString:))) : Self.schema.country.defaultValue,\n      homePhone: (indices.idx_homePhone >= 0) && (indices.idx_homePhone < argc) ? (sqlite3_column_text(statement, indices.idx_homePhone).flatMap(String.init(cString:))) : Self.schema.homePhone.defaultValue,\n      extension: (indices.idx_extension >= 0) && (indices.idx_extension < argc) ? (sqlite3_column_text(statement, indices.idx_extension).flatMap(String.init(cString:))) : Self.schema.`extension`.defaultValue,\n      photo: (indices.idx_photo >= 0) && (indices.idx_photo < argc) ? (sqlite3_column_blob(statement, indices.idx_photo).flatMap({ [ UInt8 ](UnsafeRawBufferPointer(start: $0, count: Int(sqlite3_column_bytes(statement, indices.idx_photo)))) })) : Self.schema.photo.defaultValue,\n      notes: (indices.idx_notes >= 0) && (indices.idx_notes < argc) ? (sqlite3_column_text(statement, indices.idx_notes).flatMap(String.init(cString:))) : Self.schema.notes.defaultValue,\n      reportsTo: (indices.idx_reportsTo >= 0) && (indices.idx_reportsTo < argc) ? (sqlite3_column_type(statement, indices.idx_reportsTo) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_reportsTo)) : nil) : Self.schema.reportsTo.defaultValue,\n      photoPath: (indices.idx_photoPath >= 0) && (indices.idx_photoPath < argc) ? (sqlite3_column_text(statement, indices.idx_photoPath).flatMap(String.init(cString:))) : Self.schema.photoPath.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``Employee`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE \"Employees\" SET \"LastName\" = ?, \"FirstName\" = ?, \"Title\" = ?, \"TitleOfCourtesy\" = ?, \"BirthDate\" = ?, \"HireDate\" = ?, \"Address\" = ?, \"City\" = ?, \"Region\" = ?, \"PostalCode\" = ?, \"Country\" = ?, \"HomePhone\" = ?, \"Extension\" = ?, \"Photo\" = ?, \"Notes\" = ?, \"ReportsTo\" = ?, \"PhotoPath\" = ? WHERE \"EmployeeID\" = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = Employee(id: 1, lastName: \"Hello\", firstName: \"World\", title: \"Duck\")\n   * let ok = record.bind(to: statement, indices: ( 18, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_id >= 0 {\n      if let id = id {\n        sqlite3_bind_int64(statement, indices.idx_id, Int64(id))\n      }\n      else {\n        sqlite3_bind_null(statement, indices.idx_id)\n      }\n    }\n    return try NorthwindLighter.withOptCString(lastName) { ( s ) in\n      if indices.idx_lastName >= 0 {\n        sqlite3_bind_text(statement, indices.idx_lastName, s, -1, nil)\n      }\n      return try NorthwindLighter.withOptCString(firstName) { ( s ) in\n        if indices.idx_firstName >= 0 {\n          sqlite3_bind_text(statement, indices.idx_firstName, s, -1, nil)\n        }\n        return try NorthwindLighter.withOptCString(title) { ( s ) in\n          if indices.idx_title >= 0 {\n            sqlite3_bind_text(statement, indices.idx_title, s, -1, nil)\n          }\n          return try NorthwindLighter.withOptCString(titleOfCourtesy) { ( s ) in\n            if indices.idx_titleOfCourtesy >= 0 {\n              sqlite3_bind_text(statement, indices.idx_titleOfCourtesy, s, -1, nil)\n            }\n            return try NorthwindLighter.withOptCString(birthDate) { ( s ) in\n              if indices.idx_birthDate >= 0 {\n                sqlite3_bind_text(statement, indices.idx_birthDate, s, -1, nil)\n              }\n              return try NorthwindLighter.withOptCString(hireDate) { ( s ) in\n                if indices.idx_hireDate >= 0 {\n                  sqlite3_bind_text(statement, indices.idx_hireDate, s, -1, nil)\n                }\n                return try NorthwindLighter.withOptCString(address) { ( s ) in\n                  if indices.idx_address >= 0 {\n                    sqlite3_bind_text(statement, indices.idx_address, s, -1, nil)\n                  }\n                  return try NorthwindLighter.withOptCString(city) { ( s ) in\n                    if indices.idx_city >= 0 {\n                      sqlite3_bind_text(statement, indices.idx_city, s, -1, nil)\n                    }\n                    return try NorthwindLighter.withOptCString(region) { ( s ) in\n                      if indices.idx_region >= 0 {\n                        sqlite3_bind_text(statement, indices.idx_region, s, -1, nil)\n                      }\n                      return try NorthwindLighter.withOptCString(postalCode) { ( s ) in\n                        if indices.idx_postalCode >= 0 {\n                          sqlite3_bind_text(statement, indices.idx_postalCode, s, -1, nil)\n                        }\n                        return try NorthwindLighter.withOptCString(country) { ( s ) in\n                          if indices.idx_country >= 0 {\n                            sqlite3_bind_text(statement, indices.idx_country, s, -1, nil)\n                          }\n                          return try NorthwindLighter.withOptCString(homePhone) { ( s ) in\n                            if indices.idx_homePhone >= 0 {\n                              sqlite3_bind_text(statement, indices.idx_homePhone, s, -1, nil)\n                            }\n                            return try NorthwindLighter.withOptCString(`extension`) { ( s ) in\n                              if indices.idx_extension >= 0 {\n                                sqlite3_bind_text(statement, indices.idx_extension, s, -1, nil)\n                              }\n                              return try NorthwindLighter.withOptBlob(photo) { ( rbp ) in\n                                if indices.idx_photo >= 0 {\n                                  sqlite3_bind_blob(statement, indices.idx_photo, rbp.baseAddress, Int32(rbp.count), nil)\n                                }\n                                return try NorthwindLighter.withOptCString(notes) { ( s ) in\n                                  if indices.idx_notes >= 0 {\n                                    sqlite3_bind_text(statement, indices.idx_notes, s, -1, nil)\n                                  }\n                                  if indices.idx_reportsTo >= 0 {\n                                    if let reportsTo = reportsTo {\n                                      sqlite3_bind_int64(statement, indices.idx_reportsTo, Int64(reportsTo))\n                                    }\n                                    else {\n                                      sqlite3_bind_null(statement, indices.idx_reportsTo)\n                                    }\n                                  }\n                                  return try NorthwindLighter.withOptCString(photoPath) { ( s ) in\n                                    if indices.idx_photoPath >= 0 {\n                                      sqlite3_bind_text(statement, indices.idx_photoPath, s, -1, nil)\n                                    }\n                                    return try execute()\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.EmployeeTerritory {\n  \n  \/**\n   * Static type information for the ``EmployeeTerritory`` record (`EmployeeTerritories` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLTableSchema {\n    \n    public typealias PropertyIndices = ( idx_employeeID: Int32, idx_territoryID: Int32 )\n    public typealias RecordType = NorthwindLighter.EmployeeTerritory\n    \n    \/\/\/ The SQL table name associated with the ``EmployeeTerritory`` record.\n    public static let externalName = \"EmployeeTerritories\"\n    \n    \/\/\/ The number of columns the `EmployeeTerritories` table has.\n    public static let columnCount : Int32 = 2\n    \n    \/\/\/ SQL to `SELECT` all columns of the `EmployeeTerritories` table.\n    public static let select = #\"SELECT \"EmployeeID\", \"TerritoryID\" FROM \"EmployeeTerritories\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"EmployeeID\", \"TerritoryID\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let update = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let updateParameterIndices : PropertyIndices = ( -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insert = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertReturning = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertParameterIndices : PropertyIndices = ( -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let delete = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let deleteParameterIndices : PropertyIndices = ( -1, -1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, EmployeeTerritories_id FROM EmployeeTerritories`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `EmployeeTerritories_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"EmployeeID\") == 0 {\n          indices.idx_employeeID = i\n        }\n        else if strcmp(col!, \"TerritoryID\") == 0 {\n          indices.idx_territoryID = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``EmployeeTerritory\/employeeID`` (`EmployeeID` column).\n    public let employeeID = MappedForeignKey<NorthwindLighter.EmployeeTerritory, Int, MappedColumn<NorthwindLighter.Employee, Int?>>(\n      externalName: \"EmployeeID\",\n      defaultValue: -1,\n      keyPath: \\NorthwindLighter.EmployeeTerritory.employeeID,\n      destinationColumn: NorthwindLighter.Employee.schema.id\n    )\n    \n    \/\/\/ Type information for property ``EmployeeTerritory\/territoryID`` (`TerritoryID` column).\n    public let territoryID = MappedForeignKey<NorthwindLighter.EmployeeTerritory, String, MappedColumn<NorthwindLighter.Territory, String>>(\n      externalName: \"TerritoryID\",\n      defaultValue: \"\",\n      keyPath: \\NorthwindLighter.EmployeeTerritory.territoryID,\n      destinationColumn: NorthwindLighter.Territory.schema.id\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ employeeID, territoryID ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``EmployeeTerritory`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM EmployeeTerritories\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = EmployeeTerritory(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      employeeID: (indices.idx_employeeID >= 0) && (indices.idx_employeeID < argc) && (sqlite3_column_type(statement, indices.idx_employeeID) != SQLITE_NULL) ? Int(sqlite3_column_int64(statement, indices.idx_employeeID)) : Self.schema.employeeID.defaultValue,\n      territoryID: ((indices.idx_territoryID >= 0) && (indices.idx_territoryID < argc) ? (sqlite3_column_text(statement, indices.idx_territoryID).flatMap(String.init(cString:))) : nil) ?? Self.schema.territoryID.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``EmployeeTerritory`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE EmployeeTerritories SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = EmployeeTerritory(employeeID: 1, territoryID: \"Hello\")\n   * let ok = record.bind(to: statement, indices: ( 1, 2 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_employeeID >= 0 {\n      sqlite3_bind_int64(statement, indices.idx_employeeID, Int64(employeeID))\n    }\n    return try territoryID.withCString() { ( s ) in\n      if indices.idx_territoryID >= 0 {\n        sqlite3_bind_text(statement, indices.idx_territoryID, s, -1, nil)\n      }\n      return try execute()\n    }\n  }\n}\n\npublic extension NorthwindLighter.OrderDetail {\n  \n  \/**\n   * Static type information for the ``OrderDetail`` record (`Order Details` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLTableSchema {\n    \n    public typealias PropertyIndices = ( idx_orderID: Int32, idx_productID: Int32, idx_unitPrice: Int32, idx_quantity: Int32, idx_discount: Int32 )\n    public typealias RecordType = NorthwindLighter.OrderDetail\n    \n    \/\/\/ The SQL table name associated with the ``OrderDetail`` record.\n    public static let externalName = \"Order Details\"\n    \n    \/\/\/ The number of columns the `Order Details` table has.\n    public static let columnCount : Int32 = 5\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Order Details` table.\n    public static let select = #\"SELECT \"OrderID\", \"ProductID\", \"UnitPrice\", \"Quantity\", \"Discount\" FROM \"Order Details\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"OrderID\", \"ProductID\", \"UnitPrice\", \"Quantity\", \"Discount\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3, 4 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let update = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let updateParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insert = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertReturning = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let delete = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let deleteParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Order Details_id FROM Order Details`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Order Details_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"OrderID\") == 0 {\n          indices.idx_orderID = i\n        }\n        else if strcmp(col!, \"ProductID\") == 0 {\n          indices.idx_productID = i\n        }\n        else if strcmp(col!, \"UnitPrice\") == 0 {\n          indices.idx_unitPrice = i\n        }\n        else if strcmp(col!, \"Quantity\") == 0 {\n          indices.idx_quantity = i\n        }\n        else if strcmp(col!, \"Discount\") == 0 {\n          indices.idx_discount = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``OrderDetail\/orderID`` (`OrderID` column).\n    public let orderID = MappedForeignKey<NorthwindLighter.OrderDetail, Int, MappedColumn<NorthwindLighter.Order, Int>>(\n      externalName: \"OrderID\",\n      defaultValue: -1,\n      keyPath: \\NorthwindLighter.OrderDetail.orderID,\n      destinationColumn: NorthwindLighter.Order.schema.id\n    )\n    \n    \/\/\/ Type information for property ``OrderDetail\/productID`` (`ProductID` column).\n    public let productID = MappedColumn<NorthwindLighter.OrderDetail, Int>(\n      externalName: \"ProductID\",\n      defaultValue: -1,\n      keyPath: \\NorthwindLighter.OrderDetail.productID\n    )\n    \n    \/\/\/ Type information for property ``OrderDetail\/unitPrice`` (`UnitPrice` column).\n    public let unitPrice = MappedColumn<NorthwindLighter.OrderDetail, String>(\n      externalName: \"UnitPrice\",\n      defaultValue: \"0\",\n      keyPath: \\NorthwindLighter.OrderDetail.unitPrice\n    )\n    \n    \/\/\/ Type information for property ``OrderDetail\/quantity`` (`Quantity` column).\n    public let quantity = MappedColumn<NorthwindLighter.OrderDetail, Int>(\n      externalName: \"Quantity\",\n      defaultValue: 1,\n      keyPath: \\NorthwindLighter.OrderDetail.quantity\n    )\n    \n    \/\/\/ Type information for property ``OrderDetail\/discount`` (`Discount` column).\n    public let discount = MappedColumn<NorthwindLighter.OrderDetail, Double>(\n      externalName: \"Discount\",\n      defaultValue: 0.0,\n      keyPath: \\NorthwindLighter.OrderDetail.discount\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ orderID, productID, unitPrice, quantity, discount ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``OrderDetail`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Order Details\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = OrderDetail(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      orderID: (indices.idx_orderID >= 0) && (indices.idx_orderID < argc) && (sqlite3_column_type(statement, indices.idx_orderID) != SQLITE_NULL) ? Int(sqlite3_column_int64(statement, indices.idx_orderID)) : Self.schema.orderID.defaultValue,\n      productID: (indices.idx_productID >= 0) && (indices.idx_productID < argc) && (sqlite3_column_type(statement, indices.idx_productID) != SQLITE_NULL) ? Int(sqlite3_column_int64(statement, indices.idx_productID)) : Self.schema.productID.defaultValue,\n      unitPrice: ((indices.idx_unitPrice >= 0) && (indices.idx_unitPrice < argc) ? (sqlite3_column_text(statement, indices.idx_unitPrice).flatMap(String.init(cString:))) : nil) ?? Self.schema.unitPrice.defaultValue,\n      quantity: (indices.idx_quantity >= 0) && (indices.idx_quantity < argc) && (sqlite3_column_type(statement, indices.idx_quantity) != SQLITE_NULL) ? Int(sqlite3_column_int64(statement, indices.idx_quantity)) : Self.schema.quantity.defaultValue,\n      discount: (indices.idx_discount >= 0) && (indices.idx_discount < argc) && (sqlite3_column_type(statement, indices.idx_discount) != SQLITE_NULL) ? sqlite3_column_double(statement, indices.idx_discount) : Self.schema.discount.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``OrderDetail`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE \"Order Details\" SET \"UnitPrice\" = ?, \"Quantity\" = ?, \"Discount\" = ? WHERE \"OrderID\" = ? AND \"ProductID\" = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = OrderDetail(orderID: 1, productID: 2, unitPrice: \"Hello\", quantity: 3, discount: 4)\n   * let ok = record.bind(to: statement, indices: ( 4, 5, 1, 2, 3 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_orderID >= 0 {\n      sqlite3_bind_int64(statement, indices.idx_orderID, Int64(orderID))\n    }\n    if indices.idx_productID >= 0 {\n      sqlite3_bind_int64(statement, indices.idx_productID, Int64(productID))\n    }\n    return try unitPrice.withCString() { ( s ) in\n      if indices.idx_unitPrice >= 0 {\n        sqlite3_bind_text(statement, indices.idx_unitPrice, s, -1, nil)\n      }\n      if indices.idx_quantity >= 0 {\n        sqlite3_bind_int64(statement, indices.idx_quantity, Int64(quantity))\n      }\n      if indices.idx_discount >= 0 {\n        sqlite3_bind_double(statement, indices.idx_discount, discount)\n      }\n      return try execute()\n    }\n  }\n}\n\npublic extension NorthwindLighter.Order {\n  \n  \/**\n   * Static type information for the ``Order`` record (`Orders` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLKeyedTableSchema {\n    \n    public typealias PropertyIndices = ( idx_id: Int32, idx_customerID: Int32, idx_employeeID: Int32, idx_orderDate: Int32, idx_requiredDate: Int32, idx_shippedDate: Int32, idx_shipVia: Int32, idx_freight: Int32, idx_shipName: Int32, idx_shipAddress: Int32, idx_shipCity: Int32, idx_shipRegion: Int32, idx_shipPostalCode: Int32, idx_shipCountry: Int32 )\n    public typealias RecordType = NorthwindLighter.Order\n    \n    \/\/\/ The SQL table name associated with the ``Order`` record.\n    public static let externalName = \"Orders\"\n    \n    \/\/\/ The number of columns the `Orders` table has.\n    public static let columnCount : Int32 = 14\n    \n    \/\/\/ Information on the records primary key (``Order\/id``).\n    public static let primaryKeyColumn = MappedColumn<NorthwindLighter.Order, Int>(\n      externalName: \"OrderID\",\n      defaultValue: -1,\n      keyPath: \\NorthwindLighter.Order.id\n    )\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Orders` table.\n    public static let select = #\"SELECT \"OrderID\", \"CustomerID\", \"EmployeeID\", \"OrderDate\", \"RequiredDate\", \"ShippedDate\", \"ShipVia\", \"Freight\", \"ShipName\", \"ShipAddress\", \"ShipCity\", \"ShipRegion\", \"ShipPostalCode\", \"ShipCountry\" FROM \"Orders\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"OrderID\", \"CustomerID\", \"EmployeeID\", \"OrderDate\", \"RequiredDate\", \"ShippedDate\", \"ShipVia\", \"Freight\", \"ShipName\", \"ShipAddress\", \"ShipCity\", \"ShipRegion\", \"ShipPostalCode\", \"ShipCountry\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let update = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let updateParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insert = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertReturning = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let delete = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let deleteParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Orders_id FROM Orders`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Orders_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"OrderID\") == 0 {\n          indices.idx_id = i\n        }\n        else if strcmp(col!, \"CustomerID\") == 0 {\n          indices.idx_customerID = i\n        }\n        else if strcmp(col!, \"EmployeeID\") == 0 {\n          indices.idx_employeeID = i\n        }\n        else if strcmp(col!, \"OrderDate\") == 0 {\n          indices.idx_orderDate = i\n        }\n        else if strcmp(col!, \"RequiredDate\") == 0 {\n          indices.idx_requiredDate = i\n        }\n        else if strcmp(col!, \"ShippedDate\") == 0 {\n          indices.idx_shippedDate = i\n        }\n        else if strcmp(col!, \"ShipVia\") == 0 {\n          indices.idx_shipVia = i\n        }\n        else if strcmp(col!, \"Freight\") == 0 {\n          indices.idx_freight = i\n        }\n        else if strcmp(col!, \"ShipName\") == 0 {\n          indices.idx_shipName = i\n        }\n        else if strcmp(col!, \"ShipAddress\") == 0 {\n          indices.idx_shipAddress = i\n        }\n        else if strcmp(col!, \"ShipCity\") == 0 {\n          indices.idx_shipCity = i\n        }\n        else if strcmp(col!, \"ShipRegion\") == 0 {\n          indices.idx_shipRegion = i\n        }\n        else if strcmp(col!, \"ShipPostalCode\") == 0 {\n          indices.idx_shipPostalCode = i\n        }\n        else if strcmp(col!, \"ShipCountry\") == 0 {\n          indices.idx_shipCountry = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``Order\/id`` (`OrderID` column).\n    public let id = MappedColumn<NorthwindLighter.Order, Int>(\n      externalName: \"OrderID\",\n      defaultValue: -1,\n      keyPath: \\NorthwindLighter.Order.id\n    )\n    \n    \/\/\/ Type information for property ``Order\/customerID`` (`CustomerID` column).\n    public let customerID = MappedForeignKey<NorthwindLighter.Order, String?, MappedColumn<NorthwindLighter.Customer, String?>>(\n      externalName: \"CustomerID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Order.customerID,\n      destinationColumn: NorthwindLighter.Customer.schema.id\n    )\n    \n    \/\/\/ Type information for property ``Order\/employeeID`` (`EmployeeID` column).\n    public let employeeID = MappedForeignKey<NorthwindLighter.Order, Int?, MappedColumn<NorthwindLighter.Employee, Int?>>(\n      externalName: \"EmployeeID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Order.employeeID,\n      destinationColumn: NorthwindLighter.Employee.schema.id\n    )\n    \n    \/\/\/ Type information for property ``Order\/orderDate`` (`OrderDate` column).\n    public let orderDate = MappedColumn<NorthwindLighter.Order, String?>(\n      externalName: \"OrderDate\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Order.orderDate\n    )\n    \n    \/\/\/ Type information for property ``Order\/requiredDate`` (`RequiredDate` column).\n    public let requiredDate = MappedColumn<NorthwindLighter.Order, String?>(\n      externalName: \"RequiredDate\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Order.requiredDate\n    )\n    \n    \/\/\/ Type information for property ``Order\/shippedDate`` (`ShippedDate` column).\n    public let shippedDate = MappedColumn<NorthwindLighter.Order, String?>(\n      externalName: \"ShippedDate\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Order.shippedDate\n    )\n    \n    \/\/\/ Type information for property ``Order\/shipVia`` (`ShipVia` column).\n    public let shipVia = MappedForeignKey<NorthwindLighter.Order, Int?, MappedColumn<NorthwindLighter.Shipper, Int>>(\n      externalName: \"ShipVia\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Order.shipVia,\n      destinationColumn: NorthwindLighter.Shipper.schema.id\n    )\n    \n    \/\/\/ Type information for property ``Order\/freight`` (`Freight` column).\n    public let freight = MappedColumn<NorthwindLighter.Order, String?>(\n      externalName: \"Freight\",\n      defaultValue: \"0\",\n      keyPath: \\NorthwindLighter.Order.freight\n    )\n    \n    \/\/\/ Type information for property ``Order\/shipName`` (`ShipName` column).\n    public let shipName = MappedColumn<NorthwindLighter.Order, String?>(\n      externalName: \"ShipName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Order.shipName\n    )\n    \n    \/\/\/ Type information for property ``Order\/shipAddress`` (`ShipAddress` column).\n    public let shipAddress = MappedColumn<NorthwindLighter.Order, String?>(\n      externalName: \"ShipAddress\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Order.shipAddress\n    )\n    \n    \/\/\/ Type information for property ``Order\/shipCity`` (`ShipCity` column).\n    public let shipCity = MappedColumn<NorthwindLighter.Order, String?>(\n      externalName: \"ShipCity\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Order.shipCity\n    )\n    \n    \/\/\/ Type information for property ``Order\/shipRegion`` (`ShipRegion` column).\n    public let shipRegion = MappedColumn<NorthwindLighter.Order, String?>(\n      externalName: \"ShipRegion\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Order.shipRegion\n    )\n    \n    \/\/\/ Type information for property ``Order\/shipPostalCode`` (`ShipPostalCode` column).\n    public let shipPostalCode = MappedColumn<NorthwindLighter.Order, String?>(\n      externalName: \"ShipPostalCode\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Order.shipPostalCode\n    )\n    \n    \/\/\/ Type information for property ``Order\/shipCountry`` (`ShipCountry` column).\n    public let shipCountry = MappedColumn<NorthwindLighter.Order, String?>(\n      externalName: \"ShipCountry\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Order.shipCountry\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ id, customerID, employeeID, orderDate, requiredDate, shippedDate, shipVia, freight, shipName, shipAddress, shipCity, shipRegion, shipPostalCode, shipCountry ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``Order`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Orders\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = Order(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      id: (indices.idx_id >= 0) && (indices.idx_id < argc) && (sqlite3_column_type(statement, indices.idx_id) != SQLITE_NULL) ? Int(sqlite3_column_int64(statement, indices.idx_id)) : Self.schema.id.defaultValue,\n      customerID: (indices.idx_customerID >= 0) && (indices.idx_customerID < argc) ? (sqlite3_column_text(statement, indices.idx_customerID).flatMap(String.init(cString:))) : Self.schema.customerID.defaultValue,\n      employeeID: (indices.idx_employeeID >= 0) && (indices.idx_employeeID < argc) ? (sqlite3_column_type(statement, indices.idx_employeeID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_employeeID)) : nil) : Self.schema.employeeID.defaultValue,\n      orderDate: (indices.idx_orderDate >= 0) && (indices.idx_orderDate < argc) ? (sqlite3_column_text(statement, indices.idx_orderDate).flatMap(String.init(cString:))) : Self.schema.orderDate.defaultValue,\n      requiredDate: (indices.idx_requiredDate >= 0) && (indices.idx_requiredDate < argc) ? (sqlite3_column_text(statement, indices.idx_requiredDate).flatMap(String.init(cString:))) : Self.schema.requiredDate.defaultValue,\n      shippedDate: (indices.idx_shippedDate >= 0) && (indices.idx_shippedDate < argc) ? (sqlite3_column_text(statement, indices.idx_shippedDate).flatMap(String.init(cString:))) : Self.schema.shippedDate.defaultValue,\n      shipVia: (indices.idx_shipVia >= 0) && (indices.idx_shipVia < argc) ? (sqlite3_column_type(statement, indices.idx_shipVia) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_shipVia)) : nil) : Self.schema.shipVia.defaultValue,\n      freight: (indices.idx_freight >= 0) && (indices.idx_freight < argc) ? (sqlite3_column_text(statement, indices.idx_freight).flatMap(String.init(cString:))) : Self.schema.freight.defaultValue,\n      shipName: (indices.idx_shipName >= 0) && (indices.idx_shipName < argc) ? (sqlite3_column_text(statement, indices.idx_shipName).flatMap(String.init(cString:))) : Self.schema.shipName.defaultValue,\n      shipAddress: (indices.idx_shipAddress >= 0) && (indices.idx_shipAddress < argc) ? (sqlite3_column_text(statement, indices.idx_shipAddress).flatMap(String.init(cString:))) : Self.schema.shipAddress.defaultValue,\n      shipCity: (indices.idx_shipCity >= 0) && (indices.idx_shipCity < argc) ? (sqlite3_column_text(statement, indices.idx_shipCity).flatMap(String.init(cString:))) : Self.schema.shipCity.defaultValue,\n      shipRegion: (indices.idx_shipRegion >= 0) && (indices.idx_shipRegion < argc) ? (sqlite3_column_text(statement, indices.idx_shipRegion).flatMap(String.init(cString:))) : Self.schema.shipRegion.defaultValue,\n      shipPostalCode: (indices.idx_shipPostalCode >= 0) && (indices.idx_shipPostalCode < argc) ? (sqlite3_column_text(statement, indices.idx_shipPostalCode).flatMap(String.init(cString:))) : Self.schema.shipPostalCode.defaultValue,\n      shipCountry: (indices.idx_shipCountry >= 0) && (indices.idx_shipCountry < argc) ? (sqlite3_column_text(statement, indices.idx_shipCountry).flatMap(String.init(cString:))) : Self.schema.shipCountry.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``Order`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE \"Orders\" SET \"CustomerID\" = ?, \"EmployeeID\" = ?, \"OrderDate\" = ?, \"RequiredDate\" = ?, \"ShippedDate\" = ?, \"ShipVia\" = ?, \"Freight\" = ?, \"ShipName\" = ?, \"ShipAddress\" = ?, \"ShipCity\" = ?, \"ShipRegion\" = ?, \"ShipPostalCode\" = ?, \"ShipCountry\" = ? WHERE \"OrderID\" = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = Order(id: 1, customerID: \"Hello\", employeeID: 2, orderDate: nil, requiredDate: nil)\n   * let ok = record.bind(to: statement, indices: ( 14, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_id >= 0 {\n      sqlite3_bind_int64(statement, indices.idx_id, Int64(id))\n    }\n    return try NorthwindLighter.withOptCString(customerID) { ( s ) in\n      if indices.idx_customerID >= 0 {\n        sqlite3_bind_text(statement, indices.idx_customerID, s, -1, nil)\n      }\n      if indices.idx_employeeID >= 0 {\n        if let employeeID = employeeID {\n          sqlite3_bind_int64(statement, indices.idx_employeeID, Int64(employeeID))\n        }\n        else {\n          sqlite3_bind_null(statement, indices.idx_employeeID)\n        }\n      }\n      return try NorthwindLighter.withOptCString(orderDate) { ( s ) in\n        if indices.idx_orderDate >= 0 {\n          sqlite3_bind_text(statement, indices.idx_orderDate, s, -1, nil)\n        }\n        return try NorthwindLighter.withOptCString(requiredDate) { ( s ) in\n          if indices.idx_requiredDate >= 0 {\n            sqlite3_bind_text(statement, indices.idx_requiredDate, s, -1, nil)\n          }\n          return try NorthwindLighter.withOptCString(shippedDate) { ( s ) in\n            if indices.idx_shippedDate >= 0 {\n              sqlite3_bind_text(statement, indices.idx_shippedDate, s, -1, nil)\n            }\n            if indices.idx_shipVia >= 0 {\n              if let shipVia = shipVia {\n                sqlite3_bind_int64(statement, indices.idx_shipVia, Int64(shipVia))\n              }\n              else {\n                sqlite3_bind_null(statement, indices.idx_shipVia)\n              }\n            }\n            return try NorthwindLighter.withOptCString(freight) { ( s ) in\n              if indices.idx_freight >= 0 {\n                sqlite3_bind_text(statement, indices.idx_freight, s, -1, nil)\n              }\n              return try NorthwindLighter.withOptCString(shipName) { ( s ) in\n                if indices.idx_shipName >= 0 {\n                  sqlite3_bind_text(statement, indices.idx_shipName, s, -1, nil)\n                }\n                return try NorthwindLighter.withOptCString(shipAddress) { ( s ) in\n                  if indices.idx_shipAddress >= 0 {\n                    sqlite3_bind_text(statement, indices.idx_shipAddress, s, -1, nil)\n                  }\n                  return try NorthwindLighter.withOptCString(shipCity) { ( s ) in\n                    if indices.idx_shipCity >= 0 {\n                      sqlite3_bind_text(statement, indices.idx_shipCity, s, -1, nil)\n                    }\n                    return try NorthwindLighter.withOptCString(shipRegion) { ( s ) in\n                      if indices.idx_shipRegion >= 0 {\n                        sqlite3_bind_text(statement, indices.idx_shipRegion, s, -1, nil)\n                      }\n                      return try NorthwindLighter.withOptCString(shipPostalCode) { ( s ) in\n                        if indices.idx_shipPostalCode >= 0 {\n                          sqlite3_bind_text(statement, indices.idx_shipPostalCode, s, -1, nil)\n                        }\n                        return try NorthwindLighter.withOptCString(shipCountry) { ( s ) in\n                          if indices.idx_shipCountry >= 0 {\n                            sqlite3_bind_text(statement, indices.idx_shipCountry, s, -1, nil)\n                          }\n                          return try execute()\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.Product {\n  \n  \/**\n   * Static type information for the ``Product`` record (`Products` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLKeyedTableSchema {\n    \n    public typealias PropertyIndices = ( idx_id: Int32, idx_productName: Int32, idx_supplierID: Int32, idx_categoryID: Int32, idx_quantityPerUnit: Int32, idx_unitPrice: Int32, idx_unitsInStock: Int32, idx_unitsOnOrder: Int32, idx_reorderLevel: Int32, idx_discontinued: Int32 )\n    public typealias RecordType = NorthwindLighter.Product\n    \n    \/\/\/ The SQL table name associated with the ``Product`` record.\n    public static let externalName = \"Products\"\n    \n    \/\/\/ The number of columns the `Products` table has.\n    public static let columnCount : Int32 = 10\n    \n    \/\/\/ Information on the records primary key (``Product\/id``).\n    public static let primaryKeyColumn = MappedForeignKey<NorthwindLighter.Product, Int, MappedColumn<NorthwindLighter.Category, Int?>>(\n      externalName: \"ProductID\",\n      defaultValue: -1,\n      keyPath: \\NorthwindLighter.Product.id,\n      destinationColumn: NorthwindLighter.Category.schema.id\n    )\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Products` table.\n    public static let select = #\"SELECT \"ProductID\", \"ProductName\", \"SupplierID\", \"CategoryID\", \"QuantityPerUnit\", \"UnitPrice\", \"UnitsInStock\", \"UnitsOnOrder\", \"ReorderLevel\", \"Discontinued\" FROM \"Products\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"ProductID\", \"ProductName\", \"SupplierID\", \"CategoryID\", \"QuantityPerUnit\", \"UnitPrice\", \"UnitsInStock\", \"UnitsOnOrder\", \"ReorderLevel\", \"Discontinued\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let update = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let updateParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insert = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertReturning = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let delete = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let deleteParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Products_id FROM Products`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Products_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"ProductID\") == 0 {\n          indices.idx_id = i\n        }\n        else if strcmp(col!, \"ProductName\") == 0 {\n          indices.idx_productName = i\n        }\n        else if strcmp(col!, \"SupplierID\") == 0 {\n          indices.idx_supplierID = i\n        }\n        else if strcmp(col!, \"CategoryID\") == 0 {\n          indices.idx_categoryID = i\n        }\n        else if strcmp(col!, \"QuantityPerUnit\") == 0 {\n          indices.idx_quantityPerUnit = i\n        }\n        else if strcmp(col!, \"UnitPrice\") == 0 {\n          indices.idx_unitPrice = i\n        }\n        else if strcmp(col!, \"UnitsInStock\") == 0 {\n          indices.idx_unitsInStock = i\n        }\n        else if strcmp(col!, \"UnitsOnOrder\") == 0 {\n          indices.idx_unitsOnOrder = i\n        }\n        else if strcmp(col!, \"ReorderLevel\") == 0 {\n          indices.idx_reorderLevel = i\n        }\n        else if strcmp(col!, \"Discontinued\") == 0 {\n          indices.idx_discontinued = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``Product\/id`` (`ProductID` column).\n    public let id = MappedForeignKey<NorthwindLighter.Product, Int, MappedColumn<NorthwindLighter.Category, Int?>>(\n      externalName: \"ProductID\",\n      defaultValue: -1,\n      keyPath: \\NorthwindLighter.Product.id,\n      destinationColumn: NorthwindLighter.Category.schema.id\n    )\n    \n    \/\/\/ Type information for property ``Product\/productName`` (`ProductName` column).\n    public let productName = MappedColumn<NorthwindLighter.Product, String>(\n      externalName: \"ProductName\",\n      defaultValue: \"\",\n      keyPath: \\NorthwindLighter.Product.productName\n    )\n    \n    \/\/\/ Type information for property ``Product\/supplierID`` (`SupplierID` column).\n    public let supplierID = MappedForeignKey<NorthwindLighter.Product, Int?, MappedColumn<NorthwindLighter.Supplier, Int>>(\n      externalName: \"SupplierID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Product.supplierID,\n      destinationColumn: NorthwindLighter.Supplier.schema.id\n    )\n    \n    \/\/\/ Type information for property ``Product\/categoryID`` (`CategoryID` column).\n    public let categoryID = MappedColumn<NorthwindLighter.Product, Int?>(\n      externalName: \"CategoryID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Product.categoryID\n    )\n    \n    \/\/\/ Type information for property ``Product\/quantityPerUnit`` (`QuantityPerUnit` column).\n    public let quantityPerUnit = MappedColumn<NorthwindLighter.Product, String?>(\n      externalName: \"QuantityPerUnit\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Product.quantityPerUnit\n    )\n    \n    \/\/\/ Type information for property ``Product\/unitPrice`` (`UnitPrice` column).\n    public let unitPrice = MappedColumn<NorthwindLighter.Product, String?>(\n      externalName: \"UnitPrice\",\n      defaultValue: \"0\",\n      keyPath: \\NorthwindLighter.Product.unitPrice\n    )\n    \n    \/\/\/ Type information for property ``Product\/unitsInStock`` (`UnitsInStock` column).\n    public let unitsInStock = MappedColumn<NorthwindLighter.Product, Int?>(\n      externalName: \"UnitsInStock\",\n      defaultValue: 0,\n      keyPath: \\NorthwindLighter.Product.unitsInStock\n    )\n    \n    \/\/\/ Type information for property ``Product\/unitsOnOrder`` (`UnitsOnOrder` column).\n    public let unitsOnOrder = MappedColumn<NorthwindLighter.Product, Int?>(\n      externalName: \"UnitsOnOrder\",\n      defaultValue: 0,\n      keyPath: \\NorthwindLighter.Product.unitsOnOrder\n    )\n    \n    \/\/\/ Type information for property ``Product\/reorderLevel`` (`ReorderLevel` column).\n    public let reorderLevel = MappedColumn<NorthwindLighter.Product, Int?>(\n      externalName: \"ReorderLevel\",\n      defaultValue: 0,\n      keyPath: \\NorthwindLighter.Product.reorderLevel\n    )\n    \n    \/\/\/ Type information for property ``Product\/discontinued`` (`Discontinued` column).\n    public let discontinued = MappedColumn<NorthwindLighter.Product, String>(\n      externalName: \"Discontinued\",\n      defaultValue: \"'0'\",\n      keyPath: \\NorthwindLighter.Product.discontinued\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ id, productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``Product`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Products\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = Product(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      id: (indices.idx_id >= 0) && (indices.idx_id < argc) && (sqlite3_column_type(statement, indices.idx_id) != SQLITE_NULL) ? Int(sqlite3_column_int64(statement, indices.idx_id)) : Self.schema.id.defaultValue,\n      productName: ((indices.idx_productName >= 0) && (indices.idx_productName < argc) ? (sqlite3_column_text(statement, indices.idx_productName).flatMap(String.init(cString:))) : nil) ?? Self.schema.productName.defaultValue,\n      supplierID: (indices.idx_supplierID >= 0) && (indices.idx_supplierID < argc) ? (sqlite3_column_type(statement, indices.idx_supplierID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_supplierID)) : nil) : Self.schema.supplierID.defaultValue,\n      categoryID: (indices.idx_categoryID >= 0) && (indices.idx_categoryID < argc) ? (sqlite3_column_type(statement, indices.idx_categoryID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_categoryID)) : nil) : Self.schema.categoryID.defaultValue,\n      quantityPerUnit: (indices.idx_quantityPerUnit >= 0) && (indices.idx_quantityPerUnit < argc) ? (sqlite3_column_text(statement, indices.idx_quantityPerUnit).flatMap(String.init(cString:))) : Self.schema.quantityPerUnit.defaultValue,\n      unitPrice: (indices.idx_unitPrice >= 0) && (indices.idx_unitPrice < argc) ? (sqlite3_column_text(statement, indices.idx_unitPrice).flatMap(String.init(cString:))) : Self.schema.unitPrice.defaultValue,\n      unitsInStock: (indices.idx_unitsInStock >= 0) && (indices.idx_unitsInStock < argc) ? (sqlite3_column_type(statement, indices.idx_unitsInStock) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_unitsInStock)) : nil) : Self.schema.unitsInStock.defaultValue,\n      unitsOnOrder: (indices.idx_unitsOnOrder >= 0) && (indices.idx_unitsOnOrder < argc) ? (sqlite3_column_type(statement, indices.idx_unitsOnOrder) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_unitsOnOrder)) : nil) : Self.schema.unitsOnOrder.defaultValue,\n      reorderLevel: (indices.idx_reorderLevel >= 0) && (indices.idx_reorderLevel < argc) ? (sqlite3_column_type(statement, indices.idx_reorderLevel) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_reorderLevel)) : nil) : Self.schema.reorderLevel.defaultValue,\n      discontinued: ((indices.idx_discontinued >= 0) && (indices.idx_discontinued < argc) ? (sqlite3_column_text(statement, indices.idx_discontinued).flatMap(String.init(cString:))) : nil) ?? Self.schema.discontinued.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``Product`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE \"Products\" SET \"ProductName\" = ?, \"SupplierID\" = ?, \"CategoryID\" = ?, \"QuantityPerUnit\" = ?, \"UnitPrice\" = ?, \"UnitsInStock\" = ?, \"UnitsOnOrder\" = ?, \"ReorderLevel\" = ?, \"Discontinued\" = ? WHERE \"ProductID\" = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = Product(id: 1, productName: \"Hello\", supplierID: 2, categoryID: 3, quantityPerUnit: \"World\", unitPrice: \"Duck\", discontinued: \"Donald\")\n   * let ok = record.bind(to: statement, indices: ( 10, 1, 2, 3, 4, 5, 6, 7, 8, 9 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_id >= 0 {\n      sqlite3_bind_int64(statement, indices.idx_id, Int64(id))\n    }\n    return try productName.withCString() { ( s ) in\n      if indices.idx_productName >= 0 {\n        sqlite3_bind_text(statement, indices.idx_productName, s, -1, nil)\n      }\n      if indices.idx_supplierID >= 0 {\n        if let supplierID = supplierID {\n          sqlite3_bind_int64(statement, indices.idx_supplierID, Int64(supplierID))\n        }\n        else {\n          sqlite3_bind_null(statement, indices.idx_supplierID)\n        }\n      }\n      if indices.idx_categoryID >= 0 {\n        if let categoryID = categoryID {\n          sqlite3_bind_int64(statement, indices.idx_categoryID, Int64(categoryID))\n        }\n        else {\n          sqlite3_bind_null(statement, indices.idx_categoryID)\n        }\n      }\n      return try NorthwindLighter.withOptCString(quantityPerUnit) { ( s ) in\n        if indices.idx_quantityPerUnit >= 0 {\n          sqlite3_bind_text(statement, indices.idx_quantityPerUnit, s, -1, nil)\n        }\n        return try NorthwindLighter.withOptCString(unitPrice) { ( s ) in\n          if indices.idx_unitPrice >= 0 {\n            sqlite3_bind_text(statement, indices.idx_unitPrice, s, -1, nil)\n          }\n          if indices.idx_unitsInStock >= 0 {\n            if let unitsInStock = unitsInStock {\n              sqlite3_bind_int64(statement, indices.idx_unitsInStock, Int64(unitsInStock))\n            }\n            else {\n              sqlite3_bind_null(statement, indices.idx_unitsInStock)\n            }\n          }\n          if indices.idx_unitsOnOrder >= 0 {\n            if let unitsOnOrder = unitsOnOrder {\n              sqlite3_bind_int64(statement, indices.idx_unitsOnOrder, Int64(unitsOnOrder))\n            }\n            else {\n              sqlite3_bind_null(statement, indices.idx_unitsOnOrder)\n            }\n          }\n          if indices.idx_reorderLevel >= 0 {\n            if let reorderLevel = reorderLevel {\n              sqlite3_bind_int64(statement, indices.idx_reorderLevel, Int64(reorderLevel))\n            }\n            else {\n              sqlite3_bind_null(statement, indices.idx_reorderLevel)\n            }\n          }\n          return try discontinued.withCString() { ( s ) in\n            if indices.idx_discontinued >= 0 {\n              sqlite3_bind_text(statement, indices.idx_discontinued, s, -1, nil)\n            }\n            return try execute()\n          }\n        }\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.Region {\n  \n  \/**\n   * Static type information for the ``Region`` record (`Regions` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLKeyedTableSchema {\n    \n    public typealias PropertyIndices = ( idx_id: Int32, idx_regionDescription: Int32 )\n    public typealias RecordType = NorthwindLighter.Region\n    \n    \/\/\/ The SQL table name associated with the ``Region`` record.\n    public static let externalName = \"Regions\"\n    \n    \/\/\/ The number of columns the `Regions` table has.\n    public static let columnCount : Int32 = 2\n    \n    \/\/\/ Information on the records primary key (``Region\/id``).\n    public static let primaryKeyColumn = MappedColumn<NorthwindLighter.Region, Int>(\n      externalName: \"RegionID\",\n      defaultValue: -1,\n      keyPath: \\NorthwindLighter.Region.id\n    )\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Regions` table.\n    public static let select = #\"SELECT \"RegionID\", \"RegionDescription\" FROM \"Regions\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"RegionID\", \"RegionDescription\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let update = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let updateParameterIndices : PropertyIndices = ( -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insert = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertReturning = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertParameterIndices : PropertyIndices = ( -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let delete = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let deleteParameterIndices : PropertyIndices = ( -1, -1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Regions_id FROM Regions`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Regions_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"RegionID\") == 0 {\n          indices.idx_id = i\n        }\n        else if strcmp(col!, \"RegionDescription\") == 0 {\n          indices.idx_regionDescription = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``Region\/id`` (`RegionID` column).\n    public let id = MappedColumn<NorthwindLighter.Region, Int>(\n      externalName: \"RegionID\",\n      defaultValue: -1,\n      keyPath: \\NorthwindLighter.Region.id\n    )\n    \n    \/\/\/ Type information for property ``Region\/regionDescription`` (`RegionDescription` column).\n    public let regionDescription = MappedColumn<NorthwindLighter.Region, String>(\n      externalName: \"RegionDescription\",\n      defaultValue: \"\",\n      keyPath: \\NorthwindLighter.Region.regionDescription\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ id, regionDescription ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``Region`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Regions\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = Region(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      id: (indices.idx_id >= 0) && (indices.idx_id < argc) && (sqlite3_column_type(statement, indices.idx_id) != SQLITE_NULL) ? Int(sqlite3_column_int64(statement, indices.idx_id)) : Self.schema.id.defaultValue,\n      regionDescription: ((indices.idx_regionDescription >= 0) && (indices.idx_regionDescription < argc) ? (sqlite3_column_text(statement, indices.idx_regionDescription).flatMap(String.init(cString:))) : nil) ?? Self.schema.regionDescription.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``Region`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE \"Regions\" SET \"RegionDescription\" = ? WHERE \"RegionID\" = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = Region(id: 1, regionDescription: \"Hello\")\n   * let ok = record.bind(to: statement, indices: ( 2, 1 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_id >= 0 {\n      sqlite3_bind_int64(statement, indices.idx_id, Int64(id))\n    }\n    return try regionDescription.withCString() { ( s ) in\n      if indices.idx_regionDescription >= 0 {\n        sqlite3_bind_text(statement, indices.idx_regionDescription, s, -1, nil)\n      }\n      return try execute()\n    }\n  }\n}\n\npublic extension NorthwindLighter.Shipper {\n  \n  \/**\n   * Static type information for the ``Shipper`` record (`Shippers` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLKeyedTableSchema {\n    \n    public typealias PropertyIndices = ( idx_id: Int32, idx_companyName: Int32, idx_phone: Int32 )\n    public typealias RecordType = NorthwindLighter.Shipper\n    \n    \/\/\/ The SQL table name associated with the ``Shipper`` record.\n    public static let externalName = \"Shippers\"\n    \n    \/\/\/ The number of columns the `Shippers` table has.\n    public static let columnCount : Int32 = 3\n    \n    \/\/\/ Information on the records primary key (``Shipper\/id``).\n    public static let primaryKeyColumn = MappedColumn<NorthwindLighter.Shipper, Int>(\n      externalName: \"ShipperID\",\n      defaultValue: -1,\n      keyPath: \\NorthwindLighter.Shipper.id\n    )\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Shippers` table.\n    public static let select = #\"SELECT \"ShipperID\", \"CompanyName\", \"Phone\" FROM \"Shippers\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"ShipperID\", \"CompanyName\", \"Phone\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let update = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let updateParameterIndices : PropertyIndices = ( -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insert = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertReturning = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertParameterIndices : PropertyIndices = ( -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let delete = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let deleteParameterIndices : PropertyIndices = ( -1, -1, -1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Shippers_id FROM Shippers`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Shippers_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"ShipperID\") == 0 {\n          indices.idx_id = i\n        }\n        else if strcmp(col!, \"CompanyName\") == 0 {\n          indices.idx_companyName = i\n        }\n        else if strcmp(col!, \"Phone\") == 0 {\n          indices.idx_phone = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``Shipper\/id`` (`ShipperID` column).\n    public let id = MappedColumn<NorthwindLighter.Shipper, Int>(\n      externalName: \"ShipperID\",\n      defaultValue: -1,\n      keyPath: \\NorthwindLighter.Shipper.id\n    )\n    \n    \/\/\/ Type information for property ``Shipper\/companyName`` (`CompanyName` column).\n    public let companyName = MappedColumn<NorthwindLighter.Shipper, String>(\n      externalName: \"CompanyName\",\n      defaultValue: \"\",\n      keyPath: \\NorthwindLighter.Shipper.companyName\n    )\n    \n    \/\/\/ Type information for property ``Shipper\/phone`` (`Phone` column).\n    public let phone = MappedColumn<NorthwindLighter.Shipper, String?>(\n      externalName: \"Phone\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Shipper.phone\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ id, companyName, phone ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``Shipper`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Shippers\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = Shipper(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      id: (indices.idx_id >= 0) && (indices.idx_id < argc) && (sqlite3_column_type(statement, indices.idx_id) != SQLITE_NULL) ? Int(sqlite3_column_int64(statement, indices.idx_id)) : Self.schema.id.defaultValue,\n      companyName: ((indices.idx_companyName >= 0) && (indices.idx_companyName < argc) ? (sqlite3_column_text(statement, indices.idx_companyName).flatMap(String.init(cString:))) : nil) ?? Self.schema.companyName.defaultValue,\n      phone: (indices.idx_phone >= 0) && (indices.idx_phone < argc) ? (sqlite3_column_text(statement, indices.idx_phone).flatMap(String.init(cString:))) : Self.schema.phone.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``Shipper`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE \"Shippers\" SET \"CompanyName\" = ?, \"Phone\" = ? WHERE \"ShipperID\" = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = Shipper(id: 1, companyName: \"Hello\", phone: \"World\")\n   * let ok = record.bind(to: statement, indices: ( 3, 1, 2 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_id >= 0 {\n      sqlite3_bind_int64(statement, indices.idx_id, Int64(id))\n    }\n    return try companyName.withCString() { ( s ) in\n      if indices.idx_companyName >= 0 {\n        sqlite3_bind_text(statement, indices.idx_companyName, s, -1, nil)\n      }\n      return try NorthwindLighter.withOptCString(phone) { ( s ) in\n        if indices.idx_phone >= 0 {\n          sqlite3_bind_text(statement, indices.idx_phone, s, -1, nil)\n        }\n        return try execute()\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.Supplier {\n  \n  \/**\n   * Static type information for the ``Supplier`` record (`Suppliers` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLKeyedTableSchema {\n    \n    public typealias PropertyIndices = ( idx_id: Int32, idx_companyName: Int32, idx_contactName: Int32, idx_contactTitle: Int32, idx_address: Int32, idx_city: Int32, idx_region: Int32, idx_postalCode: Int32, idx_country: Int32, idx_phone: Int32, idx_fax: Int32, idx_homePage: Int32 )\n    public typealias RecordType = NorthwindLighter.Supplier\n    \n    \/\/\/ The SQL table name associated with the ``Supplier`` record.\n    public static let externalName = \"Suppliers\"\n    \n    \/\/\/ The number of columns the `Suppliers` table has.\n    public static let columnCount : Int32 = 12\n    \n    \/\/\/ Information on the records primary key (``Supplier\/id``).\n    public static let primaryKeyColumn = MappedColumn<NorthwindLighter.Supplier, Int>(\n      externalName: \"SupplierID\",\n      defaultValue: -1,\n      keyPath: \\NorthwindLighter.Supplier.id\n    )\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Suppliers` table.\n    public static let select = #\"SELECT \"SupplierID\", \"CompanyName\", \"ContactName\", \"ContactTitle\", \"Address\", \"City\", \"Region\", \"PostalCode\", \"Country\", \"Phone\", \"Fax\", \"HomePage\" FROM \"Suppliers\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"SupplierID\", \"CompanyName\", \"ContactName\", \"ContactTitle\", \"Address\", \"City\", \"Region\", \"PostalCode\", \"Country\", \"Phone\", \"Fax\", \"HomePage\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let update = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let updateParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insert = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertReturning = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let delete = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let deleteParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Suppliers_id FROM Suppliers`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Suppliers_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"SupplierID\") == 0 {\n          indices.idx_id = i\n        }\n        else if strcmp(col!, \"CompanyName\") == 0 {\n          indices.idx_companyName = i\n        }\n        else if strcmp(col!, \"ContactName\") == 0 {\n          indices.idx_contactName = i\n        }\n        else if strcmp(col!, \"ContactTitle\") == 0 {\n          indices.idx_contactTitle = i\n        }\n        else if strcmp(col!, \"Address\") == 0 {\n          indices.idx_address = i\n        }\n        else if strcmp(col!, \"City\") == 0 {\n          indices.idx_city = i\n        }\n        else if strcmp(col!, \"Region\") == 0 {\n          indices.idx_region = i\n        }\n        else if strcmp(col!, \"PostalCode\") == 0 {\n          indices.idx_postalCode = i\n        }\n        else if strcmp(col!, \"Country\") == 0 {\n          indices.idx_country = i\n        }\n        else if strcmp(col!, \"Phone\") == 0 {\n          indices.idx_phone = i\n        }\n        else if strcmp(col!, \"Fax\") == 0 {\n          indices.idx_fax = i\n        }\n        else if strcmp(col!, \"HomePage\") == 0 {\n          indices.idx_homePage = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``Supplier\/id`` (`SupplierID` column).\n    public let id = MappedColumn<NorthwindLighter.Supplier, Int>(\n      externalName: \"SupplierID\",\n      defaultValue: -1,\n      keyPath: \\NorthwindLighter.Supplier.id\n    )\n    \n    \/\/\/ Type information for property ``Supplier\/companyName`` (`CompanyName` column).\n    public let companyName = MappedColumn<NorthwindLighter.Supplier, String>(\n      externalName: \"CompanyName\",\n      defaultValue: \"\",\n      keyPath: \\NorthwindLighter.Supplier.companyName\n    )\n    \n    \/\/\/ Type information for property ``Supplier\/contactName`` (`ContactName` column).\n    public let contactName = MappedColumn<NorthwindLighter.Supplier, String?>(\n      externalName: \"ContactName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Supplier.contactName\n    )\n    \n    \/\/\/ Type information for property ``Supplier\/contactTitle`` (`ContactTitle` column).\n    public let contactTitle = MappedColumn<NorthwindLighter.Supplier, String?>(\n      externalName: \"ContactTitle\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Supplier.contactTitle\n    )\n    \n    \/\/\/ Type information for property ``Supplier\/address`` (`Address` column).\n    public let address = MappedColumn<NorthwindLighter.Supplier, String?>(\n      externalName: \"Address\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Supplier.address\n    )\n    \n    \/\/\/ Type information for property ``Supplier\/city`` (`City` column).\n    public let city = MappedColumn<NorthwindLighter.Supplier, String?>(\n      externalName: \"City\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Supplier.city\n    )\n    \n    \/\/\/ Type information for property ``Supplier\/region`` (`Region` column).\n    public let region = MappedColumn<NorthwindLighter.Supplier, String?>(\n      externalName: \"Region\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Supplier.region\n    )\n    \n    \/\/\/ Type information for property ``Supplier\/postalCode`` (`PostalCode` column).\n    public let postalCode = MappedColumn<NorthwindLighter.Supplier, String?>(\n      externalName: \"PostalCode\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Supplier.postalCode\n    )\n    \n    \/\/\/ Type information for property ``Supplier\/country`` (`Country` column).\n    public let country = MappedColumn<NorthwindLighter.Supplier, String?>(\n      externalName: \"Country\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Supplier.country\n    )\n    \n    \/\/\/ Type information for property ``Supplier\/phone`` (`Phone` column).\n    public let phone = MappedColumn<NorthwindLighter.Supplier, String?>(\n      externalName: \"Phone\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Supplier.phone\n    )\n    \n    \/\/\/ Type information for property ``Supplier\/fax`` (`Fax` column).\n    public let fax = MappedColumn<NorthwindLighter.Supplier, String?>(\n      externalName: \"Fax\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Supplier.fax\n    )\n    \n    \/\/\/ Type information for property ``Supplier\/homePage`` (`HomePage` column).\n    public let homePage = MappedColumn<NorthwindLighter.Supplier, String?>(\n      externalName: \"HomePage\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Supplier.homePage\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ id, companyName, contactName, contactTitle, address, city, region, postalCode, country, phone, fax, homePage ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``Supplier`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Suppliers\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = Supplier(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      id: (indices.idx_id >= 0) && (indices.idx_id < argc) && (sqlite3_column_type(statement, indices.idx_id) != SQLITE_NULL) ? Int(sqlite3_column_int64(statement, indices.idx_id)) : Self.schema.id.defaultValue,\n      companyName: ((indices.idx_companyName >= 0) && (indices.idx_companyName < argc) ? (sqlite3_column_text(statement, indices.idx_companyName).flatMap(String.init(cString:))) : nil) ?? Self.schema.companyName.defaultValue,\n      contactName: (indices.idx_contactName >= 0) && (indices.idx_contactName < argc) ? (sqlite3_column_text(statement, indices.idx_contactName).flatMap(String.init(cString:))) : Self.schema.contactName.defaultValue,\n      contactTitle: (indices.idx_contactTitle >= 0) && (indices.idx_contactTitle < argc) ? (sqlite3_column_text(statement, indices.idx_contactTitle).flatMap(String.init(cString:))) : Self.schema.contactTitle.defaultValue,\n      address: (indices.idx_address >= 0) && (indices.idx_address < argc) ? (sqlite3_column_text(statement, indices.idx_address).flatMap(String.init(cString:))) : Self.schema.address.defaultValue,\n      city: (indices.idx_city >= 0) && (indices.idx_city < argc) ? (sqlite3_column_text(statement, indices.idx_city).flatMap(String.init(cString:))) : Self.schema.city.defaultValue,\n      region: (indices.idx_region >= 0) && (indices.idx_region < argc) ? (sqlite3_column_text(statement, indices.idx_region).flatMap(String.init(cString:))) : Self.schema.region.defaultValue,\n      postalCode: (indices.idx_postalCode >= 0) && (indices.idx_postalCode < argc) ? (sqlite3_column_text(statement, indices.idx_postalCode).flatMap(String.init(cString:))) : Self.schema.postalCode.defaultValue,\n      country: (indices.idx_country >= 0) && (indices.idx_country < argc) ? (sqlite3_column_text(statement, indices.idx_country).flatMap(String.init(cString:))) : Self.schema.country.defaultValue,\n      phone: (indices.idx_phone >= 0) && (indices.idx_phone < argc) ? (sqlite3_column_text(statement, indices.idx_phone).flatMap(String.init(cString:))) : Self.schema.phone.defaultValue,\n      fax: (indices.idx_fax >= 0) && (indices.idx_fax < argc) ? (sqlite3_column_text(statement, indices.idx_fax).flatMap(String.init(cString:))) : Self.schema.fax.defaultValue,\n      homePage: (indices.idx_homePage >= 0) && (indices.idx_homePage < argc) ? (sqlite3_column_text(statement, indices.idx_homePage).flatMap(String.init(cString:))) : Self.schema.homePage.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``Supplier`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE \"Suppliers\" SET \"CompanyName\" = ?, \"ContactName\" = ?, \"ContactTitle\" = ?, \"Address\" = ?, \"City\" = ?, \"Region\" = ?, \"PostalCode\" = ?, \"Country\" = ?, \"Phone\" = ?, \"Fax\" = ?, \"HomePage\" = ? WHERE \"SupplierID\" = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = Supplier(id: 1, companyName: \"Hello\", contactName: \"World\", contactTitle: \"Duck\", address: \"Donald\", city: \"Mickey\")\n   * let ok = record.bind(to: statement, indices: ( 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_id >= 0 {\n      sqlite3_bind_int64(statement, indices.idx_id, Int64(id))\n    }\n    return try companyName.withCString() { ( s ) in\n      if indices.idx_companyName >= 0 {\n        sqlite3_bind_text(statement, indices.idx_companyName, s, -1, nil)\n      }\n      return try NorthwindLighter.withOptCString(contactName) { ( s ) in\n        if indices.idx_contactName >= 0 {\n          sqlite3_bind_text(statement, indices.idx_contactName, s, -1, nil)\n        }\n        return try NorthwindLighter.withOptCString(contactTitle) { ( s ) in\n          if indices.idx_contactTitle >= 0 {\n            sqlite3_bind_text(statement, indices.idx_contactTitle, s, -1, nil)\n          }\n          return try NorthwindLighter.withOptCString(address) { ( s ) in\n            if indices.idx_address >= 0 {\n              sqlite3_bind_text(statement, indices.idx_address, s, -1, nil)\n            }\n            return try NorthwindLighter.withOptCString(city) { ( s ) in\n              if indices.idx_city >= 0 {\n                sqlite3_bind_text(statement, indices.idx_city, s, -1, nil)\n              }\n              return try NorthwindLighter.withOptCString(region) { ( s ) in\n                if indices.idx_region >= 0 {\n                  sqlite3_bind_text(statement, indices.idx_region, s, -1, nil)\n                }\n                return try NorthwindLighter.withOptCString(postalCode) { ( s ) in\n                  if indices.idx_postalCode >= 0 {\n                    sqlite3_bind_text(statement, indices.idx_postalCode, s, -1, nil)\n                  }\n                  return try NorthwindLighter.withOptCString(country) { ( s ) in\n                    if indices.idx_country >= 0 {\n                      sqlite3_bind_text(statement, indices.idx_country, s, -1, nil)\n                    }\n                    return try NorthwindLighter.withOptCString(phone) { ( s ) in\n                      if indices.idx_phone >= 0 {\n                        sqlite3_bind_text(statement, indices.idx_phone, s, -1, nil)\n                      }\n                      return try NorthwindLighter.withOptCString(fax) { ( s ) in\n                        if indices.idx_fax >= 0 {\n                          sqlite3_bind_text(statement, indices.idx_fax, s, -1, nil)\n                        }\n                        return try NorthwindLighter.withOptCString(homePage) { ( s ) in\n                          if indices.idx_homePage >= 0 {\n                            sqlite3_bind_text(statement, indices.idx_homePage, s, -1, nil)\n                          }\n                          return try execute()\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.Territory {\n  \n  \/**\n   * Static type information for the ``Territory`` record (`Territories` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLKeyedTableSchema {\n    \n    public typealias PropertyIndices = ( idx_id: Int32, idx_territoryDescription: Int32, idx_regionID: Int32 )\n    public typealias RecordType = NorthwindLighter.Territory\n    \n    \/\/\/ The SQL table name associated with the ``Territory`` record.\n    public static let externalName = \"Territories\"\n    \n    \/\/\/ The number of columns the `Territories` table has.\n    public static let columnCount : Int32 = 3\n    \n    \/\/\/ Information on the records primary key (``Territory\/id``).\n    public static let primaryKeyColumn = MappedColumn<NorthwindLighter.Territory, String>(\n      externalName: \"TerritoryID\",\n      defaultValue: \"\",\n      keyPath: \\NorthwindLighter.Territory.id\n    )\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Territories` table.\n    public static let select = #\"SELECT \"TerritoryID\", \"TerritoryDescription\", \"RegionID\" FROM \"Territories\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"TerritoryID\", \"TerritoryDescription\", \"RegionID\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let update = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let updateParameterIndices : PropertyIndices = ( -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insert = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertReturning = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let insertParameterIndices : PropertyIndices = ( -1, -1, -1 )\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let delete = \"\"\n    \n    \/\/\/ *Note*: Readonly database, do not use.\n    public static let deleteParameterIndices : PropertyIndices = ( -1, -1, -1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Territories_id FROM Territories`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Territories_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"TerritoryID\") == 0 {\n          indices.idx_id = i\n        }\n        else if strcmp(col!, \"TerritoryDescription\") == 0 {\n          indices.idx_territoryDescription = i\n        }\n        else if strcmp(col!, \"RegionID\") == 0 {\n          indices.idx_regionID = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``Territory\/id`` (`TerritoryID` column).\n    public let id = MappedColumn<NorthwindLighter.Territory, String>(\n      externalName: \"TerritoryID\",\n      defaultValue: \"\",\n      keyPath: \\NorthwindLighter.Territory.id\n    )\n    \n    \/\/\/ Type information for property ``Territory\/territoryDescription`` (`TerritoryDescription` column).\n    public let territoryDescription = MappedColumn<NorthwindLighter.Territory, String>(\n      externalName: \"TerritoryDescription\",\n      defaultValue: \"\",\n      keyPath: \\NorthwindLighter.Territory.territoryDescription\n    )\n    \n    \/\/\/ Type information for property ``Territory\/regionID`` (`RegionID` column).\n    public let regionID = MappedForeignKey<NorthwindLighter.Territory, Int, MappedColumn<NorthwindLighter.Region, Int>>(\n      externalName: \"RegionID\",\n      defaultValue: -1,\n      keyPath: \\NorthwindLighter.Territory.regionID,\n      destinationColumn: NorthwindLighter.Region.schema.id\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ id, territoryDescription, regionID ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``Territory`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Territories\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = Territory(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      id: ((indices.idx_id >= 0) && (indices.idx_id < argc) ? (sqlite3_column_text(statement, indices.idx_id).flatMap(String.init(cString:))) : nil) ?? Self.schema.id.defaultValue,\n      territoryDescription: ((indices.idx_territoryDescription >= 0) && (indices.idx_territoryDescription < argc) ? (sqlite3_column_text(statement, indices.idx_territoryDescription).flatMap(String.init(cString:))) : nil) ?? Self.schema.territoryDescription.defaultValue,\n      regionID: (indices.idx_regionID >= 0) && (indices.idx_regionID < argc) && (sqlite3_column_type(statement, indices.idx_regionID) != SQLITE_NULL) ? Int(sqlite3_column_int64(statement, indices.idx_regionID)) : Self.schema.regionID.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``Territory`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE \"Territories\" SET \"TerritoryDescription\" = ?, \"RegionID\" = ? WHERE \"TerritoryID\" = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = Territory(id: \"Hello\", territoryDescription: \"World\", regionID: 1)\n   * let ok = record.bind(to: statement, indices: ( 3, 1, 2 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    return try id.withCString() { ( s ) in\n      if indices.idx_id >= 0 {\n        sqlite3_bind_text(statement, indices.idx_id, s, -1, nil)\n      }\n      return try territoryDescription.withCString() { ( s ) in\n        if indices.idx_territoryDescription >= 0 {\n          sqlite3_bind_text(statement, indices.idx_territoryDescription, s, -1, nil)\n        }\n        if indices.idx_regionID >= 0 {\n          sqlite3_bind_int64(statement, indices.idx_regionID, Int64(regionID))\n        }\n        return try execute()\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.AlphabeticalListOfProduct {\n  \n  \/**\n   * Static type information for the ``AlphabeticalListOfProduct`` record (`Alphabetical list of products` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_productID: Int32, idx_productName: Int32, idx_supplierID: Int32, idx_categoryID: Int32, idx_quantityPerUnit: Int32, idx_unitPrice: Int32, idx_unitsInStock: Int32, idx_unitsOnOrder: Int32, idx_reorderLevel: Int32, idx_discontinued: Int32, idx_categoryName: Int32 )\n    public typealias RecordType = NorthwindLighter.AlphabeticalListOfProduct\n    \n    \/\/\/ The SQL table name associated with the ``AlphabeticalListOfProduct`` record.\n    public static let externalName = \"Alphabetical list of products\"\n    \n    \/\/\/ The number of columns the `Alphabetical list of products` table has.\n    public static let columnCount : Int32 = 11\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Alphabetical list of products` table.\n    public static let select = #\"SELECT \"ProductID\", \"ProductName\", \"SupplierID\", \"CategoryID\", \"QuantityPerUnit\", \"UnitPrice\", \"UnitsInStock\", \"UnitsOnOrder\", \"ReorderLevel\", \"Discontinued\", \"CategoryName\" FROM \"Alphabetical list of products\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"ProductID\", \"ProductName\", \"SupplierID\", \"CategoryID\", \"QuantityPerUnit\", \"UnitPrice\", \"UnitsInStock\", \"UnitsOnOrder\", \"ReorderLevel\", \"Discontinued\", \"CategoryName\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Alphabetical list of products_id FROM Alphabetical list of products`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Alphabetical list of products_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"ProductID\") == 0 {\n          indices.idx_productID = i\n        }\n        else if strcmp(col!, \"ProductName\") == 0 {\n          indices.idx_productName = i\n        }\n        else if strcmp(col!, \"SupplierID\") == 0 {\n          indices.idx_supplierID = i\n        }\n        else if strcmp(col!, \"CategoryID\") == 0 {\n          indices.idx_categoryID = i\n        }\n        else if strcmp(col!, \"QuantityPerUnit\") == 0 {\n          indices.idx_quantityPerUnit = i\n        }\n        else if strcmp(col!, \"UnitPrice\") == 0 {\n          indices.idx_unitPrice = i\n        }\n        else if strcmp(col!, \"UnitsInStock\") == 0 {\n          indices.idx_unitsInStock = i\n        }\n        else if strcmp(col!, \"UnitsOnOrder\") == 0 {\n          indices.idx_unitsOnOrder = i\n        }\n        else if strcmp(col!, \"ReorderLevel\") == 0 {\n          indices.idx_reorderLevel = i\n        }\n        else if strcmp(col!, \"Discontinued\") == 0 {\n          indices.idx_discontinued = i\n        }\n        else if strcmp(col!, \"CategoryName\") == 0 {\n          indices.idx_categoryName = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``AlphabeticalListOfProduct\/productID`` (`ProductID` column).\n    public let productID = MappedColumn<NorthwindLighter.AlphabeticalListOfProduct, Int?>(\n      externalName: \"ProductID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.AlphabeticalListOfProduct.productID\n    )\n    \n    \/\/\/ Type information for property ``AlphabeticalListOfProduct\/productName`` (`ProductName` column).\n    public let productName = MappedColumn<NorthwindLighter.AlphabeticalListOfProduct, String?>(\n      externalName: \"ProductName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.AlphabeticalListOfProduct.productName\n    )\n    \n    \/\/\/ Type information for property ``AlphabeticalListOfProduct\/supplierID`` (`SupplierID` column).\n    public let supplierID = MappedColumn<NorthwindLighter.AlphabeticalListOfProduct, Int?>(\n      externalName: \"SupplierID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.AlphabeticalListOfProduct.supplierID\n    )\n    \n    \/\/\/ Type information for property ``AlphabeticalListOfProduct\/categoryID`` (`CategoryID` column).\n    public let categoryID = MappedColumn<NorthwindLighter.AlphabeticalListOfProduct, Int?>(\n      externalName: \"CategoryID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.AlphabeticalListOfProduct.categoryID\n    )\n    \n    \/\/\/ Type information for property ``AlphabeticalListOfProduct\/quantityPerUnit`` (`QuantityPerUnit` column).\n    public let quantityPerUnit = MappedColumn<NorthwindLighter.AlphabeticalListOfProduct, String?>(\n      externalName: \"QuantityPerUnit\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.AlphabeticalListOfProduct.quantityPerUnit\n    )\n    \n    \/\/\/ Type information for property ``AlphabeticalListOfProduct\/unitPrice`` (`UnitPrice` column).\n    public let unitPrice = MappedColumn<NorthwindLighter.AlphabeticalListOfProduct, String?>(\n      externalName: \"UnitPrice\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.AlphabeticalListOfProduct.unitPrice\n    )\n    \n    \/\/\/ Type information for property ``AlphabeticalListOfProduct\/unitsInStock`` (`UnitsInStock` column).\n    public let unitsInStock = MappedColumn<NorthwindLighter.AlphabeticalListOfProduct, Int?>(\n      externalName: \"UnitsInStock\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.AlphabeticalListOfProduct.unitsInStock\n    )\n    \n    \/\/\/ Type information for property ``AlphabeticalListOfProduct\/unitsOnOrder`` (`UnitsOnOrder` column).\n    public let unitsOnOrder = MappedColumn<NorthwindLighter.AlphabeticalListOfProduct, Int?>(\n      externalName: \"UnitsOnOrder\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.AlphabeticalListOfProduct.unitsOnOrder\n    )\n    \n    \/\/\/ Type information for property ``AlphabeticalListOfProduct\/reorderLevel`` (`ReorderLevel` column).\n    public let reorderLevel = MappedColumn<NorthwindLighter.AlphabeticalListOfProduct, Int?>(\n      externalName: \"ReorderLevel\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.AlphabeticalListOfProduct.reorderLevel\n    )\n    \n    \/\/\/ Type information for property ``AlphabeticalListOfProduct\/discontinued`` (`Discontinued` column).\n    public let discontinued = MappedColumn<NorthwindLighter.AlphabeticalListOfProduct, String?>(\n      externalName: \"Discontinued\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.AlphabeticalListOfProduct.discontinued\n    )\n    \n    \/\/\/ Type information for property ``AlphabeticalListOfProduct\/categoryName`` (`CategoryName` column).\n    public let categoryName = MappedColumn<NorthwindLighter.AlphabeticalListOfProduct, String?>(\n      externalName: \"CategoryName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.AlphabeticalListOfProduct.categoryName\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ productID, productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued, categoryName ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``AlphabeticalListOfProduct`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Alphabetical list of products\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = AlphabeticalListOfProduct(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      productID: (indices.idx_productID >= 0) && (indices.idx_productID < argc) ? (sqlite3_column_type(statement, indices.idx_productID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_productID)) : nil) : Self.schema.productID.defaultValue,\n      productName: (indices.idx_productName >= 0) && (indices.idx_productName < argc) ? (sqlite3_column_text(statement, indices.idx_productName).flatMap(String.init(cString:))) : Self.schema.productName.defaultValue,\n      supplierID: (indices.idx_supplierID >= 0) && (indices.idx_supplierID < argc) ? (sqlite3_column_type(statement, indices.idx_supplierID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_supplierID)) : nil) : Self.schema.supplierID.defaultValue,\n      categoryID: (indices.idx_categoryID >= 0) && (indices.idx_categoryID < argc) ? (sqlite3_column_type(statement, indices.idx_categoryID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_categoryID)) : nil) : Self.schema.categoryID.defaultValue,\n      quantityPerUnit: (indices.idx_quantityPerUnit >= 0) && (indices.idx_quantityPerUnit < argc) ? (sqlite3_column_text(statement, indices.idx_quantityPerUnit).flatMap(String.init(cString:))) : Self.schema.quantityPerUnit.defaultValue,\n      unitPrice: (indices.idx_unitPrice >= 0) && (indices.idx_unitPrice < argc) ? (sqlite3_column_text(statement, indices.idx_unitPrice).flatMap(String.init(cString:))) : Self.schema.unitPrice.defaultValue,\n      unitsInStock: (indices.idx_unitsInStock >= 0) && (indices.idx_unitsInStock < argc) ? (sqlite3_column_type(statement, indices.idx_unitsInStock) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_unitsInStock)) : nil) : Self.schema.unitsInStock.defaultValue,\n      unitsOnOrder: (indices.idx_unitsOnOrder >= 0) && (indices.idx_unitsOnOrder < argc) ? (sqlite3_column_type(statement, indices.idx_unitsOnOrder) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_unitsOnOrder)) : nil) : Self.schema.unitsOnOrder.defaultValue,\n      reorderLevel: (indices.idx_reorderLevel >= 0) && (indices.idx_reorderLevel < argc) ? (sqlite3_column_type(statement, indices.idx_reorderLevel) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_reorderLevel)) : nil) : Self.schema.reorderLevel.defaultValue,\n      discontinued: (indices.idx_discontinued >= 0) && (indices.idx_discontinued < argc) ? (sqlite3_column_text(statement, indices.idx_discontinued).flatMap(String.init(cString:))) : Self.schema.discontinued.defaultValue,\n      categoryName: (indices.idx_categoryName >= 0) && (indices.idx_categoryName < argc) ? (sqlite3_column_text(statement, indices.idx_categoryName).flatMap(String.init(cString:))) : Self.schema.categoryName.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``AlphabeticalListOfProduct`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Alphabetical list of products SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = AlphabeticalListOfProduct(productID: 1, productName: \"Hello\", supplierID: 2, categoryID: 3)\n   * let ok = record.bind(to: statement, indices: ( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_productID >= 0 {\n      if let productID = productID {\n        sqlite3_bind_int64(statement, indices.idx_productID, Int64(productID))\n      }\n      else {\n        sqlite3_bind_null(statement, indices.idx_productID)\n      }\n    }\n    return try NorthwindLighter.withOptCString(productName) { ( s ) in\n      if indices.idx_productName >= 0 {\n        sqlite3_bind_text(statement, indices.idx_productName, s, -1, nil)\n      }\n      if indices.idx_supplierID >= 0 {\n        if let supplierID = supplierID {\n          sqlite3_bind_int64(statement, indices.idx_supplierID, Int64(supplierID))\n        }\n        else {\n          sqlite3_bind_null(statement, indices.idx_supplierID)\n        }\n      }\n      if indices.idx_categoryID >= 0 {\n        if let categoryID = categoryID {\n          sqlite3_bind_int64(statement, indices.idx_categoryID, Int64(categoryID))\n        }\n        else {\n          sqlite3_bind_null(statement, indices.idx_categoryID)\n        }\n      }\n      return try NorthwindLighter.withOptCString(quantityPerUnit) { ( s ) in\n        if indices.idx_quantityPerUnit >= 0 {\n          sqlite3_bind_text(statement, indices.idx_quantityPerUnit, s, -1, nil)\n        }\n        return try NorthwindLighter.withOptCString(unitPrice) { ( s ) in\n          if indices.idx_unitPrice >= 0 {\n            sqlite3_bind_text(statement, indices.idx_unitPrice, s, -1, nil)\n          }\n          if indices.idx_unitsInStock >= 0 {\n            if let unitsInStock = unitsInStock {\n              sqlite3_bind_int64(statement, indices.idx_unitsInStock, Int64(unitsInStock))\n            }\n            else {\n              sqlite3_bind_null(statement, indices.idx_unitsInStock)\n            }\n          }\n          if indices.idx_unitsOnOrder >= 0 {\n            if let unitsOnOrder = unitsOnOrder {\n              sqlite3_bind_int64(statement, indices.idx_unitsOnOrder, Int64(unitsOnOrder))\n            }\n            else {\n              sqlite3_bind_null(statement, indices.idx_unitsOnOrder)\n            }\n          }\n          if indices.idx_reorderLevel >= 0 {\n            if let reorderLevel = reorderLevel {\n              sqlite3_bind_int64(statement, indices.idx_reorderLevel, Int64(reorderLevel))\n            }\n            else {\n              sqlite3_bind_null(statement, indices.idx_reorderLevel)\n            }\n          }\n          return try NorthwindLighter.withOptCString(discontinued) { ( s ) in\n            if indices.idx_discontinued >= 0 {\n              sqlite3_bind_text(statement, indices.idx_discontinued, s, -1, nil)\n            }\n            return try NorthwindLighter.withOptCString(categoryName) { ( s ) in\n              if indices.idx_categoryName >= 0 {\n                sqlite3_bind_text(statement, indices.idx_categoryName, s, -1, nil)\n              }\n              return try execute()\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.CurrentProductList {\n  \n  \/**\n   * Static type information for the ``CurrentProductList`` record (`Current Product List` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_productID: Int32, idx_productName: Int32 )\n    public typealias RecordType = NorthwindLighter.CurrentProductList\n    \n    \/\/\/ The SQL table name associated with the ``CurrentProductList`` record.\n    public static let externalName = \"Current Product List\"\n    \n    \/\/\/ The number of columns the `Current Product List` table has.\n    public static let columnCount : Int32 = 2\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Current Product List` table.\n    public static let select = #\"SELECT \"ProductID\", \"ProductName\" FROM \"Current Product List\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"ProductID\", \"ProductName\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Current Product List_id FROM Current Product List`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Current Product List_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"ProductID\") == 0 {\n          indices.idx_productID = i\n        }\n        else if strcmp(col!, \"ProductName\") == 0 {\n          indices.idx_productName = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``CurrentProductList\/productID`` (`ProductID` column).\n    public let productID = MappedColumn<NorthwindLighter.CurrentProductList, Int?>(\n      externalName: \"ProductID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.CurrentProductList.productID\n    )\n    \n    \/\/\/ Type information for property ``CurrentProductList\/productName`` (`ProductName` column).\n    public let productName = MappedColumn<NorthwindLighter.CurrentProductList, String?>(\n      externalName: \"ProductName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.CurrentProductList.productName\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ productID, productName ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``CurrentProductList`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Current Product List\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = CurrentProductList(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      productID: (indices.idx_productID >= 0) && (indices.idx_productID < argc) ? (sqlite3_column_type(statement, indices.idx_productID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_productID)) : nil) : Self.schema.productID.defaultValue,\n      productName: (indices.idx_productName >= 0) && (indices.idx_productName < argc) ? (sqlite3_column_text(statement, indices.idx_productName).flatMap(String.init(cString:))) : Self.schema.productName.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``CurrentProductList`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Current Product List SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = CurrentProductList(productID: 1, productName: \"Hello\")\n   * let ok = record.bind(to: statement, indices: ( 1, 2 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_productID >= 0 {\n      if let productID = productID {\n        sqlite3_bind_int64(statement, indices.idx_productID, Int64(productID))\n      }\n      else {\n        sqlite3_bind_null(statement, indices.idx_productID)\n      }\n    }\n    return try NorthwindLighter.withOptCString(productName) { ( s ) in\n      if indices.idx_productName >= 0 {\n        sqlite3_bind_text(statement, indices.idx_productName, s, -1, nil)\n      }\n      return try execute()\n    }\n  }\n}\n\npublic extension NorthwindLighter.CustomerAndSuppliersByCity {\n  \n  \/**\n   * Static type information for the ``CustomerAndSuppliersByCity`` record (`Customer and Suppliers by City` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_city: Int32, idx_companyName: Int32, idx_contactName: Int32, idx_relationship: Int32 )\n    public typealias RecordType = NorthwindLighter.CustomerAndSuppliersByCity\n    \n    \/\/\/ The SQL table name associated with the ``CustomerAndSuppliersByCity`` record.\n    public static let externalName = \"Customer and Suppliers by City\"\n    \n    \/\/\/ The number of columns the `Customer and Suppliers by City` table has.\n    public static let columnCount : Int32 = 4\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Customer and Suppliers by City` table.\n    public static let select = #\"SELECT \"City\", \"CompanyName\", \"ContactName\", \"Relationship\" FROM \"Customer and Suppliers by City\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"City\", \"CompanyName\", \"ContactName\", \"Relationship\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Customer and Suppliers by City_id FROM Customer and Suppliers by City`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Customer and Suppliers by City_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"City\") == 0 {\n          indices.idx_city = i\n        }\n        else if strcmp(col!, \"CompanyName\") == 0 {\n          indices.idx_companyName = i\n        }\n        else if strcmp(col!, \"ContactName\") == 0 {\n          indices.idx_contactName = i\n        }\n        else if strcmp(col!, \"Relationship\") == 0 {\n          indices.idx_relationship = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``CustomerAndSuppliersByCity\/city`` (`City` column).\n    public let city = MappedColumn<NorthwindLighter.CustomerAndSuppliersByCity, String?>(\n      externalName: \"City\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.CustomerAndSuppliersByCity.city\n    )\n    \n    \/\/\/ Type information for property ``CustomerAndSuppliersByCity\/companyName`` (`CompanyName` column).\n    public let companyName = MappedColumn<NorthwindLighter.CustomerAndSuppliersByCity, String?>(\n      externalName: \"CompanyName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.CustomerAndSuppliersByCity.companyName\n    )\n    \n    \/\/\/ Type information for property ``CustomerAndSuppliersByCity\/contactName`` (`ContactName` column).\n    public let contactName = MappedColumn<NorthwindLighter.CustomerAndSuppliersByCity, String?>(\n      externalName: \"ContactName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.CustomerAndSuppliersByCity.contactName\n    )\n    \n    \/\/\/ Type information for property ``CustomerAndSuppliersByCity\/relationship`` (`Relationship` column).\n    public let relationship = MappedColumn<NorthwindLighter.CustomerAndSuppliersByCity, String?>(\n      externalName: \"Relationship\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.CustomerAndSuppliersByCity.relationship\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ city, companyName, contactName, relationship ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``CustomerAndSuppliersByCity`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Customer and Suppliers by City\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = CustomerAndSuppliersByCity(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      city: (indices.idx_city >= 0) && (indices.idx_city < argc) ? (sqlite3_column_text(statement, indices.idx_city).flatMap(String.init(cString:))) : Self.schema.city.defaultValue,\n      companyName: (indices.idx_companyName >= 0) && (indices.idx_companyName < argc) ? (sqlite3_column_text(statement, indices.idx_companyName).flatMap(String.init(cString:))) : Self.schema.companyName.defaultValue,\n      contactName: (indices.idx_contactName >= 0) && (indices.idx_contactName < argc) ? (sqlite3_column_text(statement, indices.idx_contactName).flatMap(String.init(cString:))) : Self.schema.contactName.defaultValue,\n      relationship: (indices.idx_relationship >= 0) && (indices.idx_relationship < argc) ? (sqlite3_column_text(statement, indices.idx_relationship).flatMap(String.init(cString:))) : Self.schema.relationship.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``CustomerAndSuppliersByCity`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Customer and Suppliers by City SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = CustomerAndSuppliersByCity(city: \"Hello\", companyName: \"World\", contactName: \"Duck\", relationship: \"Donald\")\n   * let ok = record.bind(to: statement, indices: ( 1, 2, 3, 4 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    return try NorthwindLighter.withOptCString(city) { ( s ) in\n      if indices.idx_city >= 0 {\n        sqlite3_bind_text(statement, indices.idx_city, s, -1, nil)\n      }\n      return try NorthwindLighter.withOptCString(companyName) { ( s ) in\n        if indices.idx_companyName >= 0 {\n          sqlite3_bind_text(statement, indices.idx_companyName, s, -1, nil)\n        }\n        return try NorthwindLighter.withOptCString(contactName) { ( s ) in\n          if indices.idx_contactName >= 0 {\n            sqlite3_bind_text(statement, indices.idx_contactName, s, -1, nil)\n          }\n          return try NorthwindLighter.withOptCString(relationship) { ( s ) in\n            if indices.idx_relationship >= 0 {\n              sqlite3_bind_text(statement, indices.idx_relationship, s, -1, nil)\n            }\n            return try execute()\n          }\n        }\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.Invoice {\n  \n  \/**\n   * Static type information for the ``Invoice`` record (`Invoices` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_shipName: Int32, idx_shipAddress: Int32, idx_shipCity: Int32, idx_shipRegion: Int32, idx_shipPostalCode: Int32, idx_shipCountry: Int32, idx_customerID: Int32, idx_customerName: Int32, idx_address: Int32, idx_city: Int32, idx_region: Int32, idx_postalCode: Int32, idx_country: Int32, idx_salesperson: Int32, idx_orderID: Int32, idx_orderDate: Int32, idx_requiredDate: Int32, idx_shippedDate: Int32, idx_shipperName: Int32, idx_productID: Int32, idx_productName: Int32, idx_unitPrice: Int32, idx_quantity: Int32, idx_discount: Int32, idx_extendedPrice: Int32, idx_freight: Int32 )\n    public typealias RecordType = NorthwindLighter.Invoice\n    \n    \/\/\/ The SQL table name associated with the ``Invoice`` record.\n    public static let externalName = \"Invoices\"\n    \n    \/\/\/ The number of columns the `Invoices` table has.\n    public static let columnCount : Int32 = 26\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Invoices` table.\n    public static let select = #\"SELECT \"ShipName\", \"ShipAddress\", \"ShipCity\", \"ShipRegion\", \"ShipPostalCode\", \"ShipCountry\", \"CustomerID\", \"CustomerName\", \"Address\", \"City\", \"Region\", \"PostalCode\", \"Country\", \"Salesperson\", \"OrderID\", \"OrderDate\", \"RequiredDate\", \"ShippedDate\", \"ShipperName\", \"ProductID\", \"ProductName\", \"UnitPrice\", \"Quantity\", \"Discount\", \"ExtendedPrice\", \"Freight\" FROM \"Invoices\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"ShipName\", \"ShipAddress\", \"ShipCity\", \"ShipRegion\", \"ShipPostalCode\", \"ShipCountry\", \"CustomerID\", \"CustomerName\", \"Address\", \"City\", \"Region\", \"PostalCode\", \"Country\", \"Salesperson\", \"OrderID\", \"OrderDate\", \"RequiredDate\", \"ShippedDate\", \"ShipperName\", \"ProductID\", \"ProductName\", \"UnitPrice\", \"Quantity\", \"Discount\", \"ExtendedPrice\", \"Freight\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Invoices_id FROM Invoices`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Invoices_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"ShipName\") == 0 {\n          indices.idx_shipName = i\n        }\n        else if strcmp(col!, \"ShipAddress\") == 0 {\n          indices.idx_shipAddress = i\n        }\n        else if strcmp(col!, \"ShipCity\") == 0 {\n          indices.idx_shipCity = i\n        }\n        else if strcmp(col!, \"ShipRegion\") == 0 {\n          indices.idx_shipRegion = i\n        }\n        else if strcmp(col!, \"ShipPostalCode\") == 0 {\n          indices.idx_shipPostalCode = i\n        }\n        else if strcmp(col!, \"ShipCountry\") == 0 {\n          indices.idx_shipCountry = i\n        }\n        else if strcmp(col!, \"CustomerID\") == 0 {\n          indices.idx_customerID = i\n        }\n        else if strcmp(col!, \"CustomerName\") == 0 {\n          indices.idx_customerName = i\n        }\n        else if strcmp(col!, \"Address\") == 0 {\n          indices.idx_address = i\n        }\n        else if strcmp(col!, \"City\") == 0 {\n          indices.idx_city = i\n        }\n        else if strcmp(col!, \"Region\") == 0 {\n          indices.idx_region = i\n        }\n        else if strcmp(col!, \"PostalCode\") == 0 {\n          indices.idx_postalCode = i\n        }\n        else if strcmp(col!, \"Country\") == 0 {\n          indices.idx_country = i\n        }\n        else if strcmp(col!, \"Salesperson\") == 0 {\n          indices.idx_salesperson = i\n        }\n        else if strcmp(col!, \"OrderID\") == 0 {\n          indices.idx_orderID = i\n        }\n        else if strcmp(col!, \"OrderDate\") == 0 {\n          indices.idx_orderDate = i\n        }\n        else if strcmp(col!, \"RequiredDate\") == 0 {\n          indices.idx_requiredDate = i\n        }\n        else if strcmp(col!, \"ShippedDate\") == 0 {\n          indices.idx_shippedDate = i\n        }\n        else if strcmp(col!, \"ShipperName\") == 0 {\n          indices.idx_shipperName = i\n        }\n        else if strcmp(col!, \"ProductID\") == 0 {\n          indices.idx_productID = i\n        }\n        else if strcmp(col!, \"ProductName\") == 0 {\n          indices.idx_productName = i\n        }\n        else if strcmp(col!, \"UnitPrice\") == 0 {\n          indices.idx_unitPrice = i\n        }\n        else if strcmp(col!, \"Quantity\") == 0 {\n          indices.idx_quantity = i\n        }\n        else if strcmp(col!, \"Discount\") == 0 {\n          indices.idx_discount = i\n        }\n        else if strcmp(col!, \"ExtendedPrice\") == 0 {\n          indices.idx_extendedPrice = i\n        }\n        else if strcmp(col!, \"Freight\") == 0 {\n          indices.idx_freight = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``Invoice\/shipName`` (`ShipName` column).\n    public let shipName = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"ShipName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.shipName\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/shipAddress`` (`ShipAddress` column).\n    public let shipAddress = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"ShipAddress\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.shipAddress\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/shipCity`` (`ShipCity` column).\n    public let shipCity = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"ShipCity\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.shipCity\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/shipRegion`` (`ShipRegion` column).\n    public let shipRegion = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"ShipRegion\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.shipRegion\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/shipPostalCode`` (`ShipPostalCode` column).\n    public let shipPostalCode = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"ShipPostalCode\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.shipPostalCode\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/shipCountry`` (`ShipCountry` column).\n    public let shipCountry = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"ShipCountry\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.shipCountry\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/customerID`` (`CustomerID` column).\n    public let customerID = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"CustomerID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.customerID\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/customerName`` (`CustomerName` column).\n    public let customerName = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"CustomerName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.customerName\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/address`` (`Address` column).\n    public let address = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"Address\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.address\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/city`` (`City` column).\n    public let city = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"City\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.city\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/region`` (`Region` column).\n    public let region = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"Region\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.region\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/postalCode`` (`PostalCode` column).\n    public let postalCode = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"PostalCode\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.postalCode\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/country`` (`Country` column).\n    public let country = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"Country\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.country\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/salesperson`` (`Salesperson` column).\n    public let salesperson = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"Salesperson\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.salesperson\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/orderID`` (`OrderID` column).\n    public let orderID = MappedColumn<NorthwindLighter.Invoice, Int?>(\n      externalName: \"OrderID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.orderID\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/orderDate`` (`OrderDate` column).\n    public let orderDate = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"OrderDate\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.orderDate\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/requiredDate`` (`RequiredDate` column).\n    public let requiredDate = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"RequiredDate\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.requiredDate\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/shippedDate`` (`ShippedDate` column).\n    public let shippedDate = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"ShippedDate\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.shippedDate\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/shipperName`` (`ShipperName` column).\n    public let shipperName = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"ShipperName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.shipperName\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/productID`` (`ProductID` column).\n    public let productID = MappedColumn<NorthwindLighter.Invoice, Int?>(\n      externalName: \"ProductID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.productID\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/productName`` (`ProductName` column).\n    public let productName = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"ProductName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.productName\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/unitPrice`` (`UnitPrice` column).\n    public let unitPrice = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"UnitPrice\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.unitPrice\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/quantity`` (`Quantity` column).\n    public let quantity = MappedColumn<NorthwindLighter.Invoice, Int?>(\n      externalName: \"Quantity\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.quantity\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/discount`` (`Discount` column).\n    public let discount = MappedColumn<NorthwindLighter.Invoice, Double?>(\n      externalName: \"Discount\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.discount\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/extendedPrice`` (`ExtendedPrice` column).\n    public let extendedPrice = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"ExtendedPrice\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.extendedPrice\n    )\n    \n    \/\/\/ Type information for property ``Invoice\/freight`` (`Freight` column).\n    public let freight = MappedColumn<NorthwindLighter.Invoice, String?>(\n      externalName: \"Freight\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.Invoice.freight\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ shipName, shipAddress, shipCity, shipRegion, shipPostalCode, shipCountry, customerID, customerName, address, city, region, postalCode, country, salesperson, orderID, orderDate, requiredDate, shippedDate, shipperName, productID, productName, unitPrice, quantity, discount, extendedPrice, freight ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``Invoice`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Invoices\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = Invoice(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      shipName: (indices.idx_shipName >= 0) && (indices.idx_shipName < argc) ? (sqlite3_column_text(statement, indices.idx_shipName).flatMap(String.init(cString:))) : Self.schema.shipName.defaultValue,\n      shipAddress: (indices.idx_shipAddress >= 0) && (indices.idx_shipAddress < argc) ? (sqlite3_column_text(statement, indices.idx_shipAddress).flatMap(String.init(cString:))) : Self.schema.shipAddress.defaultValue,\n      shipCity: (indices.idx_shipCity >= 0) && (indices.idx_shipCity < argc) ? (sqlite3_column_text(statement, indices.idx_shipCity).flatMap(String.init(cString:))) : Self.schema.shipCity.defaultValue,\n      shipRegion: (indices.idx_shipRegion >= 0) && (indices.idx_shipRegion < argc) ? (sqlite3_column_text(statement, indices.idx_shipRegion).flatMap(String.init(cString:))) : Self.schema.shipRegion.defaultValue,\n      shipPostalCode: (indices.idx_shipPostalCode >= 0) && (indices.idx_shipPostalCode < argc) ? (sqlite3_column_text(statement, indices.idx_shipPostalCode).flatMap(String.init(cString:))) : Self.schema.shipPostalCode.defaultValue,\n      shipCountry: (indices.idx_shipCountry >= 0) && (indices.idx_shipCountry < argc) ? (sqlite3_column_text(statement, indices.idx_shipCountry).flatMap(String.init(cString:))) : Self.schema.shipCountry.defaultValue,\n      customerID: (indices.idx_customerID >= 0) && (indices.idx_customerID < argc) ? (sqlite3_column_text(statement, indices.idx_customerID).flatMap(String.init(cString:))) : Self.schema.customerID.defaultValue,\n      customerName: (indices.idx_customerName >= 0) && (indices.idx_customerName < argc) ? (sqlite3_column_text(statement, indices.idx_customerName).flatMap(String.init(cString:))) : Self.schema.customerName.defaultValue,\n      address: (indices.idx_address >= 0) && (indices.idx_address < argc) ? (sqlite3_column_text(statement, indices.idx_address).flatMap(String.init(cString:))) : Self.schema.address.defaultValue,\n      city: (indices.idx_city >= 0) && (indices.idx_city < argc) ? (sqlite3_column_text(statement, indices.idx_city).flatMap(String.init(cString:))) : Self.schema.city.defaultValue,\n      region: (indices.idx_region >= 0) && (indices.idx_region < argc) ? (sqlite3_column_text(statement, indices.idx_region).flatMap(String.init(cString:))) : Self.schema.region.defaultValue,\n      postalCode: (indices.idx_postalCode >= 0) && (indices.idx_postalCode < argc) ? (sqlite3_column_text(statement, indices.idx_postalCode).flatMap(String.init(cString:))) : Self.schema.postalCode.defaultValue,\n      country: (indices.idx_country >= 0) && (indices.idx_country < argc) ? (sqlite3_column_text(statement, indices.idx_country).flatMap(String.init(cString:))) : Self.schema.country.defaultValue,\n      salesperson: (indices.idx_salesperson >= 0) && (indices.idx_salesperson < argc) ? (sqlite3_column_text(statement, indices.idx_salesperson).flatMap(String.init(cString:))) : Self.schema.salesperson.defaultValue,\n      orderID: (indices.idx_orderID >= 0) && (indices.idx_orderID < argc) ? (sqlite3_column_type(statement, indices.idx_orderID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_orderID)) : nil) : Self.schema.orderID.defaultValue,\n      orderDate: (indices.idx_orderDate >= 0) && (indices.idx_orderDate < argc) ? (sqlite3_column_text(statement, indices.idx_orderDate).flatMap(String.init(cString:))) : Self.schema.orderDate.defaultValue,\n      requiredDate: (indices.idx_requiredDate >= 0) && (indices.idx_requiredDate < argc) ? (sqlite3_column_text(statement, indices.idx_requiredDate).flatMap(String.init(cString:))) : Self.schema.requiredDate.defaultValue,\n      shippedDate: (indices.idx_shippedDate >= 0) && (indices.idx_shippedDate < argc) ? (sqlite3_column_text(statement, indices.idx_shippedDate).flatMap(String.init(cString:))) : Self.schema.shippedDate.defaultValue,\n      shipperName: (indices.idx_shipperName >= 0) && (indices.idx_shipperName < argc) ? (sqlite3_column_text(statement, indices.idx_shipperName).flatMap(String.init(cString:))) : Self.schema.shipperName.defaultValue,\n      productID: (indices.idx_productID >= 0) && (indices.idx_productID < argc) ? (sqlite3_column_type(statement, indices.idx_productID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_productID)) : nil) : Self.schema.productID.defaultValue,\n      productName: (indices.idx_productName >= 0) && (indices.idx_productName < argc) ? (sqlite3_column_text(statement, indices.idx_productName).flatMap(String.init(cString:))) : Self.schema.productName.defaultValue,\n      unitPrice: (indices.idx_unitPrice >= 0) && (indices.idx_unitPrice < argc) ? (sqlite3_column_text(statement, indices.idx_unitPrice).flatMap(String.init(cString:))) : Self.schema.unitPrice.defaultValue,\n      quantity: (indices.idx_quantity >= 0) && (indices.idx_quantity < argc) ? (sqlite3_column_type(statement, indices.idx_quantity) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_quantity)) : nil) : Self.schema.quantity.defaultValue,\n      discount: (indices.idx_discount >= 0) && (indices.idx_discount < argc) ? (sqlite3_column_type(statement, indices.idx_discount) != SQLITE_NULL ? sqlite3_column_double(statement, indices.idx_discount) : nil) : Self.schema.discount.defaultValue,\n      extendedPrice: (indices.idx_extendedPrice >= 0) && (indices.idx_extendedPrice < argc) ? (sqlite3_column_text(statement, indices.idx_extendedPrice).flatMap(String.init(cString:))) : Self.schema.extendedPrice.defaultValue,\n      freight: (indices.idx_freight >= 0) && (indices.idx_freight < argc) ? (sqlite3_column_text(statement, indices.idx_freight).flatMap(String.init(cString:))) : Self.schema.freight.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``Invoice`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Invoices SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = Invoice(shipName: \"Hello\", shipAddress: \"World\", shipCity: \"Duck\", shipRegion: \"Donald\")\n   * let ok = record.bind(to: statement, indices: ( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    return try NorthwindLighter.withOptCString(shipName) { ( s ) in\n      if indices.idx_shipName >= 0 {\n        sqlite3_bind_text(statement, indices.idx_shipName, s, -1, nil)\n      }\n      return try NorthwindLighter.withOptCString(shipAddress) { ( s ) in\n        if indices.idx_shipAddress >= 0 {\n          sqlite3_bind_text(statement, indices.idx_shipAddress, s, -1, nil)\n        }\n        return try NorthwindLighter.withOptCString(shipCity) { ( s ) in\n          if indices.idx_shipCity >= 0 {\n            sqlite3_bind_text(statement, indices.idx_shipCity, s, -1, nil)\n          }\n          return try NorthwindLighter.withOptCString(shipRegion) { ( s ) in\n            if indices.idx_shipRegion >= 0 {\n              sqlite3_bind_text(statement, indices.idx_shipRegion, s, -1, nil)\n            }\n            return try NorthwindLighter.withOptCString(shipPostalCode) { ( s ) in\n              if indices.idx_shipPostalCode >= 0 {\n                sqlite3_bind_text(statement, indices.idx_shipPostalCode, s, -1, nil)\n              }\n              return try NorthwindLighter.withOptCString(shipCountry) { ( s ) in\n                if indices.idx_shipCountry >= 0 {\n                  sqlite3_bind_text(statement, indices.idx_shipCountry, s, -1, nil)\n                }\n                return try NorthwindLighter.withOptCString(customerID) { ( s ) in\n                  if indices.idx_customerID >= 0 {\n                    sqlite3_bind_text(statement, indices.idx_customerID, s, -1, nil)\n                  }\n                  return try NorthwindLighter.withOptCString(customerName) { ( s ) in\n                    if indices.idx_customerName >= 0 {\n                      sqlite3_bind_text(statement, indices.idx_customerName, s, -1, nil)\n                    }\n                    return try NorthwindLighter.withOptCString(address) { ( s ) in\n                      if indices.idx_address >= 0 {\n                        sqlite3_bind_text(statement, indices.idx_address, s, -1, nil)\n                      }\n                      return try NorthwindLighter.withOptCString(city) { ( s ) in\n                        if indices.idx_city >= 0 {\n                          sqlite3_bind_text(statement, indices.idx_city, s, -1, nil)\n                        }\n                        return try NorthwindLighter.withOptCString(region) { ( s ) in\n                          if indices.idx_region >= 0 {\n                            sqlite3_bind_text(statement, indices.idx_region, s, -1, nil)\n                          }\n                          return try NorthwindLighter.withOptCString(postalCode) { ( s ) in\n                            if indices.idx_postalCode >= 0 {\n                              sqlite3_bind_text(statement, indices.idx_postalCode, s, -1, nil)\n                            }\n                            return try NorthwindLighter.withOptCString(country) { ( s ) in\n                              if indices.idx_country >= 0 {\n                                sqlite3_bind_text(statement, indices.idx_country, s, -1, nil)\n                              }\n                              return try NorthwindLighter.withOptCString(salesperson) { ( s ) in\n                                if indices.idx_salesperson >= 0 {\n                                  sqlite3_bind_text(statement, indices.idx_salesperson, s, -1, nil)\n                                }\n                                if indices.idx_orderID >= 0 {\n                                  if let orderID = orderID {\n                                    sqlite3_bind_int64(statement, indices.idx_orderID, Int64(orderID))\n                                  }\n                                  else {\n                                    sqlite3_bind_null(statement, indices.idx_orderID)\n                                  }\n                                }\n                                return try NorthwindLighter.withOptCString(orderDate) { ( s ) in\n                                  if indices.idx_orderDate >= 0 {\n                                    sqlite3_bind_text(statement, indices.idx_orderDate, s, -1, nil)\n                                  }\n                                  return try NorthwindLighter.withOptCString(requiredDate) { ( s ) in\n                                    if indices.idx_requiredDate >= 0 {\n                                      sqlite3_bind_text(statement, indices.idx_requiredDate, s, -1, nil)\n                                    }\n                                    return try NorthwindLighter.withOptCString(shippedDate) { ( s ) in\n                                      if indices.idx_shippedDate >= 0 {\n                                        sqlite3_bind_text(statement, indices.idx_shippedDate, s, -1, nil)\n                                      }\n                                      return try NorthwindLighter.withOptCString(shipperName) { ( s ) in\n                                        if indices.idx_shipperName >= 0 {\n                                          sqlite3_bind_text(statement, indices.idx_shipperName, s, -1, nil)\n                                        }\n                                        if indices.idx_productID >= 0 {\n                                          if let productID = productID {\n                                            sqlite3_bind_int64(statement, indices.idx_productID, Int64(productID))\n                                          }\n                                          else {\n                                            sqlite3_bind_null(statement, indices.idx_productID)\n                                          }\n                                        }\n                                        return try NorthwindLighter.withOptCString(productName) { ( s ) in\n                                          if indices.idx_productName >= 0 {\n                                            sqlite3_bind_text(statement, indices.idx_productName, s, -1, nil)\n                                          }\n                                          return try NorthwindLighter.withOptCString(unitPrice) { ( s ) in\n                                            if indices.idx_unitPrice >= 0 {\n                                              sqlite3_bind_text(statement, indices.idx_unitPrice, s, -1, nil)\n                                            }\n                                            if indices.idx_quantity >= 0 {\n                                              if let quantity = quantity {\n                                                sqlite3_bind_int64(statement, indices.idx_quantity, Int64(quantity))\n                                              }\n                                              else {\n                                                sqlite3_bind_null(statement, indices.idx_quantity)\n                                              }\n                                            }\n                                            if indices.idx_discount >= 0 {\n                                              if let discount = discount {\n                                                sqlite3_bind_double(statement, indices.idx_discount, discount)\n                                              }\n                                              else {\n                                                sqlite3_bind_null(statement, indices.idx_discount)\n                                              }\n                                            }\n                                            return try NorthwindLighter.withOptCString(extendedPrice) { ( s ) in\n                                              if indices.idx_extendedPrice >= 0 {\n                                                sqlite3_bind_text(statement, indices.idx_extendedPrice, s, -1, nil)\n                                              }\n                                              return try NorthwindLighter.withOptCString(freight) { ( s ) in\n                                                if indices.idx_freight >= 0 {\n                                                  sqlite3_bind_text(statement, indices.idx_freight, s, -1, nil)\n                                                }\n                                                return try execute()\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.OrdersQry {\n  \n  \/**\n   * Static type information for the ``OrdersQry`` record (`Orders Qry` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_orderID: Int32, idx_customerID: Int32, idx_employeeID: Int32, idx_orderDate: Int32, idx_requiredDate: Int32, idx_shippedDate: Int32, idx_shipVia: Int32, idx_freight: Int32, idx_shipName: Int32, idx_shipAddress: Int32, idx_shipCity: Int32, idx_shipRegion: Int32, idx_shipPostalCode: Int32, idx_shipCountry: Int32, idx_companyName: Int32, idx_address: Int32, idx_city: Int32, idx_region: Int32, idx_postalCode: Int32, idx_country: Int32 )\n    public typealias RecordType = NorthwindLighter.OrdersQry\n    \n    \/\/\/ The SQL table name associated with the ``OrdersQry`` record.\n    public static let externalName = \"Orders Qry\"\n    \n    \/\/\/ The number of columns the `Orders Qry` table has.\n    public static let columnCount : Int32 = 20\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Orders Qry` table.\n    public static let select = #\"SELECT \"OrderID\", \"CustomerID\", \"EmployeeID\", \"OrderDate\", \"RequiredDate\", \"ShippedDate\", \"ShipVia\", \"Freight\", \"ShipName\", \"ShipAddress\", \"ShipCity\", \"ShipRegion\", \"ShipPostalCode\", \"ShipCountry\", \"CompanyName\", \"Address\", \"City\", \"Region\", \"PostalCode\", \"Country\" FROM \"Orders Qry\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"OrderID\", \"CustomerID\", \"EmployeeID\", \"OrderDate\", \"RequiredDate\", \"ShippedDate\", \"ShipVia\", \"Freight\", \"ShipName\", \"ShipAddress\", \"ShipCity\", \"ShipRegion\", \"ShipPostalCode\", \"ShipCountry\", \"CompanyName\", \"Address\", \"City\", \"Region\", \"PostalCode\", \"Country\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Orders Qry_id FROM Orders Qry`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Orders Qry_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"OrderID\") == 0 {\n          indices.idx_orderID = i\n        }\n        else if strcmp(col!, \"CustomerID\") == 0 {\n          indices.idx_customerID = i\n        }\n        else if strcmp(col!, \"EmployeeID\") == 0 {\n          indices.idx_employeeID = i\n        }\n        else if strcmp(col!, \"OrderDate\") == 0 {\n          indices.idx_orderDate = i\n        }\n        else if strcmp(col!, \"RequiredDate\") == 0 {\n          indices.idx_requiredDate = i\n        }\n        else if strcmp(col!, \"ShippedDate\") == 0 {\n          indices.idx_shippedDate = i\n        }\n        else if strcmp(col!, \"ShipVia\") == 0 {\n          indices.idx_shipVia = i\n        }\n        else if strcmp(col!, \"Freight\") == 0 {\n          indices.idx_freight = i\n        }\n        else if strcmp(col!, \"ShipName\") == 0 {\n          indices.idx_shipName = i\n        }\n        else if strcmp(col!, \"ShipAddress\") == 0 {\n          indices.idx_shipAddress = i\n        }\n        else if strcmp(col!, \"ShipCity\") == 0 {\n          indices.idx_shipCity = i\n        }\n        else if strcmp(col!, \"ShipRegion\") == 0 {\n          indices.idx_shipRegion = i\n        }\n        else if strcmp(col!, \"ShipPostalCode\") == 0 {\n          indices.idx_shipPostalCode = i\n        }\n        else if strcmp(col!, \"ShipCountry\") == 0 {\n          indices.idx_shipCountry = i\n        }\n        else if strcmp(col!, \"CompanyName\") == 0 {\n          indices.idx_companyName = i\n        }\n        else if strcmp(col!, \"Address\") == 0 {\n          indices.idx_address = i\n        }\n        else if strcmp(col!, \"City\") == 0 {\n          indices.idx_city = i\n        }\n        else if strcmp(col!, \"Region\") == 0 {\n          indices.idx_region = i\n        }\n        else if strcmp(col!, \"PostalCode\") == 0 {\n          indices.idx_postalCode = i\n        }\n        else if strcmp(col!, \"Country\") == 0 {\n          indices.idx_country = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``OrdersQry\/orderID`` (`OrderID` column).\n    public let orderID = MappedColumn<NorthwindLighter.OrdersQry, Int?>(\n      externalName: \"OrderID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.orderID\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/customerID`` (`CustomerID` column).\n    public let customerID = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"CustomerID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.customerID\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/employeeID`` (`EmployeeID` column).\n    public let employeeID = MappedColumn<NorthwindLighter.OrdersQry, Int?>(\n      externalName: \"EmployeeID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.employeeID\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/orderDate`` (`OrderDate` column).\n    public let orderDate = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"OrderDate\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.orderDate\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/requiredDate`` (`RequiredDate` column).\n    public let requiredDate = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"RequiredDate\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.requiredDate\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/shippedDate`` (`ShippedDate` column).\n    public let shippedDate = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"ShippedDate\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.shippedDate\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/shipVia`` (`ShipVia` column).\n    public let shipVia = MappedColumn<NorthwindLighter.OrdersQry, Int?>(\n      externalName: \"ShipVia\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.shipVia\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/freight`` (`Freight` column).\n    public let freight = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"Freight\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.freight\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/shipName`` (`ShipName` column).\n    public let shipName = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"ShipName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.shipName\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/shipAddress`` (`ShipAddress` column).\n    public let shipAddress = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"ShipAddress\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.shipAddress\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/shipCity`` (`ShipCity` column).\n    public let shipCity = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"ShipCity\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.shipCity\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/shipRegion`` (`ShipRegion` column).\n    public let shipRegion = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"ShipRegion\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.shipRegion\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/shipPostalCode`` (`ShipPostalCode` column).\n    public let shipPostalCode = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"ShipPostalCode\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.shipPostalCode\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/shipCountry`` (`ShipCountry` column).\n    public let shipCountry = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"ShipCountry\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.shipCountry\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/companyName`` (`CompanyName` column).\n    public let companyName = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"CompanyName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.companyName\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/address`` (`Address` column).\n    public let address = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"Address\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.address\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/city`` (`City` column).\n    public let city = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"City\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.city\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/region`` (`Region` column).\n    public let region = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"Region\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.region\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/postalCode`` (`PostalCode` column).\n    public let postalCode = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"PostalCode\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.postalCode\n    )\n    \n    \/\/\/ Type information for property ``OrdersQry\/country`` (`Country` column).\n    public let country = MappedColumn<NorthwindLighter.OrdersQry, String?>(\n      externalName: \"Country\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrdersQry.country\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ orderID, customerID, employeeID, orderDate, requiredDate, shippedDate, shipVia, freight, shipName, shipAddress, shipCity, shipRegion, shipPostalCode, shipCountry, companyName, address, city, region, postalCode, country ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``OrdersQry`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Orders Qry\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = OrdersQry(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      orderID: (indices.idx_orderID >= 0) && (indices.idx_orderID < argc) ? (sqlite3_column_type(statement, indices.idx_orderID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_orderID)) : nil) : Self.schema.orderID.defaultValue,\n      customerID: (indices.idx_customerID >= 0) && (indices.idx_customerID < argc) ? (sqlite3_column_text(statement, indices.idx_customerID).flatMap(String.init(cString:))) : Self.schema.customerID.defaultValue,\n      employeeID: (indices.idx_employeeID >= 0) && (indices.idx_employeeID < argc) ? (sqlite3_column_type(statement, indices.idx_employeeID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_employeeID)) : nil) : Self.schema.employeeID.defaultValue,\n      orderDate: (indices.idx_orderDate >= 0) && (indices.idx_orderDate < argc) ? (sqlite3_column_text(statement, indices.idx_orderDate).flatMap(String.init(cString:))) : Self.schema.orderDate.defaultValue,\n      requiredDate: (indices.idx_requiredDate >= 0) && (indices.idx_requiredDate < argc) ? (sqlite3_column_text(statement, indices.idx_requiredDate).flatMap(String.init(cString:))) : Self.schema.requiredDate.defaultValue,\n      shippedDate: (indices.idx_shippedDate >= 0) && (indices.idx_shippedDate < argc) ? (sqlite3_column_text(statement, indices.idx_shippedDate).flatMap(String.init(cString:))) : Self.schema.shippedDate.defaultValue,\n      shipVia: (indices.idx_shipVia >= 0) && (indices.idx_shipVia < argc) ? (sqlite3_column_type(statement, indices.idx_shipVia) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_shipVia)) : nil) : Self.schema.shipVia.defaultValue,\n      freight: (indices.idx_freight >= 0) && (indices.idx_freight < argc) ? (sqlite3_column_text(statement, indices.idx_freight).flatMap(String.init(cString:))) : Self.schema.freight.defaultValue,\n      shipName: (indices.idx_shipName >= 0) && (indices.idx_shipName < argc) ? (sqlite3_column_text(statement, indices.idx_shipName).flatMap(String.init(cString:))) : Self.schema.shipName.defaultValue,\n      shipAddress: (indices.idx_shipAddress >= 0) && (indices.idx_shipAddress < argc) ? (sqlite3_column_text(statement, indices.idx_shipAddress).flatMap(String.init(cString:))) : Self.schema.shipAddress.defaultValue,\n      shipCity: (indices.idx_shipCity >= 0) && (indices.idx_shipCity < argc) ? (sqlite3_column_text(statement, indices.idx_shipCity).flatMap(String.init(cString:))) : Self.schema.shipCity.defaultValue,\n      shipRegion: (indices.idx_shipRegion >= 0) && (indices.idx_shipRegion < argc) ? (sqlite3_column_text(statement, indices.idx_shipRegion).flatMap(String.init(cString:))) : Self.schema.shipRegion.defaultValue,\n      shipPostalCode: (indices.idx_shipPostalCode >= 0) && (indices.idx_shipPostalCode < argc) ? (sqlite3_column_text(statement, indices.idx_shipPostalCode).flatMap(String.init(cString:))) : Self.schema.shipPostalCode.defaultValue,\n      shipCountry: (indices.idx_shipCountry >= 0) && (indices.idx_shipCountry < argc) ? (sqlite3_column_text(statement, indices.idx_shipCountry).flatMap(String.init(cString:))) : Self.schema.shipCountry.defaultValue,\n      companyName: (indices.idx_companyName >= 0) && (indices.idx_companyName < argc) ? (sqlite3_column_text(statement, indices.idx_companyName).flatMap(String.init(cString:))) : Self.schema.companyName.defaultValue,\n      address: (indices.idx_address >= 0) && (indices.idx_address < argc) ? (sqlite3_column_text(statement, indices.idx_address).flatMap(String.init(cString:))) : Self.schema.address.defaultValue,\n      city: (indices.idx_city >= 0) && (indices.idx_city < argc) ? (sqlite3_column_text(statement, indices.idx_city).flatMap(String.init(cString:))) : Self.schema.city.defaultValue,\n      region: (indices.idx_region >= 0) && (indices.idx_region < argc) ? (sqlite3_column_text(statement, indices.idx_region).flatMap(String.init(cString:))) : Self.schema.region.defaultValue,\n      postalCode: (indices.idx_postalCode >= 0) && (indices.idx_postalCode < argc) ? (sqlite3_column_text(statement, indices.idx_postalCode).flatMap(String.init(cString:))) : Self.schema.postalCode.defaultValue,\n      country: (indices.idx_country >= 0) && (indices.idx_country < argc) ? (sqlite3_column_text(statement, indices.idx_country).flatMap(String.init(cString:))) : Self.schema.country.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``OrdersQry`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Orders Qry SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = OrdersQry(orderID: 1, customerID: \"Hello\", employeeID: 2, orderDate: nil)\n   * let ok = record.bind(to: statement, indices: ( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_orderID >= 0 {\n      if let orderID = orderID {\n        sqlite3_bind_int64(statement, indices.idx_orderID, Int64(orderID))\n      }\n      else {\n        sqlite3_bind_null(statement, indices.idx_orderID)\n      }\n    }\n    return try NorthwindLighter.withOptCString(customerID) { ( s ) in\n      if indices.idx_customerID >= 0 {\n        sqlite3_bind_text(statement, indices.idx_customerID, s, -1, nil)\n      }\n      if indices.idx_employeeID >= 0 {\n        if let employeeID = employeeID {\n          sqlite3_bind_int64(statement, indices.idx_employeeID, Int64(employeeID))\n        }\n        else {\n          sqlite3_bind_null(statement, indices.idx_employeeID)\n        }\n      }\n      return try NorthwindLighter.withOptCString(orderDate) { ( s ) in\n        if indices.idx_orderDate >= 0 {\n          sqlite3_bind_text(statement, indices.idx_orderDate, s, -1, nil)\n        }\n        return try NorthwindLighter.withOptCString(requiredDate) { ( s ) in\n          if indices.idx_requiredDate >= 0 {\n            sqlite3_bind_text(statement, indices.idx_requiredDate, s, -1, nil)\n          }\n          return try NorthwindLighter.withOptCString(shippedDate) { ( s ) in\n            if indices.idx_shippedDate >= 0 {\n              sqlite3_bind_text(statement, indices.idx_shippedDate, s, -1, nil)\n            }\n            if indices.idx_shipVia >= 0 {\n              if let shipVia = shipVia {\n                sqlite3_bind_int64(statement, indices.idx_shipVia, Int64(shipVia))\n              }\n              else {\n                sqlite3_bind_null(statement, indices.idx_shipVia)\n              }\n            }\n            return try NorthwindLighter.withOptCString(freight) { ( s ) in\n              if indices.idx_freight >= 0 {\n                sqlite3_bind_text(statement, indices.idx_freight, s, -1, nil)\n              }\n              return try NorthwindLighter.withOptCString(shipName) { ( s ) in\n                if indices.idx_shipName >= 0 {\n                  sqlite3_bind_text(statement, indices.idx_shipName, s, -1, nil)\n                }\n                return try NorthwindLighter.withOptCString(shipAddress) { ( s ) in\n                  if indices.idx_shipAddress >= 0 {\n                    sqlite3_bind_text(statement, indices.idx_shipAddress, s, -1, nil)\n                  }\n                  return try NorthwindLighter.withOptCString(shipCity) { ( s ) in\n                    if indices.idx_shipCity >= 0 {\n                      sqlite3_bind_text(statement, indices.idx_shipCity, s, -1, nil)\n                    }\n                    return try NorthwindLighter.withOptCString(shipRegion) { ( s ) in\n                      if indices.idx_shipRegion >= 0 {\n                        sqlite3_bind_text(statement, indices.idx_shipRegion, s, -1, nil)\n                      }\n                      return try NorthwindLighter.withOptCString(shipPostalCode) { ( s ) in\n                        if indices.idx_shipPostalCode >= 0 {\n                          sqlite3_bind_text(statement, indices.idx_shipPostalCode, s, -1, nil)\n                        }\n                        return try NorthwindLighter.withOptCString(shipCountry) { ( s ) in\n                          if indices.idx_shipCountry >= 0 {\n                            sqlite3_bind_text(statement, indices.idx_shipCountry, s, -1, nil)\n                          }\n                          return try NorthwindLighter.withOptCString(companyName) { ( s ) in\n                            if indices.idx_companyName >= 0 {\n                              sqlite3_bind_text(statement, indices.idx_companyName, s, -1, nil)\n                            }\n                            return try NorthwindLighter.withOptCString(address) { ( s ) in\n                              if indices.idx_address >= 0 {\n                                sqlite3_bind_text(statement, indices.idx_address, s, -1, nil)\n                              }\n                              return try NorthwindLighter.withOptCString(city) { ( s ) in\n                                if indices.idx_city >= 0 {\n                                  sqlite3_bind_text(statement, indices.idx_city, s, -1, nil)\n                                }\n                                return try NorthwindLighter.withOptCString(region) { ( s ) in\n                                  if indices.idx_region >= 0 {\n                                    sqlite3_bind_text(statement, indices.idx_region, s, -1, nil)\n                                  }\n                                  return try NorthwindLighter.withOptCString(postalCode) { ( s ) in\n                                    if indices.idx_postalCode >= 0 {\n                                      sqlite3_bind_text(statement, indices.idx_postalCode, s, -1, nil)\n                                    }\n                                    return try NorthwindLighter.withOptCString(country) { ( s ) in\n                                      if indices.idx_country >= 0 {\n                                        sqlite3_bind_text(statement, indices.idx_country, s, -1, nil)\n                                      }\n                                      return try execute()\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.OrderSubtotal {\n  \n  \/**\n   * Static type information for the ``OrderSubtotal`` record (`Order Subtotals` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_orderID: Int32, idx_subtotal: Int32 )\n    public typealias RecordType = NorthwindLighter.OrderSubtotal\n    \n    \/\/\/ The SQL table name associated with the ``OrderSubtotal`` record.\n    public static let externalName = \"Order Subtotals\"\n    \n    \/\/\/ The number of columns the `Order Subtotals` table has.\n    public static let columnCount : Int32 = 2\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Order Subtotals` table.\n    public static let select = #\"SELECT \"OrderID\", \"Subtotal\" FROM \"Order Subtotals\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"OrderID\", \"Subtotal\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Order Subtotals_id FROM Order Subtotals`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Order Subtotals_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"OrderID\") == 0 {\n          indices.idx_orderID = i\n        }\n        else if strcmp(col!, \"Subtotal\") == 0 {\n          indices.idx_subtotal = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``OrderSubtotal\/orderID`` (`OrderID` column).\n    public let orderID = MappedColumn<NorthwindLighter.OrderSubtotal, Int?>(\n      externalName: \"OrderID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrderSubtotal.orderID\n    )\n    \n    \/\/\/ Type information for property ``OrderSubtotal\/subtotal`` (`Subtotal` column).\n    public let subtotal = MappedColumn<NorthwindLighter.OrderSubtotal, String?>(\n      externalName: \"Subtotal\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrderSubtotal.subtotal\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ orderID, subtotal ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``OrderSubtotal`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Order Subtotals\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = OrderSubtotal(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      orderID: (indices.idx_orderID >= 0) && (indices.idx_orderID < argc) ? (sqlite3_column_type(statement, indices.idx_orderID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_orderID)) : nil) : Self.schema.orderID.defaultValue,\n      subtotal: (indices.idx_subtotal >= 0) && (indices.idx_subtotal < argc) ? (sqlite3_column_text(statement, indices.idx_subtotal).flatMap(String.init(cString:))) : Self.schema.subtotal.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``OrderSubtotal`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Order Subtotals SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = OrderSubtotal(orderID: 1, subtotal: \"Hello\")\n   * let ok = record.bind(to: statement, indices: ( 1, 2 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_orderID >= 0 {\n      if let orderID = orderID {\n        sqlite3_bind_int64(statement, indices.idx_orderID, Int64(orderID))\n      }\n      else {\n        sqlite3_bind_null(statement, indices.idx_orderID)\n      }\n    }\n    return try NorthwindLighter.withOptCString(subtotal) { ( s ) in\n      if indices.idx_subtotal >= 0 {\n        sqlite3_bind_text(statement, indices.idx_subtotal, s, -1, nil)\n      }\n      return try execute()\n    }\n  }\n}\n\npublic extension NorthwindLighter.ProductSalesFor1997 {\n  \n  \/**\n   * Static type information for the ``ProductSalesFor1997`` record (`Product Sales for 1997` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_categoryName: Int32, idx_productName: Int32, idx_productSales: Int32 )\n    public typealias RecordType = NorthwindLighter.ProductSalesFor1997\n    \n    \/\/\/ The SQL table name associated with the ``ProductSalesFor1997`` record.\n    public static let externalName = \"Product Sales for 1997\"\n    \n    \/\/\/ The number of columns the `Product Sales for 1997` table has.\n    public static let columnCount : Int32 = 3\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Product Sales for 1997` table.\n    public static let select = #\"SELECT \"CategoryName\", \"ProductName\", \"ProductSales\" FROM \"Product Sales for 1997\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"CategoryName\", \"ProductName\", \"ProductSales\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Product Sales for 1997_id FROM Product Sales for 1997`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Product Sales for 1997_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"CategoryName\") == 0 {\n          indices.idx_categoryName = i\n        }\n        else if strcmp(col!, \"ProductName\") == 0 {\n          indices.idx_productName = i\n        }\n        else if strcmp(col!, \"ProductSales\") == 0 {\n          indices.idx_productSales = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``ProductSalesFor1997\/categoryName`` (`CategoryName` column).\n    public let categoryName = MappedColumn<NorthwindLighter.ProductSalesFor1997, String?>(\n      externalName: \"CategoryName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.ProductSalesFor1997.categoryName\n    )\n    \n    \/\/\/ Type information for property ``ProductSalesFor1997\/productName`` (`ProductName` column).\n    public let productName = MappedColumn<NorthwindLighter.ProductSalesFor1997, String?>(\n      externalName: \"ProductName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.ProductSalesFor1997.productName\n    )\n    \n    \/\/\/ Type information for property ``ProductSalesFor1997\/productSales`` (`ProductSales` column).\n    public let productSales = MappedColumn<NorthwindLighter.ProductSalesFor1997, String?>(\n      externalName: \"ProductSales\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.ProductSalesFor1997.productSales\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ categoryName, productName, productSales ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``ProductSalesFor1997`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Product Sales for 1997\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = ProductSalesFor1997(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      categoryName: (indices.idx_categoryName >= 0) && (indices.idx_categoryName < argc) ? (sqlite3_column_text(statement, indices.idx_categoryName).flatMap(String.init(cString:))) : Self.schema.categoryName.defaultValue,\n      productName: (indices.idx_productName >= 0) && (indices.idx_productName < argc) ? (sqlite3_column_text(statement, indices.idx_productName).flatMap(String.init(cString:))) : Self.schema.productName.defaultValue,\n      productSales: (indices.idx_productSales >= 0) && (indices.idx_productSales < argc) ? (sqlite3_column_text(statement, indices.idx_productSales).flatMap(String.init(cString:))) : Self.schema.productSales.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``ProductSalesFor1997`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Product Sales for 1997 SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = ProductSalesFor1997(categoryName: \"Hello\", productName: \"World\", productSales: \"Duck\")\n   * let ok = record.bind(to: statement, indices: ( 1, 2, 3 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    return try NorthwindLighter.withOptCString(categoryName) { ( s ) in\n      if indices.idx_categoryName >= 0 {\n        sqlite3_bind_text(statement, indices.idx_categoryName, s, -1, nil)\n      }\n      return try NorthwindLighter.withOptCString(productName) { ( s ) in\n        if indices.idx_productName >= 0 {\n          sqlite3_bind_text(statement, indices.idx_productName, s, -1, nil)\n        }\n        return try NorthwindLighter.withOptCString(productSales) { ( s ) in\n          if indices.idx_productSales >= 0 {\n            sqlite3_bind_text(statement, indices.idx_productSales, s, -1, nil)\n          }\n          return try execute()\n        }\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.ProductsAboveAveragePrice {\n  \n  \/**\n   * Static type information for the ``ProductsAboveAveragePrice`` record (`Products Above Average Price` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_productName: Int32, idx_unitPrice: Int32 )\n    public typealias RecordType = NorthwindLighter.ProductsAboveAveragePrice\n    \n    \/\/\/ The SQL table name associated with the ``ProductsAboveAveragePrice`` record.\n    public static let externalName = \"Products Above Average Price\"\n    \n    \/\/\/ The number of columns the `Products Above Average Price` table has.\n    public static let columnCount : Int32 = 2\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Products Above Average Price` table.\n    public static let select = #\"SELECT \"ProductName\", \"UnitPrice\" FROM \"Products Above Average Price\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"ProductName\", \"UnitPrice\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Products Above Average Price_id FROM Products Above Average Price`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Products Above Average Price_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"ProductName\") == 0 {\n          indices.idx_productName = i\n        }\n        else if strcmp(col!, \"UnitPrice\") == 0 {\n          indices.idx_unitPrice = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``ProductsAboveAveragePrice\/productName`` (`ProductName` column).\n    public let productName = MappedColumn<NorthwindLighter.ProductsAboveAveragePrice, String?>(\n      externalName: \"ProductName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.ProductsAboveAveragePrice.productName\n    )\n    \n    \/\/\/ Type information for property ``ProductsAboveAveragePrice\/unitPrice`` (`UnitPrice` column).\n    public let unitPrice = MappedColumn<NorthwindLighter.ProductsAboveAveragePrice, String?>(\n      externalName: \"UnitPrice\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.ProductsAboveAveragePrice.unitPrice\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ productName, unitPrice ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``ProductsAboveAveragePrice`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Products Above Average Price\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = ProductsAboveAveragePrice(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      productName: (indices.idx_productName >= 0) && (indices.idx_productName < argc) ? (sqlite3_column_text(statement, indices.idx_productName).flatMap(String.init(cString:))) : Self.schema.productName.defaultValue,\n      unitPrice: (indices.idx_unitPrice >= 0) && (indices.idx_unitPrice < argc) ? (sqlite3_column_text(statement, indices.idx_unitPrice).flatMap(String.init(cString:))) : Self.schema.unitPrice.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``ProductsAboveAveragePrice`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Products Above Average Price SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = ProductsAboveAveragePrice(productName: \"Hello\", unitPrice: \"World\")\n   * let ok = record.bind(to: statement, indices: ( 1, 2 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    return try NorthwindLighter.withOptCString(productName) { ( s ) in\n      if indices.idx_productName >= 0 {\n        sqlite3_bind_text(statement, indices.idx_productName, s, -1, nil)\n      }\n      return try NorthwindLighter.withOptCString(unitPrice) { ( s ) in\n        if indices.idx_unitPrice >= 0 {\n          sqlite3_bind_text(statement, indices.idx_unitPrice, s, -1, nil)\n        }\n        return try execute()\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.ProductsByCategory {\n  \n  \/**\n   * Static type information for the ``ProductsByCategory`` record (`Products by Category` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_categoryName: Int32, idx_productName: Int32, idx_quantityPerUnit: Int32, idx_unitsInStock: Int32, idx_discontinued: Int32 )\n    public typealias RecordType = NorthwindLighter.ProductsByCategory\n    \n    \/\/\/ The SQL table name associated with the ``ProductsByCategory`` record.\n    public static let externalName = \"Products by Category\"\n    \n    \/\/\/ The number of columns the `Products by Category` table has.\n    public static let columnCount : Int32 = 5\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Products by Category` table.\n    public static let select = #\"SELECT \"CategoryName\", \"ProductName\", \"QuantityPerUnit\", \"UnitsInStock\", \"Discontinued\" FROM \"Products by Category\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"CategoryName\", \"ProductName\", \"QuantityPerUnit\", \"UnitsInStock\", \"Discontinued\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3, 4 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Products by Category_id FROM Products by Category`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Products by Category_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"CategoryName\") == 0 {\n          indices.idx_categoryName = i\n        }\n        else if strcmp(col!, \"ProductName\") == 0 {\n          indices.idx_productName = i\n        }\n        else if strcmp(col!, \"QuantityPerUnit\") == 0 {\n          indices.idx_quantityPerUnit = i\n        }\n        else if strcmp(col!, \"UnitsInStock\") == 0 {\n          indices.idx_unitsInStock = i\n        }\n        else if strcmp(col!, \"Discontinued\") == 0 {\n          indices.idx_discontinued = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``ProductsByCategory\/categoryName`` (`CategoryName` column).\n    public let categoryName = MappedColumn<NorthwindLighter.ProductsByCategory, String?>(\n      externalName: \"CategoryName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.ProductsByCategory.categoryName\n    )\n    \n    \/\/\/ Type information for property ``ProductsByCategory\/productName`` (`ProductName` column).\n    public let productName = MappedColumn<NorthwindLighter.ProductsByCategory, String?>(\n      externalName: \"ProductName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.ProductsByCategory.productName\n    )\n    \n    \/\/\/ Type information for property ``ProductsByCategory\/quantityPerUnit`` (`QuantityPerUnit` column).\n    public let quantityPerUnit = MappedColumn<NorthwindLighter.ProductsByCategory, String?>(\n      externalName: \"QuantityPerUnit\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.ProductsByCategory.quantityPerUnit\n    )\n    \n    \/\/\/ Type information for property ``ProductsByCategory\/unitsInStock`` (`UnitsInStock` column).\n    public let unitsInStock = MappedColumn<NorthwindLighter.ProductsByCategory, Int?>(\n      externalName: \"UnitsInStock\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.ProductsByCategory.unitsInStock\n    )\n    \n    \/\/\/ Type information for property ``ProductsByCategory\/discontinued`` (`Discontinued` column).\n    public let discontinued = MappedColumn<NorthwindLighter.ProductsByCategory, String?>(\n      externalName: \"Discontinued\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.ProductsByCategory.discontinued\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ categoryName, productName, quantityPerUnit, unitsInStock, discontinued ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``ProductsByCategory`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Products by Category\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = ProductsByCategory(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      categoryName: (indices.idx_categoryName >= 0) && (indices.idx_categoryName < argc) ? (sqlite3_column_text(statement, indices.idx_categoryName).flatMap(String.init(cString:))) : Self.schema.categoryName.defaultValue,\n      productName: (indices.idx_productName >= 0) && (indices.idx_productName < argc) ? (sqlite3_column_text(statement, indices.idx_productName).flatMap(String.init(cString:))) : Self.schema.productName.defaultValue,\n      quantityPerUnit: (indices.idx_quantityPerUnit >= 0) && (indices.idx_quantityPerUnit < argc) ? (sqlite3_column_text(statement, indices.idx_quantityPerUnit).flatMap(String.init(cString:))) : Self.schema.quantityPerUnit.defaultValue,\n      unitsInStock: (indices.idx_unitsInStock >= 0) && (indices.idx_unitsInStock < argc) ? (sqlite3_column_type(statement, indices.idx_unitsInStock) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_unitsInStock)) : nil) : Self.schema.unitsInStock.defaultValue,\n      discontinued: (indices.idx_discontinued >= 0) && (indices.idx_discontinued < argc) ? (sqlite3_column_text(statement, indices.idx_discontinued).flatMap(String.init(cString:))) : Self.schema.discontinued.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``ProductsByCategory`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Products by Category SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = ProductsByCategory(categoryName: \"Hello\", productName: \"World\", quantityPerUnit: \"Duck\", unitsInStock: 1)\n   * let ok = record.bind(to: statement, indices: ( 1, 2, 3, 4, 5 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    return try NorthwindLighter.withOptCString(categoryName) { ( s ) in\n      if indices.idx_categoryName >= 0 {\n        sqlite3_bind_text(statement, indices.idx_categoryName, s, -1, nil)\n      }\n      return try NorthwindLighter.withOptCString(productName) { ( s ) in\n        if indices.idx_productName >= 0 {\n          sqlite3_bind_text(statement, indices.idx_productName, s, -1, nil)\n        }\n        return try NorthwindLighter.withOptCString(quantityPerUnit) { ( s ) in\n          if indices.idx_quantityPerUnit >= 0 {\n            sqlite3_bind_text(statement, indices.idx_quantityPerUnit, s, -1, nil)\n          }\n          if indices.idx_unitsInStock >= 0 {\n            if let unitsInStock = unitsInStock {\n              sqlite3_bind_int64(statement, indices.idx_unitsInStock, Int64(unitsInStock))\n            }\n            else {\n              sqlite3_bind_null(statement, indices.idx_unitsInStock)\n            }\n          }\n          return try NorthwindLighter.withOptCString(discontinued) { ( s ) in\n            if indices.idx_discontinued >= 0 {\n              sqlite3_bind_text(statement, indices.idx_discontinued, s, -1, nil)\n            }\n            return try execute()\n          }\n        }\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.QuarterlyOrder {\n  \n  \/**\n   * Static type information for the ``QuarterlyOrder`` record (`Quarterly Orders` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_customerID: Int32, idx_companyName: Int32, idx_city: Int32, idx_country: Int32 )\n    public typealias RecordType = NorthwindLighter.QuarterlyOrder\n    \n    \/\/\/ The SQL table name associated with the ``QuarterlyOrder`` record.\n    public static let externalName = \"Quarterly Orders\"\n    \n    \/\/\/ The number of columns the `Quarterly Orders` table has.\n    public static let columnCount : Int32 = 4\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Quarterly Orders` table.\n    public static let select = #\"SELECT \"CustomerID\", \"CompanyName\", \"City\", \"Country\" FROM \"Quarterly Orders\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"CustomerID\", \"CompanyName\", \"City\", \"Country\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Quarterly Orders_id FROM Quarterly Orders`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Quarterly Orders_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"CustomerID\") == 0 {\n          indices.idx_customerID = i\n        }\n        else if strcmp(col!, \"CompanyName\") == 0 {\n          indices.idx_companyName = i\n        }\n        else if strcmp(col!, \"City\") == 0 {\n          indices.idx_city = i\n        }\n        else if strcmp(col!, \"Country\") == 0 {\n          indices.idx_country = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``QuarterlyOrder\/customerID`` (`CustomerID` column).\n    public let customerID = MappedColumn<NorthwindLighter.QuarterlyOrder, String?>(\n      externalName: \"CustomerID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.QuarterlyOrder.customerID\n    )\n    \n    \/\/\/ Type information for property ``QuarterlyOrder\/companyName`` (`CompanyName` column).\n    public let companyName = MappedColumn<NorthwindLighter.QuarterlyOrder, String?>(\n      externalName: \"CompanyName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.QuarterlyOrder.companyName\n    )\n    \n    \/\/\/ Type information for property ``QuarterlyOrder\/city`` (`City` column).\n    public let city = MappedColumn<NorthwindLighter.QuarterlyOrder, String?>(\n      externalName: \"City\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.QuarterlyOrder.city\n    )\n    \n    \/\/\/ Type information for property ``QuarterlyOrder\/country`` (`Country` column).\n    public let country = MappedColumn<NorthwindLighter.QuarterlyOrder, String?>(\n      externalName: \"Country\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.QuarterlyOrder.country\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ customerID, companyName, city, country ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``QuarterlyOrder`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Quarterly Orders\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = QuarterlyOrder(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      customerID: (indices.idx_customerID >= 0) && (indices.idx_customerID < argc) ? (sqlite3_column_text(statement, indices.idx_customerID).flatMap(String.init(cString:))) : Self.schema.customerID.defaultValue,\n      companyName: (indices.idx_companyName >= 0) && (indices.idx_companyName < argc) ? (sqlite3_column_text(statement, indices.idx_companyName).flatMap(String.init(cString:))) : Self.schema.companyName.defaultValue,\n      city: (indices.idx_city >= 0) && (indices.idx_city < argc) ? (sqlite3_column_text(statement, indices.idx_city).flatMap(String.init(cString:))) : Self.schema.city.defaultValue,\n      country: (indices.idx_country >= 0) && (indices.idx_country < argc) ? (sqlite3_column_text(statement, indices.idx_country).flatMap(String.init(cString:))) : Self.schema.country.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``QuarterlyOrder`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Quarterly Orders SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = QuarterlyOrder(customerID: \"Hello\", companyName: \"World\", city: \"Duck\", country: \"Donald\")\n   * let ok = record.bind(to: statement, indices: ( 1, 2, 3, 4 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    return try NorthwindLighter.withOptCString(customerID) { ( s ) in\n      if indices.idx_customerID >= 0 {\n        sqlite3_bind_text(statement, indices.idx_customerID, s, -1, nil)\n      }\n      return try NorthwindLighter.withOptCString(companyName) { ( s ) in\n        if indices.idx_companyName >= 0 {\n          sqlite3_bind_text(statement, indices.idx_companyName, s, -1, nil)\n        }\n        return try NorthwindLighter.withOptCString(city) { ( s ) in\n          if indices.idx_city >= 0 {\n            sqlite3_bind_text(statement, indices.idx_city, s, -1, nil)\n          }\n          return try NorthwindLighter.withOptCString(country) { ( s ) in\n            if indices.idx_country >= 0 {\n              sqlite3_bind_text(statement, indices.idx_country, s, -1, nil)\n            }\n            return try execute()\n          }\n        }\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.SalesTotalsByAmount {\n  \n  \/**\n   * Static type information for the ``SalesTotalsByAmount`` record (`Sales Totals by Amount` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_saleAmount: Int32, idx_orderID: Int32, idx_companyName: Int32, idx_shippedDate: Int32 )\n    public typealias RecordType = NorthwindLighter.SalesTotalsByAmount\n    \n    \/\/\/ The SQL table name associated with the ``SalesTotalsByAmount`` record.\n    public static let externalName = \"Sales Totals by Amount\"\n    \n    \/\/\/ The number of columns the `Sales Totals by Amount` table has.\n    public static let columnCount : Int32 = 4\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Sales Totals by Amount` table.\n    public static let select = #\"SELECT \"SaleAmount\", \"OrderID\", \"CompanyName\", \"ShippedDate\" FROM \"Sales Totals by Amount\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"SaleAmount\", \"OrderID\", \"CompanyName\", \"ShippedDate\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Sales Totals by Amount_id FROM Sales Totals by Amount`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Sales Totals by Amount_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"SaleAmount\") == 0 {\n          indices.idx_saleAmount = i\n        }\n        else if strcmp(col!, \"OrderID\") == 0 {\n          indices.idx_orderID = i\n        }\n        else if strcmp(col!, \"CompanyName\") == 0 {\n          indices.idx_companyName = i\n        }\n        else if strcmp(col!, \"ShippedDate\") == 0 {\n          indices.idx_shippedDate = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``SalesTotalsByAmount\/saleAmount`` (`SaleAmount` column).\n    public let saleAmount = MappedColumn<NorthwindLighter.SalesTotalsByAmount, String?>(\n      externalName: \"SaleAmount\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.SalesTotalsByAmount.saleAmount\n    )\n    \n    \/\/\/ Type information for property ``SalesTotalsByAmount\/orderID`` (`OrderID` column).\n    public let orderID = MappedColumn<NorthwindLighter.SalesTotalsByAmount, Int?>(\n      externalName: \"OrderID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.SalesTotalsByAmount.orderID\n    )\n    \n    \/\/\/ Type information for property ``SalesTotalsByAmount\/companyName`` (`CompanyName` column).\n    public let companyName = MappedColumn<NorthwindLighter.SalesTotalsByAmount, String?>(\n      externalName: \"CompanyName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.SalesTotalsByAmount.companyName\n    )\n    \n    \/\/\/ Type information for property ``SalesTotalsByAmount\/shippedDate`` (`ShippedDate` column).\n    public let shippedDate = MappedColumn<NorthwindLighter.SalesTotalsByAmount, String?>(\n      externalName: \"ShippedDate\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.SalesTotalsByAmount.shippedDate\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ saleAmount, orderID, companyName, shippedDate ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``SalesTotalsByAmount`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Sales Totals by Amount\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = SalesTotalsByAmount(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      saleAmount: (indices.idx_saleAmount >= 0) && (indices.idx_saleAmount < argc) ? (sqlite3_column_text(statement, indices.idx_saleAmount).flatMap(String.init(cString:))) : Self.schema.saleAmount.defaultValue,\n      orderID: (indices.idx_orderID >= 0) && (indices.idx_orderID < argc) ? (sqlite3_column_type(statement, indices.idx_orderID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_orderID)) : nil) : Self.schema.orderID.defaultValue,\n      companyName: (indices.idx_companyName >= 0) && (indices.idx_companyName < argc) ? (sqlite3_column_text(statement, indices.idx_companyName).flatMap(String.init(cString:))) : Self.schema.companyName.defaultValue,\n      shippedDate: (indices.idx_shippedDate >= 0) && (indices.idx_shippedDate < argc) ? (sqlite3_column_text(statement, indices.idx_shippedDate).flatMap(String.init(cString:))) : Self.schema.shippedDate.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``SalesTotalsByAmount`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Sales Totals by Amount SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = SalesTotalsByAmount(saleAmount: \"Hello\", orderID: 1, companyName: \"World\", shippedDate: nil)\n   * let ok = record.bind(to: statement, indices: ( 1, 2, 3, 4 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    return try NorthwindLighter.withOptCString(saleAmount) { ( s ) in\n      if indices.idx_saleAmount >= 0 {\n        sqlite3_bind_text(statement, indices.idx_saleAmount, s, -1, nil)\n      }\n      if indices.idx_orderID >= 0 {\n        if let orderID = orderID {\n          sqlite3_bind_int64(statement, indices.idx_orderID, Int64(orderID))\n        }\n        else {\n          sqlite3_bind_null(statement, indices.idx_orderID)\n        }\n      }\n      return try NorthwindLighter.withOptCString(companyName) { ( s ) in\n        if indices.idx_companyName >= 0 {\n          sqlite3_bind_text(statement, indices.idx_companyName, s, -1, nil)\n        }\n        return try NorthwindLighter.withOptCString(shippedDate) { ( s ) in\n          if indices.idx_shippedDate >= 0 {\n            sqlite3_bind_text(statement, indices.idx_shippedDate, s, -1, nil)\n          }\n          return try execute()\n        }\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.SummaryOfSalesByQuarter {\n  \n  \/**\n   * Static type information for the ``SummaryOfSalesByQuarter`` record (`Summary of Sales by Quarter` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_shippedDate: Int32, idx_orderID: Int32, idx_subtotal: Int32 )\n    public typealias RecordType = NorthwindLighter.SummaryOfSalesByQuarter\n    \n    \/\/\/ The SQL table name associated with the ``SummaryOfSalesByQuarter`` record.\n    public static let externalName = \"Summary of Sales by Quarter\"\n    \n    \/\/\/ The number of columns the `Summary of Sales by Quarter` table has.\n    public static let columnCount : Int32 = 3\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Summary of Sales by Quarter` table.\n    public static let select = #\"SELECT \"ShippedDate\", \"OrderID\", \"Subtotal\" FROM \"Summary of Sales by Quarter\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"ShippedDate\", \"OrderID\", \"Subtotal\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Summary of Sales by Quarter_id FROM Summary of Sales by Quarter`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Summary of Sales by Quarter_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"ShippedDate\") == 0 {\n          indices.idx_shippedDate = i\n        }\n        else if strcmp(col!, \"OrderID\") == 0 {\n          indices.idx_orderID = i\n        }\n        else if strcmp(col!, \"Subtotal\") == 0 {\n          indices.idx_subtotal = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``SummaryOfSalesByQuarter\/shippedDate`` (`ShippedDate` column).\n    public let shippedDate = MappedColumn<NorthwindLighter.SummaryOfSalesByQuarter, String?>(\n      externalName: \"ShippedDate\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.SummaryOfSalesByQuarter.shippedDate\n    )\n    \n    \/\/\/ Type information for property ``SummaryOfSalesByQuarter\/orderID`` (`OrderID` column).\n    public let orderID = MappedColumn<NorthwindLighter.SummaryOfSalesByQuarter, Int?>(\n      externalName: \"OrderID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.SummaryOfSalesByQuarter.orderID\n    )\n    \n    \/\/\/ Type information for property ``SummaryOfSalesByQuarter\/subtotal`` (`Subtotal` column).\n    public let subtotal = MappedColumn<NorthwindLighter.SummaryOfSalesByQuarter, String?>(\n      externalName: \"Subtotal\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.SummaryOfSalesByQuarter.subtotal\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ shippedDate, orderID, subtotal ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``SummaryOfSalesByQuarter`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Summary of Sales by Quarter\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = SummaryOfSalesByQuarter(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      shippedDate: (indices.idx_shippedDate >= 0) && (indices.idx_shippedDate < argc) ? (sqlite3_column_text(statement, indices.idx_shippedDate).flatMap(String.init(cString:))) : Self.schema.shippedDate.defaultValue,\n      orderID: (indices.idx_orderID >= 0) && (indices.idx_orderID < argc) ? (sqlite3_column_type(statement, indices.idx_orderID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_orderID)) : nil) : Self.schema.orderID.defaultValue,\n      subtotal: (indices.idx_subtotal >= 0) && (indices.idx_subtotal < argc) ? (sqlite3_column_text(statement, indices.idx_subtotal).flatMap(String.init(cString:))) : Self.schema.subtotal.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``SummaryOfSalesByQuarter`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Summary of Sales by Quarter SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = SummaryOfSalesByQuarter(shippedDate: nil, orderID: 1, subtotal: \"Hello\")\n   * let ok = record.bind(to: statement, indices: ( 1, 2, 3 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    return try NorthwindLighter.withOptCString(shippedDate) { ( s ) in\n      if indices.idx_shippedDate >= 0 {\n        sqlite3_bind_text(statement, indices.idx_shippedDate, s, -1, nil)\n      }\n      if indices.idx_orderID >= 0 {\n        if let orderID = orderID {\n          sqlite3_bind_int64(statement, indices.idx_orderID, Int64(orderID))\n        }\n        else {\n          sqlite3_bind_null(statement, indices.idx_orderID)\n        }\n      }\n      return try NorthwindLighter.withOptCString(subtotal) { ( s ) in\n        if indices.idx_subtotal >= 0 {\n          sqlite3_bind_text(statement, indices.idx_subtotal, s, -1, nil)\n        }\n        return try execute()\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.SummaryOfSalesByYear {\n  \n  \/**\n   * Static type information for the ``SummaryOfSalesByYear`` record (`Summary of Sales by Year` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_shippedDate: Int32, idx_orderID: Int32, idx_subtotal: Int32 )\n    public typealias RecordType = NorthwindLighter.SummaryOfSalesByYear\n    \n    \/\/\/ The SQL table name associated with the ``SummaryOfSalesByYear`` record.\n    public static let externalName = \"Summary of Sales by Year\"\n    \n    \/\/\/ The number of columns the `Summary of Sales by Year` table has.\n    public static let columnCount : Int32 = 3\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Summary of Sales by Year` table.\n    public static let select = #\"SELECT \"ShippedDate\", \"OrderID\", \"Subtotal\" FROM \"Summary of Sales by Year\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"ShippedDate\", \"OrderID\", \"Subtotal\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Summary of Sales by Year_id FROM Summary of Sales by Year`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Summary of Sales by Year_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"ShippedDate\") == 0 {\n          indices.idx_shippedDate = i\n        }\n        else if strcmp(col!, \"OrderID\") == 0 {\n          indices.idx_orderID = i\n        }\n        else if strcmp(col!, \"Subtotal\") == 0 {\n          indices.idx_subtotal = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``SummaryOfSalesByYear\/shippedDate`` (`ShippedDate` column).\n    public let shippedDate = MappedColumn<NorthwindLighter.SummaryOfSalesByYear, String?>(\n      externalName: \"ShippedDate\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.SummaryOfSalesByYear.shippedDate\n    )\n    \n    \/\/\/ Type information for property ``SummaryOfSalesByYear\/orderID`` (`OrderID` column).\n    public let orderID = MappedColumn<NorthwindLighter.SummaryOfSalesByYear, Int?>(\n      externalName: \"OrderID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.SummaryOfSalesByYear.orderID\n    )\n    \n    \/\/\/ Type information for property ``SummaryOfSalesByYear\/subtotal`` (`Subtotal` column).\n    public let subtotal = MappedColumn<NorthwindLighter.SummaryOfSalesByYear, String?>(\n      externalName: \"Subtotal\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.SummaryOfSalesByYear.subtotal\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ shippedDate, orderID, subtotal ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``SummaryOfSalesByYear`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Summary of Sales by Year\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = SummaryOfSalesByYear(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      shippedDate: (indices.idx_shippedDate >= 0) && (indices.idx_shippedDate < argc) ? (sqlite3_column_text(statement, indices.idx_shippedDate).flatMap(String.init(cString:))) : Self.schema.shippedDate.defaultValue,\n      orderID: (indices.idx_orderID >= 0) && (indices.idx_orderID < argc) ? (sqlite3_column_type(statement, indices.idx_orderID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_orderID)) : nil) : Self.schema.orderID.defaultValue,\n      subtotal: (indices.idx_subtotal >= 0) && (indices.idx_subtotal < argc) ? (sqlite3_column_text(statement, indices.idx_subtotal).flatMap(String.init(cString:))) : Self.schema.subtotal.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``SummaryOfSalesByYear`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Summary of Sales by Year SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = SummaryOfSalesByYear(shippedDate: nil, orderID: 1, subtotal: \"Hello\")\n   * let ok = record.bind(to: statement, indices: ( 1, 2, 3 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    return try NorthwindLighter.withOptCString(shippedDate) { ( s ) in\n      if indices.idx_shippedDate >= 0 {\n        sqlite3_bind_text(statement, indices.idx_shippedDate, s, -1, nil)\n      }\n      if indices.idx_orderID >= 0 {\n        if let orderID = orderID {\n          sqlite3_bind_int64(statement, indices.idx_orderID, Int64(orderID))\n        }\n        else {\n          sqlite3_bind_null(statement, indices.idx_orderID)\n        }\n      }\n      return try NorthwindLighter.withOptCString(subtotal) { ( s ) in\n        if indices.idx_subtotal >= 0 {\n          sqlite3_bind_text(statement, indices.idx_subtotal, s, -1, nil)\n        }\n        return try execute()\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.CategorySalesFor1997 {\n  \n  \/**\n   * Static type information for the ``CategorySalesFor1997`` record (`Category Sales for 1997` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_categoryName: Int32, idx_categorySales: Int32 )\n    public typealias RecordType = NorthwindLighter.CategorySalesFor1997\n    \n    \/\/\/ The SQL table name associated with the ``CategorySalesFor1997`` record.\n    public static let externalName = \"Category Sales for 1997\"\n    \n    \/\/\/ The number of columns the `Category Sales for 1997` table has.\n    public static let columnCount : Int32 = 2\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Category Sales for 1997` table.\n    public static let select = #\"SELECT \"CategoryName\", \"CategorySales\" FROM \"Category Sales for 1997\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"CategoryName\", \"CategorySales\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Category Sales for 1997_id FROM Category Sales for 1997`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Category Sales for 1997_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"CategoryName\") == 0 {\n          indices.idx_categoryName = i\n        }\n        else if strcmp(col!, \"CategorySales\") == 0 {\n          indices.idx_categorySales = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``CategorySalesFor1997\/categoryName`` (`CategoryName` column).\n    public let categoryName = MappedColumn<NorthwindLighter.CategorySalesFor1997, String?>(\n      externalName: \"CategoryName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.CategorySalesFor1997.categoryName\n    )\n    \n    \/\/\/ Type information for property ``CategorySalesFor1997\/categorySales`` (`CategorySales` column).\n    public let categorySales = MappedColumn<NorthwindLighter.CategorySalesFor1997, String?>(\n      externalName: \"CategorySales\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.CategorySalesFor1997.categorySales\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ categoryName, categorySales ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``CategorySalesFor1997`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Category Sales for 1997\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = CategorySalesFor1997(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      categoryName: (indices.idx_categoryName >= 0) && (indices.idx_categoryName < argc) ? (sqlite3_column_text(statement, indices.idx_categoryName).flatMap(String.init(cString:))) : Self.schema.categoryName.defaultValue,\n      categorySales: (indices.idx_categorySales >= 0) && (indices.idx_categorySales < argc) ? (sqlite3_column_text(statement, indices.idx_categorySales).flatMap(String.init(cString:))) : Self.schema.categorySales.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``CategorySalesFor1997`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Category Sales for 1997 SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = CategorySalesFor1997(categoryName: \"Hello\", categorySales: \"World\")\n   * let ok = record.bind(to: statement, indices: ( 1, 2 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    return try NorthwindLighter.withOptCString(categoryName) { ( s ) in\n      if indices.idx_categoryName >= 0 {\n        sqlite3_bind_text(statement, indices.idx_categoryName, s, -1, nil)\n      }\n      return try NorthwindLighter.withOptCString(categorySales) { ( s ) in\n        if indices.idx_categorySales >= 0 {\n          sqlite3_bind_text(statement, indices.idx_categorySales, s, -1, nil)\n        }\n        return try execute()\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.OrderDetailsExtended {\n  \n  \/**\n   * Static type information for the ``OrderDetailsExtended`` record (`Order Details Extended` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_orderID: Int32, idx_productID: Int32, idx_productName: Int32, idx_unitPrice: Int32, idx_quantity: Int32, idx_discount: Int32, idx_extendedPrice: Int32 )\n    public typealias RecordType = NorthwindLighter.OrderDetailsExtended\n    \n    \/\/\/ The SQL table name associated with the ``OrderDetailsExtended`` record.\n    public static let externalName = \"Order Details Extended\"\n    \n    \/\/\/ The number of columns the `Order Details Extended` table has.\n    public static let columnCount : Int32 = 7\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Order Details Extended` table.\n    public static let select = #\"SELECT \"OrderID\", \"ProductID\", \"ProductName\", \"UnitPrice\", \"Quantity\", \"Discount\", \"ExtendedPrice\" FROM \"Order Details Extended\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"OrderID\", \"ProductID\", \"ProductName\", \"UnitPrice\", \"Quantity\", \"Discount\", \"ExtendedPrice\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3, 4, 5, 6 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Order Details Extended_id FROM Order Details Extended`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Order Details Extended_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"OrderID\") == 0 {\n          indices.idx_orderID = i\n        }\n        else if strcmp(col!, \"ProductID\") == 0 {\n          indices.idx_productID = i\n        }\n        else if strcmp(col!, \"ProductName\") == 0 {\n          indices.idx_productName = i\n        }\n        else if strcmp(col!, \"UnitPrice\") == 0 {\n          indices.idx_unitPrice = i\n        }\n        else if strcmp(col!, \"Quantity\") == 0 {\n          indices.idx_quantity = i\n        }\n        else if strcmp(col!, \"Discount\") == 0 {\n          indices.idx_discount = i\n        }\n        else if strcmp(col!, \"ExtendedPrice\") == 0 {\n          indices.idx_extendedPrice = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``OrderDetailsExtended\/orderID`` (`OrderID` column).\n    public let orderID = MappedColumn<NorthwindLighter.OrderDetailsExtended, Int?>(\n      externalName: \"OrderID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrderDetailsExtended.orderID\n    )\n    \n    \/\/\/ Type information for property ``OrderDetailsExtended\/productID`` (`ProductID` column).\n    public let productID = MappedColumn<NorthwindLighter.OrderDetailsExtended, Int?>(\n      externalName: \"ProductID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrderDetailsExtended.productID\n    )\n    \n    \/\/\/ Type information for property ``OrderDetailsExtended\/productName`` (`ProductName` column).\n    public let productName = MappedColumn<NorthwindLighter.OrderDetailsExtended, String?>(\n      externalName: \"ProductName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrderDetailsExtended.productName\n    )\n    \n    \/\/\/ Type information for property ``OrderDetailsExtended\/unitPrice`` (`UnitPrice` column).\n    public let unitPrice = MappedColumn<NorthwindLighter.OrderDetailsExtended, String?>(\n      externalName: \"UnitPrice\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrderDetailsExtended.unitPrice\n    )\n    \n    \/\/\/ Type information for property ``OrderDetailsExtended\/quantity`` (`Quantity` column).\n    public let quantity = MappedColumn<NorthwindLighter.OrderDetailsExtended, Int?>(\n      externalName: \"Quantity\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrderDetailsExtended.quantity\n    )\n    \n    \/\/\/ Type information for property ``OrderDetailsExtended\/discount`` (`Discount` column).\n    public let discount = MappedColumn<NorthwindLighter.OrderDetailsExtended, Double?>(\n      externalName: \"Discount\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrderDetailsExtended.discount\n    )\n    \n    \/\/\/ Type information for property ``OrderDetailsExtended\/extendedPrice`` (`ExtendedPrice` column).\n    public let extendedPrice = MappedColumn<NorthwindLighter.OrderDetailsExtended, String?>(\n      externalName: \"ExtendedPrice\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.OrderDetailsExtended.extendedPrice\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ orderID, productID, productName, unitPrice, quantity, discount, extendedPrice ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``OrderDetailsExtended`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Order Details Extended\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = OrderDetailsExtended(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      orderID: (indices.idx_orderID >= 0) && (indices.idx_orderID < argc) ? (sqlite3_column_type(statement, indices.idx_orderID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_orderID)) : nil) : Self.schema.orderID.defaultValue,\n      productID: (indices.idx_productID >= 0) && (indices.idx_productID < argc) ? (sqlite3_column_type(statement, indices.idx_productID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_productID)) : nil) : Self.schema.productID.defaultValue,\n      productName: (indices.idx_productName >= 0) && (indices.idx_productName < argc) ? (sqlite3_column_text(statement, indices.idx_productName).flatMap(String.init(cString:))) : Self.schema.productName.defaultValue,\n      unitPrice: (indices.idx_unitPrice >= 0) && (indices.idx_unitPrice < argc) ? (sqlite3_column_text(statement, indices.idx_unitPrice).flatMap(String.init(cString:))) : Self.schema.unitPrice.defaultValue,\n      quantity: (indices.idx_quantity >= 0) && (indices.idx_quantity < argc) ? (sqlite3_column_type(statement, indices.idx_quantity) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_quantity)) : nil) : Self.schema.quantity.defaultValue,\n      discount: (indices.idx_discount >= 0) && (indices.idx_discount < argc) ? (sqlite3_column_type(statement, indices.idx_discount) != SQLITE_NULL ? sqlite3_column_double(statement, indices.idx_discount) : nil) : Self.schema.discount.defaultValue,\n      extendedPrice: (indices.idx_extendedPrice >= 0) && (indices.idx_extendedPrice < argc) ? (sqlite3_column_text(statement, indices.idx_extendedPrice).flatMap(String.init(cString:))) : Self.schema.extendedPrice.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``OrderDetailsExtended`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Order Details Extended SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = OrderDetailsExtended(orderID: 1, productID: 2, productName: \"Hello\", unitPrice: \"World\")\n   * let ok = record.bind(to: statement, indices: ( 1, 2, 3, 4, 5, 6, 7 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_orderID >= 0 {\n      if let orderID = orderID {\n        sqlite3_bind_int64(statement, indices.idx_orderID, Int64(orderID))\n      }\n      else {\n        sqlite3_bind_null(statement, indices.idx_orderID)\n      }\n    }\n    if indices.idx_productID >= 0 {\n      if let productID = productID {\n        sqlite3_bind_int64(statement, indices.idx_productID, Int64(productID))\n      }\n      else {\n        sqlite3_bind_null(statement, indices.idx_productID)\n      }\n    }\n    return try NorthwindLighter.withOptCString(productName) { ( s ) in\n      if indices.idx_productName >= 0 {\n        sqlite3_bind_text(statement, indices.idx_productName, s, -1, nil)\n      }\n      return try NorthwindLighter.withOptCString(unitPrice) { ( s ) in\n        if indices.idx_unitPrice >= 0 {\n          sqlite3_bind_text(statement, indices.idx_unitPrice, s, -1, nil)\n        }\n        if indices.idx_quantity >= 0 {\n          if let quantity = quantity {\n            sqlite3_bind_int64(statement, indices.idx_quantity, Int64(quantity))\n          }\n          else {\n            sqlite3_bind_null(statement, indices.idx_quantity)\n          }\n        }\n        if indices.idx_discount >= 0 {\n          if let discount = discount {\n            sqlite3_bind_double(statement, indices.idx_discount, discount)\n          }\n          else {\n            sqlite3_bind_null(statement, indices.idx_discount)\n          }\n        }\n        return try NorthwindLighter.withOptCString(extendedPrice) { ( s ) in\n          if indices.idx_extendedPrice >= 0 {\n            sqlite3_bind_text(statement, indices.idx_extendedPrice, s, -1, nil)\n          }\n          return try execute()\n        }\n      }\n    }\n  }\n}\n\npublic extension NorthwindLighter.SalesByCategory {\n  \n  \/**\n   * Static type information for the ``SalesByCategory`` record (`Sales by Category` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema : SQLViewSchema {\n    \n    public typealias PropertyIndices = ( idx_categoryID: Int32, idx_categoryName: Int32, idx_productName: Int32, idx_productSales: Int32 )\n    public typealias RecordType = NorthwindLighter.SalesByCategory\n    \n    \/\/\/ The SQL table name associated with the ``SalesByCategory`` record.\n    public static let externalName = \"Sales by Category\"\n    \n    \/\/\/ The number of columns the `Sales by Category` table has.\n    public static let columnCount : Int32 = 4\n    \n    \/\/\/ SQL to `SELECT` all columns of the `Sales by Category` table.\n    public static let select = #\"SELECT \"CategoryID\", \"CategoryName\", \"ProductName\", \"ProductSales\" FROM \"Sales by Category\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"CategoryID\", \"CategoryName\", \"ProductName\", \"ProductSales\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, Sales by Category_id FROM Sales by Category`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `Sales by Category_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"CategoryID\") == 0 {\n          indices.idx_categoryID = i\n        }\n        else if strcmp(col!, \"CategoryName\") == 0 {\n          indices.idx_categoryName = i\n        }\n        else if strcmp(col!, \"ProductName\") == 0 {\n          indices.idx_productName = i\n        }\n        else if strcmp(col!, \"ProductSales\") == 0 {\n          indices.idx_productSales = i\n        }\n      }\n      return indices\n    }\n    \n    \/\/\/ Type information for property ``SalesByCategory\/categoryID`` (`CategoryID` column).\n    public let categoryID = MappedColumn<NorthwindLighter.SalesByCategory, Int?>(\n      externalName: \"CategoryID\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.SalesByCategory.categoryID\n    )\n    \n    \/\/\/ Type information for property ``SalesByCategory\/categoryName`` (`CategoryName` column).\n    public let categoryName = MappedColumn<NorthwindLighter.SalesByCategory, String?>(\n      externalName: \"CategoryName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.SalesByCategory.categoryName\n    )\n    \n    \/\/\/ Type information for property ``SalesByCategory\/productName`` (`ProductName` column).\n    public let productName = MappedColumn<NorthwindLighter.SalesByCategory, String?>(\n      externalName: \"ProductName\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.SalesByCategory.productName\n    )\n    \n    \/\/\/ Type information for property ``SalesByCategory\/productSales`` (`ProductSales` column).\n    public let productSales = MappedColumn<NorthwindLighter.SalesByCategory, String?>(\n      externalName: \"ProductSales\",\n      defaultValue: nil,\n      keyPath: \\NorthwindLighter.SalesByCategory.productSales\n    )\n    \n    #if swift(>=5.7)\n    public var _allColumns : [ any SQLColumn ] { [ categoryID, categoryName, productName, productSales ] }\n    #endif \/\/ swift(>=5.7)\n  }\n  \n  \/**\n   * Initialize a ``SalesByCategory`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM Sales by Category\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = SalesByCategory(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      categoryID: (indices.idx_categoryID >= 0) && (indices.idx_categoryID < argc) ? (sqlite3_column_type(statement, indices.idx_categoryID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_categoryID)) : nil) : Self.schema.categoryID.defaultValue,\n      categoryName: (indices.idx_categoryName >= 0) && (indices.idx_categoryName < argc) ? (sqlite3_column_text(statement, indices.idx_categoryName).flatMap(String.init(cString:))) : Self.schema.categoryName.defaultValue,\n      productName: (indices.idx_productName >= 0) && (indices.idx_productName < argc) ? (sqlite3_column_text(statement, indices.idx_productName).flatMap(String.init(cString:))) : Self.schema.productName.defaultValue,\n      productSales: (indices.idx_productSales >= 0) && (indices.idx_productSales < argc) ? (sqlite3_column_text(statement, indices.idx_productSales).flatMap(String.init(cString:))) : Self.schema.productSales.defaultValue\n    )\n  }\n  \n  \/**\n   * Bind all ``SalesByCategory`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE Sales by Category SET lastname = ?, firstname = ? WHERE person_id = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = SalesByCategory(categoryID: 1, categoryName: \"Hello\", productName: \"World\", productSales: \"Duck\")\n   * let ok = record.bind(to: statement, indices: ( 1, 2, 3, 4 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_categoryID >= 0 {\n      if let categoryID = categoryID {\n        sqlite3_bind_int64(statement, indices.idx_categoryID, Int64(categoryID))\n      }\n      else {\n        sqlite3_bind_null(statement, indices.idx_categoryID)\n      }\n    }\n    return try NorthwindLighter.withOptCString(categoryName) { ( s ) in\n      if indices.idx_categoryName >= 0 {\n        sqlite3_bind_text(statement, indices.idx_categoryName, s, -1, nil)\n      }\n      return try NorthwindLighter.withOptCString(productName) { ( s ) in\n        if indices.idx_productName >= 0 {\n          sqlite3_bind_text(statement, indices.idx_productName, s, -1, nil)\n        }\n        return try NorthwindLighter.withOptCString(productSales) { ( s ) in\n          if indices.idx_productSales >= 0 {\n            sqlite3_bind_text(statement, indices.idx_productSales, s, -1, nil)\n          }\n          return try execute()\n        }\n      }\n    }\n  }\n}\n","SwiftMapping":{"keys":{"autodetectForeignKeysInViews":true,"autodetectWithTableName":true,"autodetectForeignKeys":true,"primaryKeyName":"id","autodetect":["id","ID","Id","pkey","primaryKey","PrimaryKey","key","Key"]},"slashReplacementStringForIDs":"__","propertyNames":{"decapitalize":true,"camelCase":true},"recordReferenceNames":{"pluralize":true,"decapitalize":true},"recordTypeNames":{"camelCase":true,"singularize":true,"capitalize":true},"databaseTypeName":"NorthwindLighter","spaceReplacementStringForIDs":"_","typeMap":{"url":"url","URL":"url","TIMESTAMP":"date","uuid":"uuid","DECIMAL":"decimal","decimal":"decimal","Data":"date","datetime":"date","timestamp":"date","DATETIME":"date","UUID":"uuid"},"CoreData":{"removeZAndLowercasePropertyNames":true,"removeZAndCapitalizeRecordNames":true},"columnSuffixToType":{"url":"url","URL":"url","TIMESTAMP":"date","uuid":"uuid","DECIMAL":"decimal","decimal":"decimal","Data":"date","datetime":"date","timestamp":"date","DATETIME":"date","UUID":"uuid"},"relationships":{"deriveFromForeignKeys":false,"strippedForeignKeySuffixes":["_id","_ID","id","ID","Id","_fkey","_fk","_foreignKey","ForeignKey","_key","_Key","key","Key"]},"minusReplacementStringForIDs":"_"},"CodeGeneration":{"commentsWithSQL":true,"showViewHintComment":true,"optionalHelpersInDatabase":true,"inlinable":true,"allowFoundation":false,"swiftFilters":false,"propertyIndexPrefix":"idx_","extraRecordTypeConformances":["Codable"],"dateSerialization":"text","uuidSerialization":"bytes","qualifiedSelf":false,"Raw":{"hashable":true,"relationships":true},"recordTypeAliasSuffix":"RecordType","embedRecordTypesInDatabaseType":true,"Lighter":{"import":"import","relationships":true,"useSQLiteValueTypeBinds":false,"Examples":{"select":true}},"public":true,"generateAsyncFunctions":false,"readOnly":true,"omitCreationSQL":true}}